---
title: HTML 模板标签
description: 学��� HTML5 的 template 元素和 slot 元素，了解如何使用原生模板功能创建可复用的组件
pubDate: 2025-11-28
toc: true
ogImage: true
category: HTML
---

HTML5 引入了 `<template>` 元素，让我们可以在 HTML 中定义可复用的模板。配合 JavaScript 和 Web Components，可以创建真正的组件化开发体验。

## template 元素

`<template>` 元素用于定义 HTML 模板，其内容不会被渲染，也不会执行脚本或加载资源。

### 基本用法

```html
<!-- 定义模板 -->
<template id="card-template">
  <div class="card">
    <h3 class="card-title"></h3>
    <p class="card-content"></p>
  </div>
</template>

<div id="container"></div>

<script>
  // 获取模板
  const template = document.getElementById('card-template')

  // 克隆模板内容
  const clone = template.content.cloneNode(true)

  // 填充数据
  clone.querySelector('.card-title').textContent = '卡片标题'
  clone.querySelector('.card-content').textContent = '卡片内容'

  // 添加到页面
  document.getElementById('container').appendChild(clone)
</script>
```

### template 的特点

```html
<template id="demo">
  <!-- 不会渲染 -->
  <p>这段文字不会显示</p>

  <!-- 不会加载 -->
  <img src="image.jpg" alt="不会请求" />

  <!-- 不会执行 -->
  <script>
    console.log('不会执行')
  </script>
</template>
```

模板内容：

- 不会在页面上显示
- 图片不会加载
- 脚本不会执行
- 样式不会应用
- ���到被克隆并添加到 DOM

### 访问模板内容

```javascript
const template = document.getElementById('my-template')

// template.content 是一个 DocumentFragment
const content = template.content

// 查询模板内的元素
const title = content.querySelector('h2')

// 克隆内容（深克隆）
const clone = content.cloneNode(true)
```

## 实际应用示例

### 列表渲染

```html
<template id="list-item-template">
  <li class="list-item">
    <span class="item-name"></span>
    <span class="item-price"></span>
    <button class="delete-btn">删除</button>
  </li>
</template>

<ul id="product-list"></ul>

<script>
  const products = [
    { name: '产品 A', price: 99 },
    { name: '产品 B', price: 199 },
    { name: '产品 C', price: 299 },
  ]

  const template = document.getElementById('list-item-template')
  const list = document.getElementById('product-list')

  products.forEach((product) => {
    const clone = template.content.cloneNode(true)

    clone.querySelector('.item-name').textContent = product.name
    clone.querySelector('.item-price').textContent = `¥${product.price}`

    clone.querySelector('.delete-btn').addEventListener('click', function () {
      this.closest('.list-item').remove()
    })

    list.appendChild(clone)
  })
</script>
```

### 卡片组件

```html
<template id="user-card-template">
  <article class="user-card">
    <img class="avatar" src="" alt="" />
    <div class="info">
      <h3 class="name"></h3>
      <p class="bio"></p>
      <div class="stats">
        <span class="followers"></span>
        <span class="following"></span>
      </div>
    </div>
  </article>
</template>

<div id="users"></div>

<script>
  function createUserCard(user) {
    const template = document.getElementById('user-card-template')
    const clone = template.content.cloneNode(true)

    const card = clone.querySelector('.user-card')
    card.querySelector('.avatar').src = user.avatar
    card.querySelector('.avatar').alt = `${user.name}的头像`
    card.querySelector('.name').textContent = user.name
    card.querySelector('.bio').textContent = user.bio
    card.querySelector('.followers').textContent = `${user.followers} 粉丝`
    card.querySelector('.following').textContent = `${user.following} 关注`

    return clone
  }

  const users = [
    {
      name: '张三',
      avatar: 'avatar1.jpg',
      bio: '前端开发者',
      followers: 100,
      following: 50,
    },
    {
      name: '李四',
      avatar: 'avatar2.jpg',
      bio: 'UI 设计师',
      followers: 200,
      following: 80,
    },
  ]

  const container = document.getElementById('users')
  users.forEach((user) => {
    container.appendChild(createUserCard(user))
  })
</script>
```

### 模态对话框

```html
<template id="modal-template">
  <div class="modal-overlay">
    <div
      class="modal"
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
    >
      <header class="modal-header">
        <h2 id="modal-title" class="modal-title"></h2>
        <button class="modal-close" aria-label="关闭">&times;</button>
      </header>
      <div class="modal-body"></div>
      <footer class="modal-footer">
        <button class="btn-cancel">取消</button>
        <button class="btn-confirm">确定</button>
      </footer>
    </div>
  </div>
</template>

<script>
  function createModal(options) {
    const { title, content, onConfirm, onCancel } = options

    const template = document.getElementById('modal-template')
    const clone = template.content.cloneNode(true)

    const overlay = clone.querySelector('.modal-overlay')
    const modal = clone.querySelector('.modal')

    modal.querySelector('.modal-title').textContent = title
    modal.querySelector('.modal-body').innerHTML = content

    // 关闭按钮
    modal.querySelector('.modal-close').addEventListener('click', close)

    // 取消按钮
    modal.querySelector('.btn-cancel').addEventListener('click', () => {
      onCancel?.()
      close()
    })

    // 确定按钮
    modal.querySelector('.btn-confirm').addEventListener('click', () => {
      onConfirm?.()
      close()
    })

    // 点击遮罩关闭
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        close()
      }
    })

    // ESC 关闭
    function handleKeydown(e) {
      if (e.key === 'Escape') {
        close()
      }
    }

    function close() {
      overlay.remove()
      document.removeEventListener('keydown', handleKeydown)
    }

    document.addEventListener('keydown', handleKeydown)
    document.body.appendChild(clone)

    // 聚焦到模态框
    modal.querySelector('.btn-confirm').focus()
  }

  // 使用
  createModal({
    title: '确认删除',
    content: '<p>确定要删除这条记录吗？</p>',
    onConfirm: () => console.log('确认'),
    onCancel: () => console.log('取消'),
  })
</script>
```

## slot 元素

`<slot>` 元素用于 Web Components 中，定义内容插槽。

### 基本插槽

```html
<!-- 定义组件模板 -->
<template id="alert-template">
  <div class="alert">
    <slot>默认内容</slot>
  </div>
</template>

<script>
  class AlertBox extends HTMLElement {
    constructor() {
      super()
      const shadow = this.attachShadow({ mode: 'open' })
      const template = document.getElementById('alert-template')
      shadow.appendChild(template.content.cloneNode(true))
    }
  }

  customElements.define('alert-box', AlertBox)
</script>

<!-- 使用组件 -->
<alert-box>这是警告内容</alert-box>
<alert-box></alert-box>
<!-- 显示默认内容 -->
```

### 具名插槽

```html
<template id="card-template">
  <style>
    .card {
      border: 1px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
    }
    .card-header {
      background: #f5f5f5;
      padding: 16px;
    }
    .card-body {
      padding: 16px;
    }
    .card-footer {
      background: #f5f5f5;
      padding: 16px;
    }
  </style>

  <div class="card">
    <div class="card-header">
      <slot name="header">默认标题</slot>
    </div>
    <div class="card-body">
      <slot>默认内容</slot>
    </div>
    <div class="card-footer">
      <slot name="footer">默认底部</slot>
    </div>
  </div>
</template>

<script>
  class CustomCard extends HTMLElement {
    constructor() {
      super()
      const shadow = this.attachShadow({ mode: 'open' })
      const template = document.getElementById('card-template')
      shadow.appendChild(template.content.cloneNode(true))
    }
  }

  customElements.define('custom-card', CustomCard)
</script>

<!-- 使用组件 -->
<custom-card>
  <h3 slot="header">卡片标题</h3>
  <p>这是卡片的主要内容</p>
  <button slot="footer">操作按钮</button>
</custom-card>
```

### slot 事件

```javascript
class MyComponent extends HTMLElement {
  constructor() {
    super()
    const shadow = this.attachShadow({ mode: 'open' })

    const template = document.getElementById('my-template')
    shadow.appendChild(template.content.cloneNode(true))

    // 监听插槽变化
    const slot = shadow.querySelector('slot')
    slot.addEventListener('slotchange', (e) => {
      const assignedNodes = slot.assignedNodes()
      console.log('插槽内容变化:', assignedNodes)
    })
  }
}
```

## Web Components 完整示例

### 自定义按钮组件

```html
<template id="fancy-button-template">
  <style>
    :host {
      display: inline-block;
    }

    button {
      padding: 12px 24px;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }

    :host([variant='primary']) button {
      background: #007bff;
      color: white;
    }

    :host([variant='secondary']) button {
      background: #6c757d;
      color: white;
    }

    :host([variant='danger']) button {
      background: #dc3545;
      color: white;
    }

    button:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    :host([disabled]) button {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>

  <button>
    <slot>按钮</slot>
  </button>
</template>

<script>
  class FancyButton extends HTMLElement {
    static get observedAttributes() {
      return ['disabled', 'variant']
    }

    constructor() {
      super()
      const shadow = this.attachShadow({ mode: 'open' })
      const template = document.getElementById('fancy-button-template')
      shadow.appendChild(template.content.cloneNode(true))

      this.button = shadow.querySelector('button')

      this.button.addEventListener('click', (e) => {
        if (this.hasAttribute('disabled')) {
          e.preventDefault()
          e.stopPropagation()
          return
        }

        this.dispatchEvent(
          new CustomEvent('fancy-click', {
            bubbles: true,
            detail: { originalEvent: e },
          })
        )
      })
    }

    attributeChangedCallback(name, oldValue, newValue) {
      if (name === 'disabled') {
        this.button.disabled = newValue !== null
      }
    }
  }

  customElements.define('fancy-button', FancyButton)
</script>

<!-- 使用 -->
<fancy-button variant="primary">主要按钮</fancy-button>
<fancy-button variant="secondary">次要按钮</fancy-button>
<fancy-button variant="danger" disabled>禁用按钮</fancy-button>

<script>
  document
    .querySelector('fancy-button')
    .addEventListener('fancy-click', (e) => {
      console.log('按钮被点击')
    })
</script>
```

### 标签页组件

```html
<template id="tabs-template">
  <style>
    .tabs-header {
      display: flex;
      border-bottom: 1px solid #ddd;
    }

    .tab-button {
      padding: 12px 24px;
      border: none;
      background: none;
      cursor: pointer;
      border-bottom: 2px solid transparent;
    }

    .tab-button.active {
      border-bottom-color: #007bff;
      color: #007bff;
    }

    .tabs-content {
      padding: 16px;
    }

    ::slotted([slot^='panel']) {
      display: none;
    }

    ::slotted([slot^='panel'].active) {
      display: block;
    }
  </style>

  <div class="tabs">
    <div class="tabs-header">
      <slot name="tabs"></slot>
    </div>
    <div class="tabs-content">
      <slot name="panels"></slot>
    </div>
  </div>
</template>

<template id="tab-template">
  <button class="tab-button" role="tab">
    <slot></slot>
  </button>
</template>

<template id="panel-template">
  <div class="tab-panel" role="tabpanel">
    <slot></slot>
  </div>
</template>

<script>
  class TabGroup extends HTMLElement {
    constructor() {
      super()
      const shadow = this.attachShadow({ mode: 'open' })
      const template = document.getElementById('tabs-template')
      shadow.appendChild(template.content.cloneNode(true))
    }

    connectedCallback() {
      const tabs = this.querySelectorAll('tab-item')
      const panels = this.querySelectorAll('tab-panel')

      tabs.forEach((tab, index) => {
        tab.addEventListener('click', () => {
          this.selectTab(index)
        })
      })

      // 默认选中第一个
      this.selectTab(0)
    }

    selectTab(index) {
      const tabs = this.querySelectorAll('tab-item')
      const panels = this.querySelectorAll('tab-panel')

      tabs.forEach((tab, i) => {
        tab.classList.toggle('active', i === index)
      })

      panels.forEach((panel, i) => {
        panel.classList.toggle('active', i === index)
      })
    }
  }

  customElements.define('tab-group', TabGroup)
  customElements.define('tab-item', class extends HTMLElement {})
  customElements.define('tab-panel', class extends HTMLElement {})
</script>

<!-- 使用 -->
<tab-group>
  <tab-item slot="tabs">标签 1</tab-item>
  <tab-item slot="tabs">标签 2</tab-item>
  <tab-item slot="tabs">标签 3</tab-item>

  <tab-panel slot="panels">内容 1</tab-panel>
  <tab-panel slot="panels">内容 2</tab-panel>
  <tab-panel slot="panels">内容 3</tab-panel>
</tab-group>
```

## 模板与数据绑定

### 简单的模板引擎

```html
<template id="user-template">
  <div class="user">
    <img src="{{avatar}}" alt="{{name}}的头像" />
    <h3>{{name}}</h3>
    <p>{{bio}}</p>
  </div>
</template>

<script>
  function render(template, data) {
    let html = template.innerHTML

    for (const [key, value] of Object.entries(data)) {
      html = html.replace(new RegExp(`{{${key}}}`, 'g'), value)
    }

    const temp = document.createElement('template')
    temp.innerHTML = html
    return temp.content.cloneNode(true)
  }

  const template = document.getElementById('user-template')
  const userData = {
    name: '张三',
    avatar: 'avatar.jpg',
    bio: '前端开发者',
  }

  document.body.appendChild(render(template, userData))
</script>
```

### 条件渲染

```html
<template id="item-template">
  <div class="item">
    <span class="name">{{name}}</span>
    <span class="status {{statusClass}}">{{status}}</span>
  </div>
</template>

<script>
  function renderItem(item) {
    const template = document.getElementById('item-template')
    const clone = template.content.cloneNode(true)

    clone.querySelector('.name').textContent = item.name

    const status = clone.querySelector('.status')
    status.textContent = item.active ? '在线' : '离线'
    status.classList.add(item.active ? 'online' : 'offline')

    return clone
  }
</script>
```

## 浏览器兼容性

`<template>` 元素得到所有现代浏览器的支持：

| 浏览器  | 支持版本 |
| ------- | -------- |
| Chrome  | 26+      |
| Firefox | 22+      |
| Safari  | 8+       |
| Edge    | 13+      |

对于不支持的浏览器，可以使用 polyfill 或检测：

```javascript
if ('content' in document.createElement('template')) {
  // 支持 template
} else {
  // 不支持，使用替代方案
}
```

## 最佳实践

### 模板命名

```html
<!-- 使用描述性的 ID -->
<template id="product-card-template">...</template>
<template id="user-list-item-template">...</template>
<template id="error-message-template">...</template>
```

### 模板组织

```html
<!-- 将模板放在一起 -->
<div id="templates" hidden>
  <template id="template-1">...</template>
  <template id="template-2">...</template>
  <template id="template-3">...</template>
</div>

<!-- 或者放在文档末尾 -->
<body>
  <!-- 页面内容 -->

  <!-- 模板定义 -->
  <template id="template-1">...</template>
</body>
```

### 复用模板工厂

```javascript
class TemplateFactory {
  constructor() {
    this.cache = new Map()
  }

  get(id) {
    if (!this.cache.has(id)) {
      const template = document.getElementById(id)
      if (!template) {
        throw new Error(`Template ${id} not found`)
      }
      this.cache.set(id, template)
    }
    return this.cache.get(id)
  }

  create(id, data = {}) {
    const template = this.get(id)
    const clone = template.content.cloneNode(true)

    // 填充数据
    for (const [selector, value] of Object.entries(data)) {
      const el = clone.querySelector(selector)
      if (el) {
        if (typeof value === 'string') {
          el.textContent = value
        } else if (typeof value === 'object') {
          Object.assign(el, value)
        }
      }
    }

    return clone
  }
}

const templates = new TemplateFactory()

// 使用
const card = templates.create('card-template', {
  '.title': '标题',
  '.content': '内容',
  '.image': { src: 'image.jpg', alt: '图片' },
})
```

## 小结

HTML 模板标签提供了原生的模板功能：

**template 元素**：

- 定义可复用的 HTML 片段
- 内容不会被渲染
- 通过 `content.cloneNode(true)` 使用

**slot 元素**：

- 用于 Web Components
- 支持默认内容和具名插槽
- 实现内容分发

**使用场景**：

- 列表渲染
- 组件模板
- 动态内容生成

**优点**：

- 原生支持，无需库
- 性能好
- 与 Web Components 配合

模板标签是构建现代 Web 应用的重要工具，下一篇会介绍 iframe 与嵌入内容。
