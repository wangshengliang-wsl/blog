---
title: ES7 与 ES8 新特性
description: ES2016 引入 includes 和指数运算符，ES2017 带来 Object.values/entries、字符串填充等实用特性
pubDate: 2025-11-28
toc: true
ogImage: true
category: ES6+
---

从 ES6 (2015) 开始，TC39 采用了年度发布机制。每年 6 月发布新版本，版本号从年份命名（如 ES2016）逐渐替代了传统的数字命名（如 ES7）。ES7 和 ES8 的更新规模相对较小，但都是实用性很强的特性。

## ES7 (ES2016)

ES2016 是新发布机制下的第一个版本，只包含两个新特性。

### Array.prototype.includes()

在 ES6 之前，检查数组是否包含某个元素通常用 `indexOf`：

```javascript
const arr = [1, 2, 3, NaN]

// ES5 方式
arr.indexOf(2) !== -1 // true
arr.indexOf(4) !== -1 // false

// indexOf 的问题：无法检测 NaN
arr.indexOf(NaN) // -1，找不到
```

`includes` 方法直接返回布尔值，语义更清晰，并且能正确处理 `NaN`：

```javascript
const arr = [1, 2, 3, NaN]

arr.includes(2) // true
arr.includes(4) // false
arr.includes(NaN) // true，能正确识别 NaN
```

`includes` 接受第二个参数指定搜索的起始位置：

```javascript
const arr = ['a', 'b', 'c', 'd']

arr.includes('b', 2) // false，从索引 2 开始搜索
arr.includes('b', 1) // true

// 负数索引从末尾计算
arr.includes('b', -3) // true，等同于从索引 1 开始
```

**`includes` 与 `indexOf` 的区别**

| 特性           | `includes`                   | `indexOf`          |
| -------------- | ---------------------------- | ------------------ |
| 返回值         | 布尔值                       | 索引或 -1          |
| NaN 处理       | 能找到                       | 找不到             |
| undefined 处理 | 能找到稀疏数组中的 undefined | 能找到             |
| 用途           | 判断存在性                   | 需要知道位置时使用 |

```javascript
// 稀疏数组中的 undefined
const sparse = [1, , 3] // 索引 1 是空位

sparse.includes(undefined) // true
sparse.indexOf(undefined) // -1
```

### 指数运算符 (\*\*)

ES7 引入了指数运算符 `**`，替代 `Math.pow()`：

```javascript
// ES6 之前
Math.pow(2, 10) // 1024
Math.pow(2, 0.5) // 1.4142135623730951

// ES7
2 ** 10 // 1024
2 ** 0.5 // 1.4142135623730951
```

指数运算符是右结合的：

```javascript
// 右结合：从右向左计算
2 **
  (3 **
    (2(
      // 512，等同于 2 ** (3 ** 2) = 2 ** 9

      // 对比左结合
      2 ** 3
    ) **
      2)) // 64
```

支持赋值运算符形式：

```javascript
let n = 2
n **= 10 // 1024，等同于 n = n ** 10
```

负数底数需要加括号：

```javascript
// 语法错误
// -2 ** 2

// 正确写法
;(-2) ** 2 - // 4
  2 ** 2 // -4
```

与 `Math.pow` 的行为一致：

```javascript
2 ** 3 === Math.pow(2, 3) // true
10 ** -2 // 0.01
27 ** (1 / 3) // 3，立方根
```

## ES8 (ES2017)

ES2017 的更新较多，涵盖对象方法、字符串方法和语法改进。

### Object.values()

返回对象自身可枚举属性的值组成的数组，顺序与 `for...in` 一致：

```javascript
const user = {
  name: '张三',
  age: 25,
  city: '北京',
}

Object.values(user) // ['张三', 25, '北京']

// 配合解构使用
const [name, age] = Object.values(user)
```

只返回自身属性，不包括继承的属性：

```javascript
const parent = { inherited: true }
const child = Object.create(parent)
child.own = 'value'

Object.values(child) // ['value']，不含 inherited
```

数字键按升序排列：

```javascript
const obj = { 10: 'a', 2: 'b', 1: 'c' }
Object.values(obj) // ['c', 'b', 'a']
```

### Object.entries()

返回对象自身可枚举属性的键值对数组：

```javascript
const user = {
  name: '张三',
  age: 25,
}

Object.entries(user) // [['name', '张三'], ['age', 25]]
```

配合 `for...of` 和解构，遍历对象更方便：

```javascript
const scores = {
  math: 95,
  english: 88,
  chinese: 92,
}

for (const [subject, score] of Object.entries(scores)) {
  console.log(`${subject}: ${score}`)
}
// math: 95
// english: 88
// chinese: 92
```

可以轻松将对象转为 Map：

```javascript
const obj = { a: 1, b: 2 }
const map = new Map(Object.entries(obj))

map.get('a') // 1
```

### String.prototype.padStart() / padEnd()

字符串填充方法，用于在字符串开头或结尾填充字符到指定长度：

```javascript
// padStart：在开头填充
'5'.padStart(2, '0') // '05'
'123'.padStart(5, '0') // '00123'
'hello'.padStart(10, 'ab') // 'ababahello'

// padEnd：在结尾填充
'5'.padEnd(2, '0') // '50'
'123'.padEnd(5, '0') // '12300'
'hello'.padEnd(10, 'ab') // 'helloababa'
```

常见应用场景：

```javascript
// 格式化数字
const num = 7
String(num).padStart(2, '0') // '07'

// 时间格式化
const hour = 9
const minute = 5`${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}` // '09:05'

// 金额格式化
const price = '99'
price.padStart(8, ' ') + ' 元' // '      99 元'

// 生成固定长度 ID
const id = '42'
id.padStart(6, '0') // '000042'

// 隐藏敏感信息
const phone = '13812345678'
phone.slice(-4).padStart(11, '*') // '*******5678'
```

如果原字符串长度大于等于目标长度，返回原字符串：

```javascript
'hello'.padStart(3, '*') // 'hello'
'hello'.padEnd(3, '*') // 'hello'
```

省略第二个参数时，默认用空格填充：

```javascript
'5'.padStart(3) // '  5'
```

### Object.getOwnPropertyDescriptors()

返回对象所有自身属性的描述符。ES5 的 `Object.getOwnPropertyDescriptor` 只能获取单个属性的描述符，这个方法可以一次获取全部：

```javascript
const obj = {
  name: '张三',
  get fullName() {
    return this.name
  },
}

Object.getOwnPropertyDescriptors(obj)
/*
{
  name: {
    value: '张三',
    writable: true,
    enumerable: true,
    configurable: true
  },
  fullName: {
    get: [Function: get fullName],
    set: undefined,
    enumerable: true,
    configurable: true
  }
}
*/
```

这个方法主要用于解决 `Object.assign` 无法正确复制 getter/setter 的问题：

```javascript
const source = {
  _name: '张三',
  get name() {
    return this._name
  },
  set name(val) {
    this._name = val
  },
}

// Object.assign 的问题：getter 被转成了普通属性
const copy1 = Object.assign({}, source)
Object.getOwnPropertyDescriptor(copy1, 'name')
// { value: '张三', writable: true, enumerable: true, configurable: true }
// getter/setter 丢失了

// 使用 getOwnPropertyDescriptors 完整复制
const copy2 = Object.defineProperties(
  {},
  Object.getOwnPropertyDescriptors(source)
)
Object.getOwnPropertyDescriptor(copy2, 'name')
// { get: [Function], set: [Function], enumerable: true, configurable: true }
// getter/setter 保留了
```

配合 `Object.create` 实现完整的对象克隆：

```javascript
const clone = (obj) =>
  Object.create(
    Object.getPrototypeOf(obj),
    Object.getOwnPropertyDescriptors(obj)
  )

const original = {
  data: [1, 2, 3],
  get length() {
    return this.data.length
  },
}

const cloned = clone(original)
cloned.length // 3
```

### 函数参数尾逗号

ES8 允许函数参数列表和调用时的参数列表末尾有逗号：

```javascript
// 函数定义
function fn(
  param1,
  param2 // 尾逗号
) {
  // ...
}

// 函数调用
fn(
  arg1,
  arg2 // 尾逗号
)

// 箭头函数
const arrow = (
  a,
  b // 尾逗号
) => a + b
```

这个改动主要是为了方便版本控制。添加新参数时，diff 只显示新增的一行，而不会因为补逗号而修改前一行：

```diff
function example(
  param1,
  param2,
+ param3,
)
```

数组和对象字面量早在 ES5 就支持尾逗号，ES8 将这种一致性扩展到了函数参数。

---

ES7 和 ES8 的更新虽然不多，但都是日常开发中高频使用的特性。`includes` 让数组查找更直观，`Object.values/entries` 简化了对象遍历，`padStart/padEnd` 解决了字符串格式化的痛点。这些小而精的改进体现了 TC39 年度发布机制的特点：快速迭代，稳步增强。
