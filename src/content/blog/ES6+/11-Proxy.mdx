---
title: Proxy 代理机制
description: 深入理解 ES6 Proxy 代理机制，掌握 13 种拦截操作、可撤销代理，以及在数据验证、响应式系统中的实战应用
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

Proxy 是 ES6 引入的元编程特性，可以拦截和自定义对象的基本操作。Vue 3 的响应式系统、数据验证、访问控制等场景都依赖 Proxy 实现。

## Proxy 基本概念

Proxy 用于创建一个对象的代理，从而拦截和自定义该对象的基本操作（如属性查找、赋值、枚举等）。

### 基本语法

```javascript
const proxy = new Proxy(target, handler)
```

- `target`：要代理的目标对象
- `handler`：定义拦截行为的对象

### 简单示例

```javascript
const target = {
  name: '张三',
  age: 25,
}

const handler = {
  get(target, prop, receiver) {
    console.log(`Getting ${prop}`)
    return target[prop]
  },
  set(target, prop, value, receiver) {
    console.log(`Setting ${prop} = ${value}`)
    target[prop] = value
    return true
  },
}

const proxy = new Proxy(target, handler)

console.log(proxy.name) // 'Getting name', '张三'
proxy.age = 26 // 'Setting age = 26'
```

## 13 种拦截操作

Proxy 支持 13 种拦截操作（trap）。

### get(target, prop, receiver)

拦截属性读取：

```javascript
const handler = {
  get(target, prop, receiver) {
    if (prop in target) {
      return target[prop]
    }
    throw new ReferenceError(`Property "${prop}" does not exist`)
  },
}

const proxy = new Proxy({ name: '张三' }, handler)
console.log(proxy.name) // '张三'
// console.log(proxy.age); // ReferenceError: Property "age" does not exist
```

### set(target, prop, value, receiver)

拦截属性设置：

```javascript
const handler = {
  set(target, prop, value, receiver) {
    if (prop === 'age' && typeof value !== 'number') {
      throw new TypeError('Age must be a number')
    }
    if (prop === 'age' && (value < 0 || value > 150)) {
      throw new RangeError('Age must be between 0 and 150')
    }
    target[prop] = value
    return true // 表示设置成功
  },
}

const proxy = new Proxy({}, handler)
proxy.age = 25 // 正常
// proxy.age = '25'; // TypeError: Age must be a number
// proxy.age = 200;  // RangeError: Age must be between 0 and 150
```

### has(target, prop)

拦截 `in` 操作符：

```javascript
const handler = {
  has(target, prop) {
    if (prop.startsWith('_')) {
      return false // 隐藏私有属性
    }
    return prop in target
  },
}

const proxy = new Proxy({ name: '张三', _secret: '秘密' }, handler)
console.log('name' in proxy) // true
console.log('_secret' in proxy) // false
```

### deleteProperty(target, prop)

拦截 `delete` 操作：

```javascript
const handler = {
  deleteProperty(target, prop) {
    if (prop.startsWith('_')) {
      throw new Error('Cannot delete private property')
    }
    delete target[prop]
    return true
  },
}

const proxy = new Proxy({ name: '张三', _id: 1 }, handler)
delete proxy.name // 正常
// delete proxy._id; // Error: Cannot delete private property
```

### ownKeys(target)

拦截 `Object.keys()`、`Object.getOwnPropertyNames()` 等：

```javascript
const handler = {
  ownKeys(target) {
    return Object.keys(target).filter((key) => !key.startsWith('_'))
  },
}

const proxy = new Proxy({ name: '张三', age: 25, _secret: '秘密' }, handler)

console.log(Object.keys(proxy)) // ['name', 'age']
```

### getOwnPropertyDescriptor(target, prop)

拦截 `Object.getOwnPropertyDescriptor()`：

```javascript
const handler = {
  getOwnPropertyDescriptor(target, prop) {
    if (prop.startsWith('_')) {
      return undefined // 隐藏私有属性描述符
    }
    return Object.getOwnPropertyDescriptor(target, prop)
  },
}
```

### defineProperty(target, prop, descriptor)

拦截 `Object.defineProperty()`：

```javascript
const handler = {
  defineProperty(target, prop, descriptor) {
    if (prop.startsWith('_')) {
      throw new Error('Cannot define private property')
    }
    return Object.defineProperty(target, prop, descriptor)
  },
}
```

### preventExtensions(target)

拦截 `Object.preventExtensions()`：

```javascript
const handler = {
  preventExtensions(target) {
    console.log('Preventing extensions')
    Object.preventExtensions(target)
    return true
  },
}
```

### getPrototypeOf(target)

拦截 `Object.getPrototypeOf()`：

```javascript
const handler = {
  getPrototypeOf(target) {
    return { custom: true }
  },
}

const proxy = new Proxy({}, handler)
console.log(Object.getPrototypeOf(proxy)) // { custom: true }
```

### setPrototypeOf(target, proto)

拦截 `Object.setPrototypeOf()`：

```javascript
const handler = {
  setPrototypeOf(target, proto) {
    throw new Error('Changing prototype is forbidden')
  },
}
```

### isExtensible(target)

拦截 `Object.isExtensible()`：

```javascript
const handler = {
  isExtensible(target) {
    return Object.isExtensible(target)
  },
}
```

### apply(target, thisArg, argumentsList)

拦截函数调用：

```javascript
const handler = {
  apply(target, thisArg, args) {
    console.log(`Calling with args: ${args}`)
    return target.apply(thisArg, args)
  },
}

const sum = new Proxy(function (a, b) {
  return a + b
}, handler)
console.log(sum(1, 2)) // 'Calling with args: 1,2', 3
```

### construct(target, argumentsList, newTarget)

拦截 `new` 操作：

```javascript
const handler = {
  construct(target, args, newTarget) {
    console.log(`Creating instance with args: ${args}`)
    return new target(...args)
  },
}

const Person = new Proxy(function (name) {
  this.name = name
}, handler)

const p = new Person('张三') // 'Creating instance with args: 张三'
console.log(p.name) // '张三'
```

## Proxy.revocable()

创建可撤销的代理：

```javascript
const target = { name: '张三' }
const { proxy, revoke } = Proxy.revocable(target, {
  get(target, prop) {
    return target[prop]
  },
})

console.log(proxy.name) // '张三'

revoke() // 撤销代理

// console.log(proxy.name); // TypeError: Cannot perform 'get' on a proxy that has been revoked
```

应用场景：

```javascript
// 临时授权
function createTemporaryAccess(data, duration) {
  const { proxy, revoke } = Proxy.revocable(data, {})

  setTimeout(() => {
    revoke()
    console.log('Access revoked')
  }, duration)

  return proxy
}

const tempData = createTemporaryAccess({ secret: '机密' }, 5000)
console.log(tempData.secret) // '机密'
// 5 秒后无法访问
```

## this 指向问题

Proxy 代理的对象中，`this` 会指向 Proxy 实例而非原对象：

```javascript
const target = {
  m() {
    console.log(this === proxy)
  },
}

const proxy = new Proxy(target, {})

target.m() // false
proxy.m() // true
```

某些原生对象依赖内部槽位，需要绑定正确的 `this`：

```javascript
const target = new Date()
const proxy = new Proxy(target, {})

// proxy.getDate(); // TypeError: this is not a Date object

// 解决方案
const handler = {
  get(target, prop) {
    const value = target[prop]
    if (typeof value === 'function') {
      return value.bind(target)
    }
    return value
  },
}

const proxy2 = new Proxy(target, handler)
console.log(proxy2.getDate()) // 正常工作
```

## 实战应用

### 数据验证

```javascript
function createValidator(schema) {
  return new Proxy(
    {},
    {
      set(target, prop, value) {
        const validator = schema[prop]
        if (!validator) {
          throw new Error(`Unknown property: ${prop}`)
        }
        if (!validator.validate(value)) {
          throw new Error(`Invalid value for ${prop}: ${validator.message}`)
        }
        target[prop] = value
        return true
      },
    }
  )
}

const userSchema = {
  name: {
    validate: (v) => typeof v === 'string' && v.length > 0,
    message: 'must be a non-empty string',
  },
  age: {
    validate: (v) => Number.isInteger(v) && v >= 0 && v <= 150,
    message: 'must be an integer between 0 and 150',
  },
  email: {
    validate: (v) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v),
    message: 'must be a valid email',
  },
}

const user = createValidator(userSchema)
user.name = '张三'
user.age = 25
user.email = 'zhangsan@example.com'
// user.age = -1; // Error: Invalid value for age: must be an integer between 0 and 150
```

### 响应式系统（Vue 3 原理）

```javascript
const reactiveMap = new WeakMap()

function reactive(target) {
  if (reactiveMap.has(target)) {
    return reactiveMap.get(target)
  }

  const proxy = new Proxy(target, {
    get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver)
      track(target, prop) // 收集依赖
      if (typeof value === 'object' && value !== null) {
        return reactive(value) // 深度响应
      }
      return value
    },
    set(target, prop, value, receiver) {
      const oldValue = target[prop]
      const result = Reflect.set(target, prop, value, receiver)
      if (oldValue !== value) {
        trigger(target, prop) // 触发更新
      }
      return result
    },
  })

  reactiveMap.set(target, proxy)
  return proxy
}

// 简化的依赖收集和触发
const targetMap = new WeakMap()
let activeEffect = null

function track(target, prop) {
  if (!activeEffect) return
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  let dep = depsMap.get(prop)
  if (!dep) {
    depsMap.set(prop, (dep = new Set()))
  }
  dep.add(activeEffect)
}

function trigger(target, prop) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return
  const dep = depsMap.get(prop)
  if (dep) {
    dep.forEach((effect) => effect())
  }
}

function effect(fn) {
  activeEffect = fn
  fn()
  activeEffect = null
}

// 使用
const state = reactive({ count: 0 })
effect(() => {
  console.log('Count:', state.count)
})

state.count++ // 'Count: 1'
state.count++ // 'Count: 2'
```

### 属性访问日志

```javascript
function createLogger(target, name = 'Object') {
  return new Proxy(target, {
    get(target, prop, receiver) {
      console.log(`[${name}] GET ${String(prop)}`)
      return Reflect.get(target, prop, receiver)
    },
    set(target, prop, value, receiver) {
      console.log(`[${name}] SET ${String(prop)} = ${JSON.stringify(value)}`)
      return Reflect.set(target, prop, value, receiver)
    },
    deleteProperty(target, prop) {
      console.log(`[${name}] DELETE ${String(prop)}`)
      return Reflect.deleteProperty(target, prop)
    },
  })
}

const user = createLogger({ name: '张三', age: 25 }, 'User')
user.name // '[User] GET name'
user.age = 26 // '[User] SET age = 26'
delete user.name // '[User] DELETE name'
```

### 默认值和计算属性

```javascript
function withDefaults(target, defaults) {
  return new Proxy(target, {
    get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver)
      if (value === undefined && prop in defaults) {
        const defaultValue = defaults[prop]
        return typeof defaultValue === 'function'
          ? defaultValue(target)
          : defaultValue
      }
      return value
    },
  })
}

const config = withDefaults(
  { host: 'localhost' },
  {
    port: 3000,
    protocol: 'http',
    url: (target) =>
      `${target.protocol || 'http'}://${target.host}:${target.port || 3000}`,
  }
)

console.log(config.host) // 'localhost'
console.log(config.port) // 3000
console.log(config.protocol) // 'http'
console.log(config.url) // 'http://localhost:3000'
```

### 单例模式

```javascript
function singleton(className) {
  let instance
  return new Proxy(className, {
    construct(target, args) {
      if (!instance) {
        instance = new target(...args)
      }
      return instance
    },
  })
}

class Database {
  constructor() {
    console.log('Database created')
  }
}

const SingletonDatabase = singleton(Database)

const db1 = new SingletonDatabase() // 'Database created'
const db2 = new SingletonDatabase() // 不输出，返回已有实例
console.log(db1 === db2) // true
```

### 负索引数组

```javascript
function createNegativeArray(arr) {
  return new Proxy(arr, {
    get(target, prop, receiver) {
      let index = Number(prop)
      if (Number.isInteger(index) && index < 0) {
        index = target.length + index
      }
      return Reflect.get(target, index >= 0 ? index : prop, receiver)
    },
  })
}

const arr = createNegativeArray([1, 2, 3, 4, 5])
console.log(arr[-1]) // 5
console.log(arr[-2]) // 4
console.log(arr[0]) // 1
```

### 只读对象

```javascript
function readonly(target) {
  return new Proxy(target, {
    set() {
      console.warn('Cannot modify readonly object')
      return true
    },
    deleteProperty() {
      console.warn('Cannot delete property from readonly object')
      return true
    },
    defineProperty() {
      console.warn('Cannot define property on readonly object')
      return true
    },
  })
}

const config = readonly({ apiKey: 'secret', endpoint: '/api' })
config.apiKey = 'hacked' // 'Cannot modify readonly object'
console.log(config.apiKey) // 'secret'
```

## 性能考量

Proxy 会带来一定的性能开销，因为每次操作都会经过 handler 处理。在性能敏感的场景中：

```javascript
// 1. 避免在热路径中使用 Proxy
// 2. 减少 handler 中的复杂逻辑
// 3. 考虑使用缓存

// 缓存示例
const cache = new WeakMap()

function cachedProxy(target, handler) {
  if (cache.has(target)) {
    return cache.get(target)
  }
  const proxy = new Proxy(target, handler)
  cache.set(target, proxy)
  return proxy
}
```

---

Proxy 是 JavaScript 元编程的核心工具，它提供了拦截和自定义对象操作的能力。从数据验证到响应式系统，从访问控制到日志记录，Proxy 的应用场景非常广泛。理解 Proxy 的工作原理对于理解现代前端框架（如 Vue 3）至关重要。
