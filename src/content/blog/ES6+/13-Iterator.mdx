---
title: Iterator 与 for...of
description: 深入理解 ES6 迭代器协议和可迭代协议，掌握 for...of 循环的工作原理，以及自定义迭代器的实现方法
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

迭代器（Iterator）是 ES6 引入的一种统一的遍历机制。它为不同的数据结构提供了统一的访问接口，使得 `for...of` 循环可以遍历各种数据结构。

## 迭代器协议

### 什么是迭代器

迭代器是一个对象，它提供 `next()` 方法，每次调用返回一个包含 `value` 和 `done` 属性的对象：

```javascript
// 手动实现一个迭代器
function createIterator(items) {
  let index = 0
  return {
    next() {
      if (index < items.length) {
        return { value: items[index++], done: false }
      }
      return { value: undefined, done: true }
    },
  }
}

const iterator = createIterator([1, 2, 3])

console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next()) // { value: 2, done: false }
console.log(iterator.next()) // { value: 3, done: false }
console.log(iterator.next()) // { value: undefined, done: true }
```

### 迭代器协议规范

迭代器对象必须实现 `next()` 方法，返回值的格式为：

```typescript
interface IteratorResult {
  value: any // 当前值
  done: boolean // 是否完成
}
```

还可以选择实现 `return()` 和 `throw()` 方法：

```javascript
const iterator = {
  next() {
    return { value: 1, done: false }
  },
  return() {
    console.log('Iterator closed')
    return { done: true }
  },
  throw(e) {
    console.log('Error:', e)
    return { done: true }
  },
}
```

## 可迭代协议

### Symbol.iterator

可迭代对象必须实现 `Symbol.iterator` 方法，该方法返回一个迭代器：

```javascript
const iterable = {
  [Symbol.iterator]() {
    let count = 0
    return {
      next() {
        if (count < 3) {
          return { value: count++, done: false }
        }
        return { value: undefined, done: true }
      },
    }
  },
}

// 使用 for...of
for (const value of iterable) {
  console.log(value) // 0, 1, 2
}

// 使用展开运算符
console.log([...iterable]) // [0, 1, 2]
```

### 内置可迭代对象

以下类型原生实现了可迭代协议：

```javascript
// 数组
for (const item of [1, 2, 3]) {
  console.log(item)
}

// 字符串
for (const char of 'hello') {
  console.log(char)
}

// Set
for (const value of new Set([1, 2, 3])) {
  console.log(value)
}

// Map
for (const [key, value] of new Map([
  ['a', 1],
  ['b', 2],
])) {
  console.log(key, value)
}

// arguments
function foo() {
  for (const arg of arguments) {
    console.log(arg)
  }
}
foo(1, 2, 3)

// NodeList
const divs = document.querySelectorAll('div')
for (const div of divs) {
  console.log(div)
}

// TypedArray
for (const byte of new Uint8Array([1, 2, 3])) {
  console.log(byte)
}
```

### 检查可迭代性

```javascript
function isIterable(obj) {
  return obj != null && typeof obj[Symbol.iterator] === 'function'
}

console.log(isIterable([1, 2, 3])) // true
console.log(isIterable('hello')) // true
console.log(isIterable({})) // false
console.log(isIterable(123)) // false
```

## for...of 循环

### 基本用法

`for...of` 循环遍历可迭代对象的值：

```javascript
const arr = ['a', 'b', 'c']

// for...of 遍历值
for (const value of arr) {
  console.log(value) // 'a', 'b', 'c'
}

// 对比 for...in 遍历键
for (const key in arr) {
  console.log(key) // '0', '1', '2'
}
```

### 与数组方法的对比

```javascript
const arr = [1, 2, 3]

// for...of 可以使用 break、continue、return
for (const value of arr) {
  if (value === 2) break
  console.log(value) // 1
}

// forEach 不能使用 break
arr.forEach((value) => {
  // if (value === 2) break; // SyntaxError
  console.log(value)
})
```

### 遍历 entries

获取索引和值：

```javascript
const arr = ['a', 'b', 'c']

for (const [index, value] of arr.entries()) {
  console.log(index, value)
}
// 0 'a'
// 1 'b'
// 2 'c'

// Map 原生支持
const map = new Map([
  ['x', 1],
  ['y', 2],
])
for (const [key, value] of map) {
  console.log(key, value)
}
```

## 自定义可迭代对象

### 基本实现

```javascript
class Range {
  constructor(start, end, step = 1) {
    this.start = start
    this.end = end
    this.step = step
  }

  [Symbol.iterator]() {
    let current = this.start
    const end = this.end
    const step = this.step

    return {
      next() {
        if (current <= end) {
          const value = current
          current += step
          return { value, done: false }
        }
        return { value: undefined, done: true }
      },
    }
  }
}

const range = new Range(1, 5)
console.log([...range]) // [1, 2, 3, 4, 5]

for (const n of new Range(0, 10, 2)) {
  console.log(n) // 0, 2, 4, 6, 8, 10
}
```

### 使用 Generator 简化

Generator 函数返回的对象同时实现了迭代器协议和可迭代协议：

```javascript
class Range {
  constructor(start, end, step = 1) {
    this.start = start
    this.end = end
    this.step = step
  }

  *[Symbol.iterator]() {
    for (let i = this.start; i <= this.end; i += this.step) {
      yield i
    }
  }
}

console.log([...new Range(1, 5)]) // [1, 2, 3, 4, 5]
```

### 链表遍历

```javascript
class LinkedList {
  constructor() {
    this.head = null
    this.tail = null
  }

  append(value) {
    const node = { value, next: null }
    if (!this.head) {
      this.head = node
      this.tail = node
    } else {
      this.tail.next = node
      this.tail = node
    }
  }

  *[Symbol.iterator]() {
    let current = this.head
    while (current) {
      yield current.value
      current = current.next
    }
  }
}

const list = new LinkedList()
list.append(1)
list.append(2)
list.append(3)

console.log([...list]) // [1, 2, 3]
```

### 树的遍历

```javascript
class TreeNode {
  constructor(value, children = []) {
    this.value = value
    this.children = children
  }

  // 深度优先遍历
  *[Symbol.iterator]() {
    yield this.value
    for (const child of this.children) {
      yield* child
    }
  }

  // 广度优先遍历
  *bfs() {
    const queue = [this]
    while (queue.length > 0) {
      const node = queue.shift()
      yield node.value
      queue.push(...node.children)
    }
  }
}

const tree = new TreeNode(1, [
  new TreeNode(2, [new TreeNode(4), new TreeNode(5)]),
  new TreeNode(3, [new TreeNode(6)]),
])

console.log([...tree]) // [1, 2, 4, 5, 3, 6]（深度优先）
console.log([...tree.bfs()]) // [1, 2, 3, 4, 5, 6]（广度优先）
```

## 迭代器的 return() 方法

当迭代提前终止时（break、throw、return），会调用迭代器的 `return()` 方法：

```javascript
const iterable = {
  [Symbol.iterator]() {
    let index = 0
    return {
      next() {
        console.log('next called')
        return { value: index++, done: index > 5 }
      },
      return() {
        console.log('return called')
        return { done: true }
      },
    }
  },
}

for (const value of iterable) {
  console.log(value)
  if (value >= 2) break
}
// 'next called', 0
// 'next called', 1
// 'next called', 2
// 'return called'
```

这对于资源清理很有用：

```javascript
function* fileLines(path) {
  const file = openFile(path)
  try {
    while (true) {
      const line = file.readLine()
      if (line === null) return
      yield line
    }
  } finally {
    file.close() // 确保文件被关闭
  }
}

for (const line of fileLines('/path/to/file')) {
  console.log(line)
  if (line.includes('target')) break // finally 块仍会执行
}
```

## 消费可迭代对象的语法

以下语法都会消费可迭代对象：

```javascript
const iterable = [1, 2, 3]

// for...of
for (const x of iterable) {
}

// 展开运算符
const arr = [...iterable]

// Array.from
const arr2 = Array.from(iterable)

// 解构赋值
const [a, b, c] = iterable

// Set、Map 构造函数
const set = new Set(iterable)
const map = new Map([
  [1, 'a'],
  [2, 'b'],
])

// Promise.all、Promise.race
Promise.all(iterable)
Promise.race(iterable)

// yield*
function* gen() {
  yield* iterable
}
```

## 让对象可迭代

普通对象默认不可迭代，但可以添加迭代器：

```javascript
// 方式一：直接在对象上定义
const obj = {
  name: '张三',
  age: 25,
  city: '北京',

  [Symbol.iterator]() {
    const keys = Object.keys(this)
    let index = 0

    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++]
          return { value: [key, this[key]], done: false }
        }
        return { value: undefined, done: true }
      },
    }
  },
}

for (const [key, value] of obj) {
  console.log(key, value)
}
// 'name' '张三'
// 'age' 25
// 'city' '北京'

// 方式二：通过 Object.entries
for (const [key, value] of Object.entries(obj)) {
  console.log(key, value)
}
```

## 无限迭代器

```javascript
// 无限递增
function* infiniteCounter(start = 0) {
  while (true) {
    yield start++
  }
}

// 无限循环
function* cycle(arr) {
  while (true) {
    yield* arr
  }
}

// 使用时需要限制
const counter = infiniteCounter()
for (let i = 0; i < 5; i++) {
  console.log(counter.next().value) // 0, 1, 2, 3, 4
}

// 配合 take 函数
function* take(iterable, n) {
  let count = 0
  for (const item of iterable) {
    if (count >= n) return
    yield item
    count++
  }
}

console.log([...take(cycle([1, 2, 3]), 7)])
// [1, 2, 3, 1, 2, 3, 1]
```

## 实战应用

### 分页迭代器

```javascript
async function* paginate(fetchFn, pageSize = 10) {
  let page = 1
  while (true) {
    const data = await fetchFn(page, pageSize)
    if (data.length === 0) return
    yield* data
    page++
  }
}

// 使用
const fetchUsers = async (page, size) => {
  const response = await fetch(`/api/users?page=${page}&size=${size}`)
  return response.json()
}

for await (const user of paginate(fetchUsers)) {
  console.log(user)
  if (shouldStop) break
}
```

### 惰性求值

```javascript
function* map(iterable, fn) {
  for (const item of iterable) {
    yield fn(item)
  }
}

function* filter(iterable, predicate) {
  for (const item of iterable) {
    if (predicate(item)) yield item
  }
}

function* take(iterable, n) {
  let count = 0
  for (const item of iterable) {
    if (count++ >= n) return
    yield item
  }
}

// 惰性处理大数据集
function* range(start, end) {
  for (let i = start; i <= end; i++) yield i
}

const result = take(
  filter(
    map(range(1, 1000000), (x) => x * 2),
    (x) => x % 3 === 0
  ),
  5
)

console.log([...result]) // [6, 12, 18, 24, 30]
// 只计算了需要的值，不会处理全部 1000000 个数
```

### 状态机

```javascript
function* trafficLight() {
  while (true) {
    yield 'green'
    yield 'yellow'
    yield 'red'
  }
}

const light = trafficLight()
console.log(light.next().value) // 'green'
console.log(light.next().value) // 'yellow'
console.log(light.next().value) // 'red'
console.log(light.next().value) // 'green'
```

---

迭代器协议为 JavaScript 提供了统一的遍历接口。通过实现 `Symbol.iterator` 方法，任何对象都可以变成可迭代的，从而支持 `for...of` 循环和展开运算符等语法。配合 Generator 函数，可以轻松实现惰性求值、无限序列、异步迭代等高级功能。
