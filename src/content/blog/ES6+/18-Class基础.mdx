---
title: Class 类的基本语法
description: 深入掌握 ES6 Class 语法，理解构造函数、实例方法、静态成员、私有字段、访问器属性等核心概念，以及与传统原型继承的关系
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

ES6 引入了 Class 语法，为 JavaScript 提供了更清晰、更符合传统面向对象编程习惯的类定义方式。Class 本质上是构造函数的语法糖，但它让代码更加简洁和易于理解。

## Class 基本概念

### 传统构造函数 vs Class

ES5 使用构造函数和原型实现"类"：

```javascript
// ES5 构造函数方式
function Person(name, age) {
  this.name = name
  this.age = age
}

Person.prototype.sayHello = function () {
  console.log(`Hello, I'm ${this.name}`)
}

Person.staticMethod = function () {
  console.log('Static method')
}

const person = new Person('张三', 25)
person.sayHello() // "Hello, I'm 张三"
```

ES6 使用 Class 语法：

```javascript
// ES6 Class 方式
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  sayHello() {
    console.log(`Hello, I'm ${this.name}`)
  }

  static staticMethod() {
    console.log('Static method')
  }
}

const person = new Person('张三', 25)
person.sayHello() // "Hello, I'm 张三"
```

### Class 的本质

Class 只是语法糖，本质上仍然是函数：

```javascript
class Point {}

typeof Point // 'function'
Point === Point.prototype.constructor // true

// 类的方法定义在 prototype 上
class Foo {
  method() {}
}

Foo.prototype.method // [Function: method]
```

### 类声明和类表达式

```javascript
// 类声明
class Rectangle {
  constructor(width, height) {
    this.width = width
    this.height = height
  }
}

// 类表达式（匿名）
const Rectangle = class {
  constructor(width, height) {
    this.width = width
    this.height = height
  }
}

// 类表达式（具名）
const Rectangle = class RectangleClass {
  constructor(width, height) {
    this.width = width
    this.height = height
  }
  // RectangleClass 只能在类内部使用
}

console.log(Rectangle.name) // 'RectangleClass'
// console.log(RectangleClass); // ReferenceError
```

### 类声明不提升

与函数声明不同，类声明不会提升：

```javascript
// 错误：不能在声明前使用
// const p = new Person(); // ReferenceError

class Person {}

// 函数声明会提升
foo() // 正常
function foo() {}
```

### 严格模式

类内部默认使用严格模式：

```javascript
class StrictClass {
  method() {
    // 自动启用严格模式
    // 'use strict';
    // x = 1; // ReferenceError: x is not defined
  }
}
```

## constructor 构造函数

### 基本用法

`constructor` 是类的构造函数，用于创建和初始化实例：

```javascript
class Person {
  constructor(name) {
    // this 指向新创建的实例
    this.name = name
    this.createdAt = new Date()
  }
}

const person = new Person('张三')
console.log(person.name) // '张三'
console.log(person.createdAt) // 当前时间
```

### 默认 constructor

如果不定义 constructor，会自动添加空的构造函数：

```javascript
class Empty {}

// 等价于
class Empty {
  constructor() {}
}
```

### constructor 的返回值

constructor 默认返回 `this`（实例对象），也可以返回其他对象：

```javascript
class Foo {
  constructor() {
    return { custom: true }
  }
}

const foo = new Foo()
console.log(foo.custom) // true
console.log(foo instanceof Foo) // false
```

### 必须使用 new 调用

类必须通过 `new` 调用，不能当作普通函数调用：

```javascript
class Foo {}

new Foo() // 正确
// Foo();   // TypeError: Class constructor Foo cannot be invoked without 'new'
```

## 实例属性和方法

### 实例属性

在 constructor 中定义实例属性：

```javascript
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
}
```

ES2022 支持类字段语法，可以在类体中直接定义：

```javascript
class Person {
  // 类字段（实例属性）
  name = ''
  age = 0
  hobbies = []

  constructor(name, age) {
    this.name = name
    this.age = age
  }
}

const p = new Person('张三', 25)
console.log(p.hobbies) // []（每个实例独立的数组）
```

### 实例方法

定义在类体中的方法默认是实例方法，存在于原型上：

```javascript
class Calculator {
  constructor(value = 0) {
    this.value = value
  }

  add(n) {
    this.value += n
    return this
  }

  subtract(n) {
    this.value -= n
    return this
  }

  multiply(n) {
    this.value *= n
    return this
  }

  getResult() {
    return this.value
  }
}

// 链式调用
const result = new Calculator(10).add(5).multiply(2).subtract(3).getResult()

console.log(result) // 27
```

### 方法简写

类中的方法使用简写语法：

```javascript
class Foo {
  // 方法简写
  method() {}

  // 等价于 ES5
  // method: function() {}

  // 异步方法
  async asyncMethod() {}

  // 生成器方法
  *generatorMethod() {}

  // 异步生成器
  async *asyncGeneratorMethod() {}
}
```

### 计算属性名

可以使用计算属性名定义方法：

```javascript
const methodName = 'dynamicMethod'
const symbolMethod = Symbol('method')

class Foo {
  [methodName]() {
    return 'dynamic'
  }

  [symbolMethod]() {
    return 'symbol method'
  }

  ['get' + 'Value']() {
    return 42
  }
}

const foo = new Foo()
console.log(foo.dynamicMethod()) // 'dynamic'
console.log(foo[symbolMethod]()) // 'symbol method'
console.log(foo.getValue()) // 42
```

## 静态成员

### 静态方法

使用 `static` 关键字定义静态方法，静态方法属于类本身而非实例：

```javascript
class MathUtils {
  static add(a, b) {
    return a + b
  }

  static multiply(a, b) {
    return a * b
  }

  static PI = 3.14159
}

// 通过类名调用
console.log(MathUtils.add(1, 2)) // 3
console.log(MathUtils.multiply(3, 4)) // 12
console.log(MathUtils.PI) // 3.14159

// 不能通过实例调用
const utils = new MathUtils()
// utils.add(1, 2); // TypeError: utils.add is not a function
```

### 静态属性

ES2022 支持静态字段：

```javascript
class Config {
  static apiUrl = 'https://api.example.com'
  static timeout = 5000
  static #privateStatic = 'secret'

  static getPrivate() {
    return this.#privateStatic
  }
}

console.log(Config.apiUrl) // 'https://api.example.com'
console.log(Config.timeout) // 5000
console.log(Config.getPrivate()) // 'secret'
```

### 静态方法中的 this

静态方法中的 `this` 指向类本身：

```javascript
class Foo {
  static classMethod() {
    console.log(this === Foo) // true
    return new this()
  }

  static create() {
    return new this()
  }
}

const instance = Foo.create()
console.log(instance instanceof Foo) // true
```

### 静态块（Static Block）

ES2022 引入静态块，用于复杂的静态初始化：

```javascript
class Database {
  static connection
  static config

  static {
    // 静态初始化块
    try {
      this.config = loadConfig()
      this.connection = createConnection(this.config)
    } catch (e) {
      this.config = getDefaultConfig()
      this.connection = null
    }
  }

  static isConnected() {
    return this.connection !== null
  }
}
```

静态块可以访问私有字段：

```javascript
class Foo {
  static #privateField

  static {
    this.#privateField = 'initialized in static block'
  }

  static getPrivate() {
    return this.#privateField
  }
}
```

## 私有成员

### 私有字段（ES2022）

使用 `#` 前缀定义私有字段：

```javascript
class Person {
  #name
  #age

  constructor(name, age) {
    this.#name = name
    this.#age = age
  }

  getName() {
    return this.#name
  }

  getAge() {
    return this.#age
  }

  setAge(age) {
    if (age > 0 && age < 150) {
      this.#age = age
    }
  }
}

const person = new Person('张三', 25)
console.log(person.getName()) // '张三'
console.log(person.getAge()) // 25

// 外部无法访问私有字段
// console.log(person.#name); // SyntaxError
// console.log(person['#name']); // undefined（这是普通属性，不是私有字段）
```

### 私有方法

```javascript
class BankAccount {
  #balance = 0

  deposit(amount) {
    if (this.#validateAmount(amount)) {
      this.#balance += amount
      this.#log('deposit', amount)
    }
  }

  withdraw(amount) {
    if (this.#validateAmount(amount) && this.#balance >= amount) {
      this.#balance -= amount
      this.#log('withdraw', amount)
      return true
    }
    return false
  }

  getBalance() {
    return this.#balance
  }

  #validateAmount(amount) {
    return typeof amount === 'number' && amount > 0
  }

  #log(action, amount) {
    console.log(`${action}: ${amount}, balance: ${this.#balance}`)
  }
}

const account = new BankAccount()
account.deposit(100) // 'deposit: 100, balance: 100'
account.withdraw(30) // 'withdraw: 30, balance: 70'

// account.#validateAmount(50); // SyntaxError
```

### 私有静态成员

```javascript
class Counter {
  static #count = 0

  static #increment() {
    return ++this.#count
  }

  constructor() {
    this.id = Counter.#increment()
  }

  static getCount() {
    return this.#count
  }
}

const c1 = new Counter()
const c2 = new Counter()
const c3 = new Counter()

console.log(c1.id) // 1
console.log(c2.id) // 2
console.log(c3.id) // 3
console.log(Counter.getCount()) // 3
```

### 检查私有字段存在性

使用 `in` 操作符检查私有字段：

```javascript
class Foo {
  #brand

  static isFoo(obj) {
    return #brand in obj
  }
}

const foo = new Foo()
console.log(Foo.isFoo(foo)) // true
console.log(Foo.isFoo({})) // false
```

## 访问器属性

### getter 和 setter

使用 `get` 和 `set` 关键字定义访问器：

```javascript
class Circle {
  #radius

  constructor(radius) {
    this.#radius = radius
  }

  // getter
  get radius() {
    return this.#radius
  }

  // setter
  set radius(value) {
    if (value > 0) {
      this.#radius = value
    } else {
      throw new Error('Radius must be positive')
    }
  }

  get diameter() {
    return this.#radius * 2
  }

  get area() {
    return Math.PI * this.#radius ** 2
  }

  get circumference() {
    return 2 * Math.PI * this.#radius
  }
}

const circle = new Circle(5)
console.log(circle.radius) // 5
console.log(circle.diameter) // 10
console.log(circle.area) // 78.539...
console.log(circle.circumference) // 31.415...

circle.radius = 10
console.log(circle.diameter) // 20
```

### 只读属性

只定义 getter 不定义 setter 可以创建只读属性：

```javascript
class Rectangle {
  #width
  #height

  constructor(width, height) {
    this.#width = width
    this.#height = height
  }

  get width() {
    return this.#width
  }

  get height() {
    return this.#height
  }

  get area() {
    return this.#width * this.#height
  }
}

const rect = new Rectangle(10, 5)
console.log(rect.area) // 50

// rect.area = 100; // 严格模式下会报错，非严格模式下静默失败
```

### 静态访问器

```javascript
class Config {
  static #settings = {
    theme: 'dark',
    language: 'zh-CN',
  }

  static get theme() {
    return this.#settings.theme
  }

  static set theme(value) {
    if (['light', 'dark'].includes(value)) {
      this.#settings.theme = value
    }
  }

  static get language() {
    return this.#settings.language
  }

  static set language(value) {
    this.#settings.language = value
  }
}

console.log(Config.theme) // 'dark'
Config.theme = 'light'
console.log(Config.theme) // 'light'
```

## this 指向问题

### 方法中的 this

类方法中的 `this` 指向调用者：

```javascript
class Logger {
  prefix = '[LOG]'

  log(message) {
    console.log(`${this.prefix} ${message}`)
  }
}

const logger = new Logger()
logger.log('Hello') // '[LOG] Hello'

// 单独提取方法会丢失 this
const { log } = logger
// log('Hello'); // TypeError: Cannot read property 'prefix' of undefined
```

### 解决方案一：bind

```javascript
class Logger {
  constructor() {
    this.log = this.log.bind(this)
  }

  prefix = '[LOG]'

  log(message) {
    console.log(`${this.prefix} ${message}`)
  }
}

const logger = new Logger()
const { log } = logger
log('Hello') // '[LOG] Hello'
```

### 解决方案二：箭头函数

```javascript
class Logger {
  prefix = '[LOG]'

  // 箭头函数作为类字段
  log = (message) => {
    console.log(`${this.prefix} ${message}`)
  }
}

const logger = new Logger()
const { log } = logger
log('Hello') // '[LOG] Hello'
```

注意：箭头函数方法会为每个实例创建新函数，而非共享原型方法。

### 解决方案三：Proxy

```javascript
function bindAll(instance) {
  const proto = Object.getPrototypeOf(instance)
  const methodNames = Object.getOwnPropertyNames(proto).filter(
    (name) => name !== 'constructor' && typeof proto[name] === 'function'
  )

  for (const name of methodNames) {
    instance[name] = instance[name].bind(instance)
  }

  return instance
}

class Logger {
  prefix = '[LOG]'

  constructor() {
    bindAll(this)
  }

  log(message) {
    console.log(`${this.prefix} ${message}`)
  }
}
```

## 类的继承预览

虽然继承会在下一篇详细讲解，这里简单介绍基本语法：

```javascript
class Animal {
  constructor(name) {
    this.name = name
  }

  speak() {
    console.log(`${this.name} makes a sound.`)
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name) // 调用父类构造函数
    this.breed = breed
  }

  speak() {
    console.log(`${this.name} barks.`)
  }

  fetch() {
    console.log(`${this.name} fetches the ball.`)
  }
}

const dog = new Dog('Buddy', 'Golden Retriever')
dog.speak() // 'Buddy barks.'
dog.fetch() // 'Buddy fetches the ball.'
```

## 实战应用

### 单例模式

```javascript
class Singleton {
  static #instance = null

  constructor() {
    if (Singleton.#instance) {
      return Singleton.#instance
    }
    Singleton.#instance = this
  }

  static getInstance() {
    if (!this.#instance) {
      this.#instance = new Singleton()
    }
    return this.#instance
  }
}

const s1 = new Singleton()
const s2 = new Singleton()
const s3 = Singleton.getInstance()

console.log(s1 === s2) // true
console.log(s2 === s3) // true
```

### 工厂模式

```javascript
class Vehicle {
  constructor(type, brand) {
    this.type = type
    this.brand = brand
  }

  static create(type, brand) {
    switch (type) {
      case 'car':
        return new Car(brand)
      case 'motorcycle':
        return new Motorcycle(brand)
      case 'bicycle':
        return new Bicycle(brand)
      default:
        throw new Error(`Unknown vehicle type: ${type}`)
    }
  }
}

class Car extends Vehicle {
  constructor(brand) {
    super('car', brand)
    this.wheels = 4
  }
}

class Motorcycle extends Vehicle {
  constructor(brand) {
    super('motorcycle', brand)
    this.wheels = 2
  }
}

class Bicycle extends Vehicle {
  constructor(brand) {
    super('bicycle', brand)
    this.wheels = 2
    this.motorized = false
  }
}

const car = Vehicle.create('car', 'Toyota')
const bike = Vehicle.create('bicycle', 'Giant')
```

### 观察者模式

```javascript
class EventEmitter {
  #listeners = new Map()

  on(event, callback) {
    if (!this.#listeners.has(event)) {
      this.#listeners.set(event, new Set())
    }
    this.#listeners.get(event).add(callback)
    return this
  }

  off(event, callback) {
    const callbacks = this.#listeners.get(event)
    if (callbacks) {
      callbacks.delete(callback)
    }
    return this
  }

  emit(event, ...args) {
    const callbacks = this.#listeners.get(event)
    if (callbacks) {
      for (const callback of callbacks) {
        callback.apply(this, args)
      }
    }
    return this
  }

  once(event, callback) {
    const wrapper = (...args) => {
      callback.apply(this, args)
      this.off(event, wrapper)
    }
    return this.on(event, wrapper)
  }
}

// 使用
const emitter = new EventEmitter()

emitter.on('message', (msg) => console.log('Received:', msg))
emitter.once('connect', () => console.log('Connected!'))

emitter.emit('connect') // 'Connected!'
emitter.emit('connect') // 无输出（once 只触发一次）
emitter.emit('message', 'Hello') // 'Received: Hello'
```

### 数据验证类

```javascript
class Validator {
  #rules = []
  #value

  constructor(value) {
    this.#value = value
  }

  static of(value) {
    return new Validator(value)
  }

  required(message = 'Value is required') {
    this.#rules.push({
      test: (v) => v !== null && v !== undefined && v !== '',
      message,
    })
    return this
  }

  minLength(min, message = `Minimum length is ${min}`) {
    this.#rules.push({
      test: (v) => String(v).length >= min,
      message,
    })
    return this
  }

  maxLength(max, message = `Maximum length is ${max}`) {
    this.#rules.push({
      test: (v) => String(v).length <= max,
      message,
    })
    return this
  }

  pattern(regex, message = 'Invalid format') {
    this.#rules.push({
      test: (v) => regex.test(String(v)),
      message,
    })
    return this
  }

  custom(testFn, message = 'Validation failed') {
    this.#rules.push({
      test: testFn,
      message,
    })
    return this
  }

  validate() {
    const errors = []
    for (const rule of this.#rules) {
      if (!rule.test(this.#value)) {
        errors.push(rule.message)
      }
    }
    return {
      valid: errors.length === 0,
      errors,
    }
  }
}

// 使用
const result = Validator.of('abc')
  .required()
  .minLength(2)
  .maxLength(10)
  .pattern(/^[a-z]+$/, 'Only lowercase letters allowed')
  .validate()

console.log(result) // { valid: true, errors: [] }

const result2 = Validator.of('A1')
  .required()
  .minLength(5)
  .pattern(/^[a-z]+$/)
  .validate()

console.log(result2)
// { valid: false, errors: ['Minimum length is 5', 'Invalid format'] }
```

### 链表实现

```javascript
class LinkedList {
  #head = null
  #tail = null
  #size = 0

  get size() {
    return this.#size
  }

  get isEmpty() {
    return this.#size === 0
  }

  append(value) {
    const node = { value, next: null }

    if (!this.#head) {
      this.#head = node
      this.#tail = node
    } else {
      this.#tail.next = node
      this.#tail = node
    }

    this.#size++
    return this
  }

  prepend(value) {
    const node = { value, next: this.#head }
    this.#head = node

    if (!this.#tail) {
      this.#tail = node
    }

    this.#size++
    return this
  }

  find(predicate) {
    let current = this.#head
    while (current) {
      if (predicate(current.value)) {
        return current.value
      }
      current = current.next
    }
    return undefined
  }

  remove(value) {
    if (!this.#head) return false

    if (this.#head.value === value) {
      this.#head = this.#head.next
      if (!this.#head) this.#tail = null
      this.#size--
      return true
    }

    let current = this.#head
    while (current.next) {
      if (current.next.value === value) {
        current.next = current.next.next
        if (!current.next) this.#tail = current
        this.#size--
        return true
      }
      current = current.next
    }

    return false
  }

  *[Symbol.iterator]() {
    let current = this.#head
    while (current) {
      yield current.value
      current = current.next
    }
  }

  toArray() {
    return [...this]
  }
}

// 使用
const list = new LinkedList()
list.append(1).append(2).append(3).prepend(0)

console.log(list.size) // 4
console.log(list.toArray()) // [0, 1, 2, 3]
console.log([...list]) // [0, 1, 2, 3]

list.remove(2)
console.log(list.toArray()) // [0, 1, 3]
```

## 与原型的关系

### 方法在原型上

```javascript
class Foo {
  method() {}
}

const foo = new Foo()

console.log(foo.hasOwnProperty('method')) // false
console.log(Foo.prototype.hasOwnProperty('method')) // true
console.log(foo.__proto__ === Foo.prototype) // true
```

### 实例属性在实例上

```javascript
class Bar {
  value = 42

  constructor() {
    this.name = 'bar'
  }
}

const bar = new Bar()

console.log(bar.hasOwnProperty('value')) // true
console.log(bar.hasOwnProperty('name')) // true
```

### 原型链

```javascript
class Animal {}
class Dog extends Animal {}

const dog = new Dog()

console.log(dog.__proto__ === Dog.prototype) // true
console.log(Dog.prototype.__proto__ === Animal.prototype) // true
console.log(Animal.prototype.__proto__ === Object.prototype) // true
```

---

ES6 Class 语法让 JavaScript 的面向对象编程更加清晰和规范。私有字段、静态块等新特性的加入，使得类的封装能力更强。理解 Class 本质上仍是基于原型的语法糖，有助于更深入地掌握 JavaScript 的对象模型。在下一篇中，我们将深入探讨类的继承机制。
