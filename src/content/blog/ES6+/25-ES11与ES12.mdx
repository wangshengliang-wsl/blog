---
title: ES11 与 ES12 新特性
description: ES2020 引入可选链、空值合并、BigInt，ES2021 带来 replaceAll、Promise.any、逻辑赋值运算符等特性
pubDate: 2025-11-28
toc: true
ogImage: true
category: ES6+
---

ES11 (2020) 和 ES12 (2021) 带来了一批高频使用的特性。可选链和空值合并运算符彻底改变了处理空值的方式，BigInt 解决了大整数精度问题，逻辑赋值运算符让代码更简洁。

## ES11 (ES2020)

### 可选链 (?.)

可选链运算符 `?.` 在访问深层嵌套属性时，如果中间某个属性是 `null` 或 `undefined`，不会报错而是返回 `undefined`：

```javascript
const user = {
  name: '张三',
  address: {
    city: '北京',
  },
}

// 传统方式：层层判断
const street = user && user.address && user.address.street

// 可选链
const street = user?.address?.street // undefined，不报错
```

可选链有三种形式：

```javascript
// 属性访问
obj?.prop
obj?.['prop']

// 方法调用
obj?.method()

// 数组索引
arr?.[0]
```

各种使用场景：

```javascript
// 访问可能不存在的对象属性
const email = user?.contact?.email

// 调用可能不存在的方法
const result = obj?.callback?.()

// 访问数组元素
const first = arr?.[0]

// 可选方法调用
element?.addEventListener?.('click', handler)

// 配合解构
const { name } = user?.profile ?? {}
```

可选链是短路求值的：

```javascript
let count = 0
const obj = null

obj?.foo(count++) // 不会执行 count++
console.log(count) // 0
```

**不能用于赋值左侧**

```javascript
// 语法错误
obj?.prop = value
```

### 空值合并 (??)

`??` 运算符在左侧是 `null` 或 `undefined` 时返回右侧值：

```javascript
const a = null ?? 'default' // 'default'
const b = undefined ?? 'default' // 'default'
const c = 0 ?? 'default' // 0
const d = '' ?? 'default' // ''
const e = false ?? 'default' // false
```

与 `||` 的区别：

```javascript
// || 对所有 falsy 值都会返回右侧
0 || 100 // 100
'' || 'default' // 'default'
false || true // true

// ?? 只对 null/undefined 返回右侧
0 ?? 100 // 0
'' ?? 'default' // ''
false ?? true // false
```

常见用途：

```javascript
// 设置默认值
const port = config.port ?? 3000
const timeout = options.timeout ?? 5000

// 保留合法的 falsy 值
const count = response.count ?? 0 // count 可能是 0
const name = user.nickname ?? user.name ?? '匿名'

// 配合可选链
const city = user?.address?.city ?? '未知'
```

**不能与 `&&` 或 `||` 混用**（除非加括号）：

```javascript
// 语法错误
a || b ?? c
a && b ?? c

// 正确：加括号明确优先级
(a || b) ?? c
a || (b ?? c)
```

### BigInt

JavaScript 的 `Number` 类型能精确表示的整数范围是 -(2^53 - 1) 到 2^53 - 1。BigInt 可以表示任意大的整数：

```javascript
// Number 的精度问题
9007199254740992 === 9007199254740993 // true，精度丢失

// BigInt 没有精度问题
9007199254740992n === 9007199254740993n // false
```

创建 BigInt：

```javascript
// 字面量：数字后加 n
const big = 123456789012345678901234567890n

// BigInt() 函数
BigInt(123) // 123n
BigInt('123456789012345678901234567890')

// 不能用小数
BigInt(1.5) // RangeError
```

运算规则：

```javascript
// 基本运算
10n + 20n // 30n
100n - 50n // 50n
10n * 20n // 200n
10n / 3n // 3n（向零取整）
10n % 3n // 1n
2n ** 10n // 1024n

// 不能与 Number 混合运算
10n + 5 // TypeError

// 需要显式转换
10n + BigInt(5) // 15n
Number(10n) + 5 // 15
```

比较运算：

```javascript
// 可以与 Number 比较（不需要转换）
10n === 10 // false（类型不同）
10n == 10 // true（值相等）
10n > 5 // true
10n < 20 // true

// 排序
const mixed = [4n, 6, -12n, 10, 4, 0, 0n]
mixed.sort() // [-12n, 0, 0n, 4, 4n, 6, 10]
```

常见用途：

```javascript
// 处理大整数 ID
const userId = 9007199254740993n

// 精确的金融计算（以分为单位）
const price = 19999n // 199.99 元

// 位运算处理大数
const flags = 1n << 64n
```

### Promise.allSettled()

`Promise.allSettled()` 等待所有 Promise 完成（无论成功或失败），返回每个 Promise 的结果：

```javascript
const promises = [
  Promise.resolve(1),
  Promise.reject(new Error('fail')),
  Promise.resolve(3),
]

const results = await Promise.allSettled(promises)
// [
//   { status: 'fulfilled', value: 1 },
//   { status: 'rejected', reason: Error: fail },
//   { status: 'fulfilled', value: 3 }
// ]
```

与 `Promise.all` 的区别：

| 方法                 | 行为                              |
| -------------------- | --------------------------------- |
| `Promise.all`        | 任一 Promise reject 就立即 reject |
| `Promise.allSettled` | 等待所有完成，收集所有结果        |

```javascript
// Promise.all：一个失败就整体失败
Promise.all([Promise.resolve(1), Promise.reject('error')]).catch(console.log)
// 'error'

// Promise.allSettled：收集所有结果
Promise.allSettled([Promise.resolve(1), Promise.reject('error')]).then(
  console.log
)
// [{ status: 'fulfilled', value: 1 }, { status: 'rejected', reason: 'error' }]
```

处理结果：

```javascript
const results = await Promise.allSettled(promises)

// 获取成功的结果
const fulfilled = results
  .filter((r) => r.status === 'fulfilled')
  .map((r) => r.value)

// 获取失败的原因
const rejected = results
  .filter((r) => r.status === 'rejected')
  .map((r) => r.reason)
```

### globalThis

`globalThis` 提供统一的方式访问全局对象，在任何环境下都有效：

```javascript
// 不同环境的全局对象
// 浏览器: window, self, frames
// Node.js: global
// Web Worker: self

// globalThis 统一访问
globalThis.setTimeout === setTimeout // true
```

```javascript
// 跨环境代码
const global =
  typeof globalThis !== 'undefined'
    ? globalThis
    : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
        ? global
        : self

// 现在直接用 globalThis
globalThis.myGlobal = 'value'
```

### String.prototype.matchAll()

`matchAll()` 返回一个迭代器，包含正则表达式的所有匹配结果（包括捕获组）：

```javascript
const str = 'test1test2test3'
const regex = /test(\d)/g

// ES9 之前：循环调用 exec
let match
while ((match = regex.exec(str)) !== null) {
  console.log(match[0], match[1])
}

// ES10：matchAll
const matches = str.matchAll(regex)
for (const match of matches) {
  console.log(match[0], match[1])
}
// test1 1
// test2 2
// test3 3
```

返回的每个匹配包含完整信息：

```javascript
const str = 'Hello World'
const regex = /(\w+)/g

const matches = [...str.matchAll(regex)]
// [
//   ['Hello', 'Hello', index: 0, input: 'Hello World', groups: undefined],
//   ['World', 'World', index: 6, input: 'Hello World', groups: undefined]
// ]
```

配合命名捕获组：

```javascript
const str = '2024-03-15, 2024-04-20'
const regex = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/g

for (const match of str.matchAll(regex)) {
  console.log(match.groups)
}
// { year: '2024', month: '03', day: '15' }
// { year: '2024', month: '04', day: '20' }
```

注意：`matchAll` 要求正则必须带 `g` 标志：

```javascript
'abc'.matchAll(/a/) // TypeError: matchAll must be called with a global RegExp
```

### 动态 import()

`import()` 函数实现动态导入模块，返回 Promise：

```javascript
// 静态 import：必须在顶层
import { foo } from './module.js'

// 动态 import：可以在任何位置
const module = await import('./module.js')
module.foo()
```

常见用途：

```javascript
// 条件加载
if (condition) {
  const { feature } = await import('./feature.js')
  feature()
}

// 按需加载
button.addEventListener('click', async () => {
  const { showModal } = await import('./modal.js')
  showModal()
})

// 根据变量加载
const locale = 'zh-CN'
const messages = await import(`./locales/${locale}.js`)

// 加载默认导出
const { default: MyComponent } = await import('./Component.js')
```

配合 React.lazy：

```javascript
const LazyComponent = React.lazy(() => import('./HeavyComponent'))
```

## ES12 (ES2021)

### String.prototype.replaceAll()

`replaceAll()` 替换字符串中所有匹配项：

```javascript
const str = 'aabbcc'

// replace 只替换第一个
str.replace('b', '_') // 'aa_bcc'

// replaceAll 替换所有
str.replaceAll('b', '_') // 'aa__cc'
```

在 ES2021 之前，替换所有需要用正则：

```javascript
// 旧方式
str.replace(/b/g, '_')

// 新方式
str.replaceAll('b', '_')
```

支持正则表达式（必须带 `g` 标志）：

```javascript
'aAbBcC'.replaceAll(/[A-Z]/g, '_')
// 'a_b_c_'

// 不带 g 会报错
'aAbBcC'.replaceAll(/[A-Z]/, '_')
// TypeError
```

替换函数同样可用：

```javascript
'hello world'.replaceAll(/\w+/g, (match) => match.toUpperCase())
// 'HELLO WORLD'
```

### Promise.any()

`Promise.any()` 返回第一个成功的 Promise，只有所有都失败才 reject：

```javascript
const promises = [
  Promise.reject('error 1'),
  Promise.resolve('success'),
  Promise.reject('error 2'),
]

const result = await Promise.any(promises)
console.log(result) // 'success'
```

与其他 Promise 方法对比：

| 方法                 | 返回时机                   |
| -------------------- | -------------------------- |
| `Promise.race`       | 第一个完成（无论成功失败） |
| `Promise.any`        | 第一个成功                 |
| `Promise.all`        | 所有成功                   |
| `Promise.allSettled` | 所有完成                   |

所有 Promise 都失败时，抛出 `AggregateError`：

```javascript
try {
  await Promise.any([Promise.reject('a'), Promise.reject('b')])
} catch (err) {
  console.log(err instanceof AggregateError) // true
  console.log(err.errors) // ['a', 'b']
  console.log(err.message) // 'All promises were rejected'
}
```

实际应用：

```javascript
// 从多个源获取数据，用最快成功的
const data = await Promise.any([
  fetch('https://api1.example.com/data'),
  fetch('https://api2.example.com/data'),
  fetch('https://api3.example.com/data'),
])
```

### WeakRef 与 FinalizationRegistry

`WeakRef` 创建对象的弱引用，不阻止垃圾回收：

```javascript
let obj = { data: 'important' }
const weakRef = new WeakRef(obj)

// 获取引用的对象（可能返回 undefined）
weakRef.deref() // { data: 'important' }

// 原对象被回收后
obj = null
// 某个时刻垃圾回收后
weakRef.deref() // undefined
```

`FinalizationRegistry` 在对象被垃圾回收时执行回调：

```javascript
const registry = new FinalizationRegistry((heldValue) => {
  console.log(`对象 ${heldValue} 被回收了`)
})

let obj = { name: 'test' }
registry.register(obj, 'myObject')

obj = null
// 垃圾回收后会输出：对象 myObject 被回收了
```

这两个特性主要用于缓存等高级场景：

```javascript
// 简单的弱引用缓存
class WeakCache {
  #cache = new Map()
  #registry = new FinalizationRegistry((key) => {
    this.#cache.delete(key)
  })

  set(key, value) {
    const ref = new WeakRef(value)
    this.#cache.set(key, ref)
    this.#registry.register(value, key)
  }

  get(key) {
    return this.#cache.get(key)?.deref()
  }
}
```

注意：垃圾回收时机不确定，不要依赖 `FinalizationRegistry` 做重要的清理工作。

### 逻辑赋值运算符

三个新的赋值运算符结合了逻辑运算和赋值：

**`||=`（或赋值）**

```javascript
// a ||= b 等价于 a || (a = b)
// 当 a 是 falsy 值时赋值

let a = null
a ||= 'default' // a = 'default'

let b = 'existing'
b ||= 'default' // b = 'existing'（不变）

// 常见用途
options.timeout ||= 5000
user.name ||= '匿名'
```

**`&&=`（与赋值）**

```javascript
// a &&= b 等价于 a && (a = b)
// 当 a 是 truthy 值时赋值

let a = 'value'
a &&= 'new value' // a = 'new value'

let b = null
b &&= 'new value' // b = null（不变）

// 常见用途：有值时更新
obj.prop &&= transform(obj.prop)
```

**`??=`（空值合并赋值）**

```javascript
// a ??= b 等价于 a ?? (a = b)
// 当 a 是 null 或 undefined 时赋值

let a = null
a ??= 'default' // a = 'default'

let b = 0
b ??= 100 // b = 0（不变，0 不是 nullish）

let c = ''
c ??= 'default' // c = ''（不变）

// 常见用途
options.count ??= 0 // 允许 0，只在 null/undefined 时设默认值
cache[key] ??= computeValue(key) // 缓存初始化
```

### 数值分隔符

使用下划线 `_` 作为数字的视觉分隔符，提高可读性：

```javascript
// 大数字更易读
const billion = 1_000_000_000
const bytes = 0xff_ff_ff_ff

// 二进制
const binary = 0b1010_0001_1000_0101

// 八进制
const octal = 0o755_744

// BigInt
const bigInt = 9_007_199_254_740_993n

// 小数部分也可以
const pi = 3.141_592_653
```

分隔符的位置很灵活，但有限制：

```javascript
// 不能连续
// 1__000 // SyntaxError

// 不能在开头或结尾
// _1000 // 这是标识符
// 1000_ // SyntaxError

// 不能紧邻小数点
// 3_.14 // SyntaxError
// 3._14 // SyntaxError

// 不能在进制前缀后
// 0x_ff // SyntaxError
```

字符串转数字时会忽略分隔符：

```javascript
Number('1_000') // NaN（字符串中的 _ 不会被处理）
parseInt('1_000') // 1（遇到 _ 停止解析）

// 直接写字面量没问题
const n = 1_000 // 1000
```

---

ES11 和 ES12 的特性已经成为现代 JavaScript 的标配。可选链和空值合并让空值处理变得简洁安全，BigInt 解决了长期以来的大数精度问题，逻辑赋值运算符让默认值设置更加直观。这些特性在日常开发中使用频率极高。
