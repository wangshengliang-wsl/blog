---
title: 数值的扩展
description: 全面了解 ES6+ 数值处理新特性，包括二进制八进制字面量、Number 新方法、Math 扩展、BigInt 大整数类型及其实战应用
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

JavaScript 的数值处理一直存在一些痛点：浮点数精度问题、大整数溢出、类型判断不严格。ES6 及后续版本对数值相关功能进行了系统性增强，引入了 BigInt 类型来处理任意精度整数，同时补充了大量实用方法。

## 二进制和八进制字面量

ES6 提供了二进制和八进制数值的新写法。

### 二进制（Binary）

用 `0b` 或 `0B` 前缀表示：

```javascript
console.log(0b111) // 7
console.log(0b1010) // 10
console.log(0b11111111) // 255
```

### 八进制（Octal）

ES6 用 `0o` 或 `0O` 前缀表示。这是严格模式下的标准写法，取代了旧的 `0` 前缀（非严格模式下仍可用但不推荐）：

```javascript
console.log(0o7) // 7
console.log(0o10) // 8
console.log(0o77) // 63

// ES5 的旧写法（不推荐，严格模式下报错）
// console.log(077); // 63，但在严格模式下 SyntaxError
```

### 转换

将二进制、八进制字符串转为十进制：

```javascript
console.log(Number('0b111')) // 7
console.log(Number('0o10')) // 8

console.log(parseInt('111', 2)) // 7
console.log(parseInt('10', 8)) // 8
```

十进制转其他进制字符串：

```javascript
const num = 255
console.log(num.toString(2)) // '11111111'
console.log(num.toString(8)) // '377'
console.log(num.toString(16)) // 'ff'
```

## 数值分隔符

ES2021 引入数值分隔符 `_`，提高大数字的可读性：

```javascript
const billion = 1_000_000_000
const bytes = 0xff_ff_ff_ff
const bits = 0b1111_0000_1111_0000
const fraction = 1_234.567_89

console.log(billion) // 1000000000
console.log(bytes) // 4294967295

// 分隔符可以放在任意数字之间
const phone = 138_0000_0000
const creditCard = 1234_5678_9012_3456n
```

限制：

- 不能放在开头或结尾
- 不能连续使用
- 不能放在小数点两侧
- 不能放在进制前缀后

```javascript
// 以下都是错误的
// const a = _1000;
// const b = 1000_;
// const c = 1__000;
// const d = 1._5;
// const e = 0x_FF;
```

## Number 的新方法

ES6 把一些全局方法移到 Number 对象上，使语言设计更加合理。

### Number.isFinite()

检查数值是否是有限的（不是 `Infinity`、`-Infinity` 或 `NaN`）：

```javascript
console.log(Number.isFinite(15)) // true
console.log(Number.isFinite(0.5)) // true
console.log(Number.isFinite(Infinity)) // false
console.log(Number.isFinite(-Infinity)) // false
console.log(Number.isFinite(NaN)) // false

// 与全局 isFinite 的区别：不进行类型转换
console.log(isFinite('15')) // true，隐式转换为数字
console.log(Number.isFinite('15')) // false，字符串直接返回 false
console.log(Number.isFinite(null)) // false
console.log(isFinite(null)) // true，null 转换为 0
```

### Number.isNaN()

检查是否是 `NaN`：

```javascript
console.log(Number.isNaN(NaN)) // true
console.log(Number.isNaN(15)) // false
console.log(Number.isNaN('NaN')) // false
console.log(Number.isNaN(undefined)) // false

// 与全局 isNaN 的区别：不进行类型转换
console.log(isNaN('hello')) // true，字符串转换为 NaN
console.log(Number.isNaN('hello')) // false，不是 NaN 类型
console.log(isNaN(undefined)) // true，undefined 转换为 NaN
console.log(Number.isNaN(undefined)) // false
```

### Number.isInteger()

判断是否为整数：

```javascript
console.log(Number.isInteger(25)) // true
console.log(Number.isInteger(25.0)) // true，25.0 在 JS 中等于 25
console.log(Number.isInteger(25.1)) // false
console.log(Number.isInteger('25')) // false，不进行类型转换
console.log(Number.isInteger(true)) // false
console.log(Number.isInteger(null)) // false
```

注意精度问题：

```javascript
// 超出精度范围可能产生误判
console.log(Number.isInteger(3.0000000000000002)) // true，精度丢失
console.log(Number.isInteger(5e-325)) // true，超小数被当作 0
```

### Number.isSafeInteger()

判断是否是"安全整数"，即在 `-(2^53 - 1)` 到 `2^53 - 1` 范围内的整数：

```javascript
console.log(Number.isSafeInteger(3)) // true
console.log(Number.isSafeInteger(1.2)) // false
console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER)) // true
console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1)) // false

// 安全整数范围
console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991 (2^53 - 1)
console.log(Number.MIN_SAFE_INTEGER) // -9007199254740991
```

超出安全整数范围的计算不可靠：

```javascript
console.log(9007199254740993 === 9007199254740992) // true！精度丢失
console.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2) // true！
```

### Number.parseInt() 和 Number.parseFloat()

这两个方法与全局的 `parseInt()` 和 `parseFloat()` 行为完全相同，移到 Number 对象上是为了语言模块化：

```javascript
console.log(Number.parseInt('123')) // 123
console.log(Number.parseInt('123.45')) // 123
console.log(Number.parseInt('12px')) // 12
console.log(Number.parseInt('0xFF', 16)) // 255

console.log(Number.parseFloat('3.14')) // 3.14
console.log(Number.parseFloat('3.14abc')) // 3.14

// 与全局方法完全相同
console.log(Number.parseInt === parseInt) // true
console.log(Number.parseFloat === parseFloat) // true
```

### Number.EPSILON

表示 1 与大于 1 的最小浮点数之间的差，约等于 `2.220446049250313e-16`。用于处理浮点数精度问题：

```javascript
console.log(Number.EPSILON) // 2.220446049250313e-16
console.log(0.1 + 0.2) // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3) // false

// 使用 EPSILON 进行浮点数比较
function floatEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON
}

console.log(floatEqual(0.1 + 0.2, 0.3)) // true
```

更严谨的比较函数（考虑数值大小）：

```javascript
function withinErrorMargin(left, right) {
  return Math.abs(left - right) < Number.EPSILON * Math.pow(2, 2)
}

console.log(withinErrorMargin(0.1 + 0.2, 0.3)) // true
```

## Math 对象的扩展

ES6 在 Math 对象上新增了 17 个静态方法。

### Math.trunc()

去除小数部分，返回整数部分：

```javascript
console.log(Math.trunc(4.9)) // 4
console.log(Math.trunc(-4.1)) // -4
console.log(Math.trunc(-0.123)) // -0

// 对非数值先转换
console.log(Math.trunc('123.456')) // 123
console.log(Math.trunc(true)) // 1
console.log(Math.trunc(null)) // 0
console.log(Math.trunc(NaN)) // NaN
console.log(Math.trunc(undefined)) // NaN
```

与 `Math.floor()` 的区别：

```javascript
console.log(Math.trunc(-4.1)) // -4
console.log(Math.floor(-4.1)) // -5

console.log(Math.trunc(4.9)) // 4
console.log(Math.floor(4.9)) // 4
```

### Math.sign()

判断数值的符号，返回 5 种值：

```javascript
console.log(Math.sign(-5)) // -1
console.log(Math.sign(5)) // 1
console.log(Math.sign(0)) // 0
console.log(Math.sign(-0)) // -0
console.log(Math.sign(NaN)) // NaN

// 非数值先转换
console.log(Math.sign('')) // 0
console.log(Math.sign(true)) // 1
console.log(Math.sign('-5')) // -1
```

### Math.cbrt()

计算立方根（cube root）：

```javascript
console.log(Math.cbrt(-1)) // -1
console.log(Math.cbrt(0)) // 0
console.log(Math.cbrt(8)) // 2
console.log(Math.cbrt(27)) // 3
console.log(Math.cbrt(-8)) // -2
```

### Math.clz32()

返回 32 位无符号整数有多少个前导 0：

```javascript
console.log(Math.clz32(0)) // 32
console.log(Math.clz32(1)) // 31
console.log(Math.clz32(0b01000)) // 28
console.log(Math.clz32(0x7fffffff)) // 1
```

### Math.imul()

返回两个 32 位整数相乘的结果，也是 32 位整数：

```javascript
console.log(Math.imul(2, 4)) // 8
console.log(Math.imul(-1, 8)) // -8

// 处理大整数乘法的低 32 位
console.log((0x7fffffff * 0x7fffffff) | 0) // 0
console.log(Math.imul(0x7fffffff, 0x7fffffff)) // 1
```

### Math.fround()

返回数值的 32 位单精度浮点数形式：

```javascript
console.log(Math.fround(0)) // 0
console.log(Math.fround(1)) // 1
console.log(Math.fround(1.5)) // 1.5
console.log(Math.fround(1.337)) // 1.3370000123977661
```

### Math.hypot()

返回所有参数平方和的平方根（计算直角三角形斜边长度）：

```javascript
console.log(Math.hypot(3, 4)) // 5
console.log(Math.hypot(3, 4, 5)) // 7.0710678118654755
console.log(Math.hypot()) // 0
console.log(Math.hypot(NaN)) // NaN
console.log(Math.hypot(3, 4, 'foo')) // NaN
```

### 对数方法

```javascript
// Math.expm1()：返回 e^x - 1
console.log(Math.expm1(0)) // 0
console.log(Math.expm1(1)) // 1.718281828459045

// Math.log1p()：返回 ln(1 + x)
console.log(Math.log1p(0)) // 0
console.log(Math.log1p(1)) // 0.6931471805599453
console.log(Math.log1p(-1)) // -Infinity

// Math.log10()：返回以 10 为底的对数
console.log(Math.log10(100)) // 2
console.log(Math.log10(1)) // 0

// Math.log2()：返回以 2 为底的对数
console.log(Math.log2(8)) // 3
console.log(Math.log2(16)) // 4
```

### 双曲函数

```javascript
Math.sinh(x) // 双曲正弦
Math.cosh(x) // 双曲余弦
Math.tanh(x) // 双曲正切
Math.asinh(x) // 反双曲正弦
Math.acosh(x) // 反双曲余弦
Math.atanh(x) // 反双曲正切
```

## BigInt 大整数

ES2020 引入的 `BigInt` 是新的原始类型，可以表示任意精度的整数。

### 创建 BigInt

```javascript
// 字面量：在整数后加 n
const big1 = 9007199254740993n

// BigInt() 函数
const big2 = BigInt(123)
const big3 = BigInt('9007199254740993')

console.log(big1) // 9007199254740993n
console.log(typeof big1) // 'bigint'
```

### 解决大整数精度问题

```javascript
// Number 类型的精度问题
console.log(9007199254740993 === 9007199254740992) // true！

// BigInt 保持精度
console.log(9007199254740993n === 9007199254740992n) // false
console.log(9007199254740993n + 1n) // 9007199254740994n
```

### 运算

BigInt 支持常见的算术运算符：

```javascript
const a = 10n
const b = 3n

console.log(a + b) // 13n
console.log(a - b) // 7n
console.log(a * b) // 30n
console.log(a / b) // 3n（整数除法，向零取整）
console.log(a % b) // 1n
console.log(a ** b) // 1000n

// 不能与 Number 混合运算
console.log(10n + 5) // TypeError: Cannot mix BigInt and other types

// 需要显式转换
console.log(10n + BigInt(5)) // 15n
console.log(Number(10n) + 5) // 15
```

### 比较

BigInt 与 Number 可以比较：

```javascript
console.log(10n == 10) // true（宽松相等）
console.log(10n === 10) // false（严格相等，类型不同）

console.log(10n > 9) // true
console.log(10n < 11) // true

// 可以排序
const mixed = [4n, 6, -12n, 10, 4, 0, 0n]
mixed.sort((a, b) => {
  if (a < b) return -1
  if (a > b) return 1
  return 0
})
console.log(mixed) // [-12n, 0, 0n, 4n, 4, 6, 10]
```

### 类型转换

```javascript
// BigInt -> Number（可能丢失精度）
console.log(Number(10n)) // 10

// BigInt -> String
console.log(String(10n)) // '10'
console.log(10n.toString()) // '10'
console.log(10n.toString(2)) // '1010'

// BigInt -> Boolean
console.log(Boolean(0n)) // false
console.log(Boolean(10n)) // true

// 不能转为小数
console.log(BigInt(1.5)) // RangeError
```

### 限制

```javascript
// 不能用于 Math 方法
console.log(Math.sqrt(4n)) // TypeError

// 不能用于 JSON.stringify
JSON.stringify({ a: 10n }) // TypeError: Do not know how to serialize a BigInt

// 解决方案：自定义序列化
JSON.stringify({ a: 10n }, (key, value) =>
  typeof value === 'bigint' ? value.toString() : value
) // '{"a":"10"}'
```

### 实际应用

```javascript
// 高精度计算
function factorial(n) {
  let result = 1n
  for (let i = 2n; i <= n; i++) {
    result *= i
  }
  return result
}

console.log(factorial(50n))
// 30414093201713378043612608166064768844377641568960512000000000000n

// 处理 64 位整数 ID（如 Snowflake ID）
const snowflakeId = 1234567890123456789n
console.log(snowflakeId.toString()) // '1234567890123456789'

// 时间戳（纳秒级）
const nanoTimestamp = BigInt(Date.now()) * 1_000_000n
```

## 实战应用

### 金额计算

避免浮点数精度问题，用整数（分）计算：

```javascript
// 有问题的浮点数计算
console.log(0.1 + 0.2) // 0.30000000000000004

// 解决方案：用分计算
function addMoney(a, b) {
  const aCents = Math.round(a * 100)
  const bCents = Math.round(b * 100)
  return (aCents + bCents) / 100
}

console.log(addMoney(0.1, 0.2)) // 0.3

// 或使用 BigInt
function addMoneyBigInt(a, b) {
  const tocents = (v) => BigInt(Math.round(v * 100))
  return Number(tocents(a) + tocents(b)) / 100
}
```

### 随机整数

```javascript
// 生成 [min, max] 范围内的随机整数
function randomInt(min, max) {
  min = Math.ceil(min)
  max = Math.floor(max)
  return Math.floor(Math.random() * (max - min + 1)) + min
}

console.log(randomInt(1, 10)) // 1-10 之间的随机整数
```

### 数字格式化

```javascript
// 千分位分隔
function formatNumber(num) {
  return num.toLocaleString('en-US')
}

console.log(formatNumber(1234567.89)) // '1,234,567.89'

// 中文数字格式化
console.log((12345).toLocaleString('zh-Hans-CN-u-nu-hanidec'))
// '一二,三四五'
```

### 进制转换工具

```javascript
function convertBase(num, fromBase, toBase) {
  return parseInt(num, fromBase).toString(toBase)
}

console.log(convertBase('ff', 16, 2)) // '11111111'
console.log(convertBase('1010', 2, 10)) // '10'
console.log(convertBase('10', 10, 16)) // 'a'
```

---

ES6+ 对数值的增强涵盖了从字面量表示、类型判断、数学运算到大整数支持的方方面面。`Number.isNaN()` 和 `Number.isFinite()` 提供了更严格的类型检查，`BigInt` 解决了大整数精度问题，数值分隔符提升了代码可读性。这些特性让 JavaScript 的数值处理能力大幅提升。
