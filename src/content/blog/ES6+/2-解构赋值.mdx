---
title: 变量的解构赋值
description: 全面掌握 ES6 解构赋值语法，包括数组解构、对象解构、嵌套解构、默认值设置，以及在函数参数、数据交换等场景的实战应用
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

从 API 返回的数据中提取字段、从配置对象中读取选项、交换两个变量的值——这些操作在 ES5 时代需要写大量样板代码。ES6 的解构赋值让这些操作变得简洁直观。

## 数组解构

数组解构按照位置一一对应进行赋值。

### 基本用法

```javascript
const [a, b, c] = [1, 2, 3]
console.log(a) // 1
console.log(b) // 2
console.log(c) // 3
```

等号左边的模式与右边的数组结构一一对应。这比传统写法简洁得多：

```javascript
// ES5 写法
var arr = [1, 2, 3]
var a = arr[0]
var b = arr[1]
var c = arr[2]
```

### 跳过元素

用逗号占位跳过不需要的元素：

```javascript
const [first, , third] = [1, 2, 3]
console.log(first) // 1
console.log(third) // 3

const [, , last] = ['a', 'b', 'c']
console.log(last) // 'c'
```

### 剩余元素

使用 rest 模式 `...` 收集剩余元素：

```javascript
const [head, ...tail] = [1, 2, 3, 4, 5]
console.log(head) // 1
console.log(tail) // [2, 3, 4, 5]

const [first, second, ...rest] = [1, 2]
console.log(rest) // []，没有剩余元素时返回空数组
```

rest 元素必须放在最后：

```javascript
const [...rest, last] = [1, 2, 3]; // SyntaxError
```

### 默认值

当解构位置的值为 `undefined` 时，使用默认值：

```javascript
const [a = 1] = []
console.log(a) // 1

const [b = 2] = [undefined]
console.log(b) // 2

const [c = 3] = [null]
console.log(c) // null，只有 undefined 触发默认值
```

默认值可以是表达式，且惰性求值：

```javascript
function getDefault() {
  console.log('计算默认值')
  return 100
}

const [x = getDefault()] = [1]
// 不输出任何内容，因为 x 有值，不需要默认值
console.log(x) // 1

const [y = getDefault()] = []
// 输出 '计算默认值'
console.log(y) // 100
```

默认值可以引用其他解构变量，但要注意顺序：

```javascript
const [x = 1, y = x] = []
console.log(x, y) // 1, 1

const [a = b, b = 1] = [] // ReferenceError: Cannot access 'b' before initialization
```

### 嵌套解构

解构可以嵌套使用：

```javascript
const [a, [b, c]] = [1, [2, 3]]
console.log(a, b, c) // 1, 2, 3

const [x, [y, [z]]] = [1, [2, [3]]]
console.log(x, y, z) // 1, 2, 3
```

### 解构任意可迭代对象

数组解构适用于任何实现了 Iterator 接口的对象：

```javascript
// 字符串
const [a, b, c] = 'xyz'
console.log(a, b, c) // 'x', 'y', 'z'

// Set
const [first, second] = new Set([1, 2, 3])
console.log(first, second) // 1, 2

// Map
const [[key1, val1], [key2, val2]] = new Map([
  ['a', 1],
  ['b', 2],
])
console.log(key1, val1) // 'a', 1

// Generator
function* gen() {
  yield 1
  yield 2
  yield 3
}
const [g1, g2, g3] = gen()
console.log(g1, g2, g3) // 1, 2, 3
```

## 对象解构

对象解构按照属性名匹配，与顺序无关。

### 基本用法

```javascript
const { name, age } = { name: '张三', age: 25 }
console.log(name) // '张三'
console.log(age) // 25
```

属性顺序不影响解构结果：

```javascript
const { age, name } = { name: '张三', age: 25 }
console.log(name) // '张三'
console.log(age) // 25
```

### 变量重命名

使用 `属性名: 变量名` 语法将属性赋值给不同名称的变量：

```javascript
const { name: userName, age: userAge } = { name: '张三', age: 25 }
console.log(userName) // '张三'
console.log(userAge) // 25
// console.log(name);  // ReferenceError: name is not defined
```

这在处理命名冲突或需要更具描述性的变量名时很有用：

```javascript
const response = {
  data: { id: 1, name: 'Product' },
  status: 200,
}

const { data: productData, status: httpStatus } = response
```

### 默认值

与数组解构相同，当属性值为 `undefined` 时使用默认值：

```javascript
const { a = 1, b = 2 } = { a: 10 }
console.log(a) // 10
console.log(b) // 2

const { x = 3 } = { x: undefined }
console.log(x) // 3

const { y = 4 } = { y: null }
console.log(y) // null
```

重命名和默认值可以结合使用：

```javascript
const { name: userName = 'Anonymous', role = 'user' } = { name: '张三' }
console.log(userName) // '张三'
console.log(role) // 'user'
```

### 嵌套解构

解构嵌套对象：

```javascript
const user = {
  name: '张三',
  address: {
    city: '北京',
    district: '朝阳区',
  },
}

const {
  address: { city, district },
} = user
console.log(city) // '北京'
console.log(district) // '朝阳区'
// console.log(address); // ReferenceError，address 只是模式，不是变量
```

如果同时需要外层对象和内层属性：

```javascript
const {
  address,
  address: { city },
} = user
console.log(address) // { city: '北京', district: '朝阳区' }
console.log(city) // '北京'
```

### 剩余属性

使用 rest 模式收集剩余属性：

```javascript
const { a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 }
console.log(a) // 1
console.log(b) // 2
console.log(rest) // { c: 3, d: 4 }
```

这在过滤对象属性时非常有用：

```javascript
// 移除敏感字段
const user = { id: 1, name: '张三', password: 'secret', token: 'abc' }
const { password, token, ...safeUser } = user
console.log(safeUser) // { id: 1, name: '张三' }
```

### 计算属性名

可以使用变量作为属性名：

```javascript
const key = 'name'
const { [key]: value } = { name: '张三' }
console.log(value) // '张三'

const propName = 'dynamic'
const { [propName]: dynamicValue = 'default' } = {}
console.log(dynamicValue) // 'default'
```

### 原型链上的属性

解构可以获取原型链上的属性：

```javascript
const proto = { inherited: 'from proto' }
const obj = Object.create(proto)
obj.own = 'own property'

const { own, inherited } = obj
console.log(own) // 'own property'
console.log(inherited) // 'from proto'
```

## 函数参数解构

解构赋值在函数参数中应用广泛。

### 对象参数解构

```javascript
function createUser({ name, age, role = 'user' }) {
  return { name, age, role, createdAt: Date.now() }
}

const user = createUser({ name: '张三', age: 25 })
console.log(user)
// { name: '张三', age: 25, role: 'user', createdAt: ... }
```

这种模式让函数调用更具可读性，参数顺序不重要，还能设置默认值。

### 整体默认值 vs 属性默认值

```javascript
// 方式一：属性默认值
function fn1({ x = 0, y = 0 }) {
  return [x, y]
}

fn1({}) // [0, 0]
fn1({ x: 1 }) // [1, 0]
fn1() // TypeError: Cannot destructure property 'x' of undefined

// 方式二：整体默认值
function fn2({ x, y } = { x: 0, y: 0 }) {
  return [x, y]
}

fn2({}) // [undefined, undefined]
fn2({ x: 1 }) // [1, undefined]
fn2() // [0, 0]

// 方式三：两者结合（推荐）
function fn3({ x = 0, y = 0 } = {}) {
  return [x, y]
}

fn3({}) // [0, 0]
fn3({ x: 1 }) // [1, 0]
fn3() // [0, 0]
```

第三种方式最完善：即使不传参数也不会报错，且单独传递部分属性时其他属性使用默认值。

### 数组参数解构

```javascript
function sum([a, b, c = 0]) {
  return a + b + c
}

console.log(sum([1, 2])) // 3
console.log(sum([1, 2, 3])) // 6
```

### 解构 + 剩余参数

```javascript
function logFirst(first, ...rest) {
  console.log('First:', first)
  console.log('Rest:', rest)
}

function processItems([head, ...tail]) {
  console.log('Head:', head)
  console.log('Tail:', tail)
}
```

## 实战应用场景

### 交换变量

无需临时变量即可交换两个变量的值：

```javascript
let a = 1
let b = 2

;[a, b] = [b, a]

console.log(a) // 2
console.log(b) // 1
```

三个或更多变量的循环交换：

```javascript
let x = 1,
  y = 2,
  z = 3
;[x, y, z] = [y, z, x]
console.log(x, y, z) // 2, 3, 1
```

### 函数返回多个值

```javascript
function getMinMax(arr) {
  return [Math.min(...arr), Math.max(...arr)]
}

const [min, max] = getMinMax([3, 1, 4, 1, 5, 9])
console.log(min, max) // 1, 9

function getUserInfo() {
  return {
    name: '张三',
    age: 25,
    email: 'zhangsan@example.com',
  }
}

const { name, email } = getUserInfo()
```

### 提取 JSON 数据

```javascript
const response = {
  status: 200,
  data: {
    users: [
      { id: 1, name: '张三' },
      { id: 2, name: '李四' },
    ],
    total: 2,
    page: 1,
  },
}

const {
  status,
  data: { users, total, page },
} = response

console.log(status) // 200
console.log(users) // [{ id: 1, name: '张三' }, { id: 2, name: '李四' }]
```

### 模块导入

```javascript
// 导入模块的特定方法
import { useState, useEffect, useCallback } from 'react'

// 等价于对象解构
const { useState, useEffect, useCallback } = require('react')
```

### React Hooks 中的应用

```javascript
// useState 返回数组，用数组解构
const [count, setCount] = useState(0)
const [user, setUser] = useState(null)

// useReducer
const [state, dispatch] = useReducer(reducer, initialState)
```

### 配置对象处理

```javascript
function initApp(options = {}) {
  const {
    port = 3000,
    host = 'localhost',
    protocol = 'http',
    database: {
      host: dbHost = 'localhost',
      port: dbPort = 5432,
      name: dbName = 'myapp',
    } = {},
  } = options

  console.log(`Server: ${protocol}://${host}:${port}`)
  console.log(`Database: ${dbHost}:${dbPort}/${dbName}`)
}

initApp() // 使用全部默认值
initApp({ port: 8080, database: { name: 'production' } })
```

### 遍历 Map

```javascript
const map = new Map([
  ['name', '张三'],
  ['age', 25],
  ['city', '北京'],
])

// 解构键值对
for (const [key, value] of map) {
  console.log(`${key}: ${value}`)
}

// 只需要 key
for (const [key] of map) {
  console.log(key)
}

// 只需要 value
for (const [, value] of map) {
  console.log(value)
}
```

### 正则表达式匹配结果

```javascript
const url = 'https://example.com:8080/path'
const pattern = /^(https?):\/\/([^:\/]+):?(\d*)(.*)$/
const [, protocol, host, port, path] = url.match(pattern)

console.log(protocol) // 'https'
console.log(host) // 'example.com'
console.log(port) // '8080'
console.log(path) // '/path'
```

## 边界情况和常见错误

### 解构 null 或 undefined

```javascript
const { a } = null // TypeError: Cannot destructure property 'a' of null
const [b] = undefined // TypeError: Cannot read properties of undefined

// 安全处理
const { a } = null || {}
const [b] = undefined ?? []
```

### 已声明变量的对象解构

对象解构赋值给已声明的变量时，需要用括号包裹：

```javascript
let x, y;

// 错误：JavaScript 将 { x, y } 解析为代码块
{ x, y } = { x: 1, y: 2 }; // SyntaxError

// 正确：用括号包裹
({ x, y } = { x: 1, y: 2 });
console.log(x, y); // 1, 2
```

### 数组解构非数组

对非可迭代对象进行数组解构会报错：

```javascript
const [a] = 1 // TypeError: 1 is not iterable
const [b] = false // TypeError: false is not iterable
const [c] = {} // TypeError: {} is not iterable

// 对象可以解构
const [d] = { 0: 'a', length: 1 } // TypeError，类数组对象不可迭代
const [e] = Array.from({ 0: 'a', length: 1 }) // 'a'
```

### 圆括号的使用限制

解构赋值中，模式部分不能使用圆括号：

```javascript
// 以下都是错误的
const [(a)] = [1];           // SyntaxError
const { (x): y } = {};       // SyntaxError
const { x: (y) } = {};       // SyntaxError

// 只有赋值语句的非模式部分可以使用圆括号
let x;
[(x)] = [1];                 // 可以，但没必要
({ x: (x) } = { x: 1 });     // 可以，但没必要
```

### 解构的性能

解构赋值在现代 JavaScript 引擎中经过高度优化，性能与手动赋值相当。在热路径上可能需要注意的是深层嵌套解构创建的中间对象，但这通常不是瓶颈。

```javascript
// 这两种写法性能几乎相同
const { a, b, c } = obj

const a = obj.a
const b = obj.b
const c = obj.c
```

## 与其他特性的配合

### 解构 + 展开运算符

```javascript
// 合并对象时排除某些属性
const user = { id: 1, name: '张三', password: 'secret' }
const { password, ...publicInfo } = user
const newUser = { ...publicInfo, role: 'admin' }
// { id: 1, name: '张三', role: 'admin' }
```

### 解构 + 可选链

```javascript
const response = {
  data: {
    user: { name: '张三' },
  },
}

// 可选链确保安全访问
const userName = response?.data?.user?.name

// 解构时可以结合默认值
const { data: { user: { name = 'Anonymous' } = {} } = {} } = response || {}
```

### 解构 + Promise

```javascript
async function fetchUserAndPosts(userId) {
  const [user, posts] = await Promise.all([
    fetch(`/api/users/${userId}`).then((r) => r.json()),
    fetch(`/api/users/${userId}/posts`).then((r) => r.json()),
  ])

  return { user, posts }
}
```

---

解构赋值是 ES6 中使用频率最高的特性之一。它让从复杂数据结构中提取数据变得简洁、清晰，配合默认值和剩余模式可以处理各种边界情况。在 API 数据处理、函数参数设计、模块导入等场景中，解构赋值已经成为现代 JavaScript 开发的标配写法。
