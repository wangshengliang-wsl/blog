---
title: Set 和 Map 数据结构
description: 深入掌握 ES6 新增的 Set、WeakSet、Map、WeakMap 数据结构，理解其特性、API 和实战应用场景
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

ES6 之前，JavaScript 只有对象和数组两种集合类型。对象的键只能是字符串，数组只能用数字索引。ES6 引入了 Set 和 Map，提供了更强大的数据结构支持。

## Set

Set 是值的集合，其中的值是唯一的，不会重复。

### 基本用法

```javascript
// 创建 Set
const set = new Set()

// 添加值
set.add(1)
set.add(2)
set.add(2) // 重复值被忽略
set.add('2') // 不同类型，可以添加

console.log(set) // Set(3) { 1, 2, '2' }
console.log(set.size) // 3
```

可以在构造时传入可迭代对象：

```javascript
// 从数组创建
const set1 = new Set([1, 2, 3, 3, 4])
console.log([...set1]) // [1, 2, 3, 4]

// 从字符串创建
const set2 = new Set('hello')
console.log([...set2]) // ['h', 'e', 'l', 'o']
```

### 值的唯一性

Set 使用类似 `===` 的算法判断值是否相等，但有两点不同：

```javascript
const set = new Set()

// NaN 等于自身
set.add(NaN)
set.add(NaN)
console.log(set.size) // 1

// +0 和 -0 相等
set.add(+0)
set.add(-0)
console.log(set.size) // 2（加上 NaN）

// 对象总是不等
set.add({})
set.add({})
console.log(set.size) // 4，两个空对象是不同的值
```

### Set 的方法和属性

```javascript
const set = new Set([1, 2, 3])

// 属性
console.log(set.size) // 3

// 添加
set.add(4)
set.add(1) // 已存在，忽略
console.log(set.size) // 4

// 删除
set.delete(2) // 返回 true（删除成功）
set.delete(10) // 返回 false（不存在）

// 检查是否存在
console.log(set.has(1)) // true
console.log(set.has(2)) // false

// 清空
set.clear()
console.log(set.size) // 0
```

### 遍历

Set 的遍历顺序就是插入顺序：

```javascript
const set = new Set(['a', 'b', 'c'])

// forEach
set.forEach((value, key) => {
  console.log(value, key) // 'a' 'a', 'b' 'b', 'c' 'c'
  // 注意：value 和 key 相同
})

// for...of
for (const value of set) {
  console.log(value) // 'a', 'b', 'c'
}

// keys()、values()、entries()
console.log([...set.keys()]) // ['a', 'b', 'c']
console.log([...set.values()]) // ['a', 'b', 'c']
console.log([...set.entries()]) // [['a', 'a'], ['b', 'b'], ['c', 'c']]
```

### 数组去重

```javascript
// 最简洁的数组去重
const unique = (arr) => [...new Set(arr)]

console.log(unique([1, 2, 2, 3, 3, 3])) // [1, 2, 3]

// 字符串去重
const uniqueChars = (str) => [...new Set(str)].join('')
console.log(uniqueChars('aabbcc')) // 'abc'
```

### 集合运算

```javascript
const a = new Set([1, 2, 3])
const b = new Set([2, 3, 4])

// 并集
const union = new Set([...a, ...b])
console.log([...union]) // [1, 2, 3, 4]

// 交集
const intersection = new Set([...a].filter((x) => b.has(x)))
console.log([...intersection]) // [2, 3]

// 差集（a - b）
const difference = new Set([...a].filter((x) => !b.has(x)))
console.log([...difference]) // [1]

// 对称差集
const symmetricDifference = new Set([
  ...[...a].filter((x) => !b.has(x)),
  ...[...b].filter((x) => !a.has(x)),
])
console.log([...symmetricDifference]) // [1, 4]

// 判断子集
const isSubset = (subset, superset) => [...subset].every((x) => superset.has(x))

console.log(isSubset(new Set([1, 2]), a)) // true
```

### ES2025 新增方法

```javascript
const a = new Set([1, 2, 3])
const b = new Set([2, 3, 4])

// 这些方法在最新的 JavaScript 引擎中可用
a.union(b) // Set { 1, 2, 3, 4 }
a.intersection(b) // Set { 2, 3 }
a.difference(b) // Set { 1 }
a.symmetricDifference(b) // Set { 1, 4 }
a.isSubsetOf(b) // false
a.isSupersetOf(b) // false
a.isDisjointFrom(b) // false（有交集则为 false）
```

## WeakSet

WeakSet 与 Set 类似，但有以下区别：

1. 成员只能是对象（和 Symbol）
2. 成员是弱引用，不阻止垃圾回收
3. 不可遍历，没有 `size` 属性

### 基本用法

```javascript
const ws = new WeakSet()

const obj1 = {}
const obj2 = {}

ws.add(obj1)
ws.add(obj2)

console.log(ws.has(obj1)) // true
console.log(ws.has(obj2)) // true

ws.delete(obj1)
console.log(ws.has(obj1)) // false

// 不能添加原始值
// ws.add(1); // TypeError
// ws.add('hello'); // TypeError
```

### 弱引用特性

```javascript
let obj = { name: '张三' }
const ws = new WeakSet([obj])

console.log(ws.has(obj)) // true

obj = null // 移除对对象的引用
// 此时 WeakSet 中的对象可能被垃圾回收
// 但无法验证，因为 WeakSet 不可遍历
```

### 应用场景

**标记对象**：

```javascript
const processedItems = new WeakSet()

function processItem(item) {
  if (processedItems.has(item)) {
    return // 已处理过
  }

  // 处理逻辑
  console.log('Processing:', item)

  processedItems.add(item)
}

const item = { id: 1 }
processItem(item) // 'Processing: { id: 1 }'
processItem(item) // 不输出，已处理
```

**防止循环引用**：

```javascript
function deepClone(obj, seen = new WeakSet()) {
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // 检测循环引用
  if (seen.has(obj)) {
    throw new Error('Circular reference detected')
  }
  seen.add(obj)

  const clone = Array.isArray(obj) ? [] : {}
  for (const key of Object.keys(obj)) {
    clone[key] = deepClone(obj[key], seen)
  }

  return clone
}
```

**私有数据存储**：

```javascript
const privateData = new WeakSet()

class Person {
  constructor(name) {
    this.name = name
    privateData.add(this) // 标记为有效实例
  }

  greet() {
    if (!privateData.has(this)) {
      throw new Error('Invalid instance')
    }
    console.log(`Hello, I'm ${this.name}`)
  }
}
```

## Map

Map 是键值对的集合，与对象不同，Map 的键可以是任意类型。

### 基本用法

```javascript
const map = new Map()

// 设置键值对
map.set('name', '张三')
map.set(1, 'one')
map.set({}, 'empty object')

// 获取值
console.log(map.get('name')) // '张三'
console.log(map.get(1)) // 'one'

// 链式调用
map.set('a', 1).set('b', 2).set('c', 3)
```

可以在构造时传入键值对数组：

```javascript
const map = new Map([
  ['name', '张三'],
  ['age', 25],
  [{ key: 1 }, 'object key'],
])

console.log(map.get('name')) // '张三'
console.log(map.size) // 3
```

### 任意类型的键

```javascript
const map = new Map()

// 对象作为键
const objKey = { id: 1 }
map.set(objKey, 'object value')
console.log(map.get(objKey)) // 'object value'

// 函数作为键
const fnKey = function () {}
map.set(fnKey, 'function value')
console.log(map.get(fnKey)) // 'function value'

// NaN 作为键
map.set(NaN, 'NaN value')
console.log(map.get(NaN)) // 'NaN value'

// 注意：不同的对象引用是不同的键
console.log(map.get({ id: 1 })) // undefined，不是同一个对象
```

### Map 的方法和属性

```javascript
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3],
])

// 属性
console.log(map.size) // 3

// 设置和获取
map.set('d', 4)
console.log(map.get('d')) // 4
console.log(map.get('e')) // undefined

// 检查是否存在
console.log(map.has('a')) // true
console.log(map.has('e')) // false

// 删除
map.delete('a') // 返回 true
map.delete('e') // 返回 false

// 清空
map.clear()
console.log(map.size) // 0
```

### 遍历

Map 的遍历顺序是插入顺序：

```javascript
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3],
])

// forEach
map.forEach((value, key) => {
  console.log(key, value) // 'a' 1, 'b' 2, 'c' 3
})

// for...of
for (const [key, value] of map) {
  console.log(key, value)
}

// keys()
for (const key of map.keys()) {
  console.log(key) // 'a', 'b', 'c'
}

// values()
for (const value of map.values()) {
  console.log(value) // 1, 2, 3
}

// entries()
for (const [key, value] of map.entries()) {
  console.log(key, value)
}
```

### Map 与对象的转换

```javascript
// 对象转 Map
function objToMap(obj) {
  return new Map(Object.entries(obj))
}

const obj = { a: 1, b: 2, c: 3 }
const map = objToMap(obj)
console.log(map) // Map(3) { 'a' => 1, 'b' => 2, 'c' => 3 }

// Map 转对象（键必须是字符串）
function mapToObj(map) {
  return Object.fromEntries(map)
}

console.log(mapToObj(map)) // { a: 1, b: 2, c: 3 }
```

### Map vs Object

| 特性   | Map              | Object                    |
| ------ | ---------------- | ------------------------- |
| 键类型 | 任意类型         | 字符串/Symbol             |
| 键顺序 | 插入顺序         | 不保证（ES6后有一定规则） |
| 大小   | `map.size`       | `Object.keys(obj).length` |
| 遍历   | 直接可迭代       | 需要获取键数组            |
| 性能   | 频繁增删性能更好 | 频繁读取性能更好          |
| JSON   | 需要转换         | 原生支持                  |

```javascript
// 选择建议：
// - 键值对集合，键类型不确定：用 Map
// - 需要 JSON 序列化：用 Object
// - 需要频繁增删键值对：用 Map
// - 固定结构的数据：用 Object
```

## WeakMap

WeakMap 与 Map 类似，但有以下区别：

1. 键只能是对象（和 Symbol）
2. 键是弱引用，不阻止垃圾回收
3. 不可遍历，没有 `size` 属性

### 基本用法

```javascript
const wm = new WeakMap()

const key1 = {}
const key2 = {}

wm.set(key1, 'value1')
wm.set(key2, 'value2')

console.log(wm.get(key1)) // 'value1'
console.log(wm.has(key1)) // true

wm.delete(key1)
console.log(wm.has(key1)) // false

// 不能使用原始值作为键
// wm.set('key', 'value'); // TypeError
```

### 应用场景

**存储 DOM 节点数据**：

```javascript
const nodeData = new WeakMap()

function setData(element, data) {
  nodeData.set(element, data)
}

function getData(element) {
  return nodeData.get(element)
}

// 使用
const div = document.querySelector('div')
setData(div, { clicks: 0, lastVisit: Date.now() })

// 当 div 从 DOM 中移除并且没有其他引用时
// WeakMap 中的条目会自动被垃圾回收
```

**私有数据**：

```javascript
const privateData = new WeakMap()

class Person {
  constructor(name, age) {
    privateData.set(this, { name, age })
  }

  get name() {
    return privateData.get(this).name
  }

  get age() {
    return privateData.get(this).age
  }

  birthday() {
    const data = privateData.get(this)
    data.age++
  }
}

const person = new Person('张三', 25)
console.log(person.name) // '张三'
console.log(person.age) // 25
person.birthday()
console.log(person.age) // 26

// 外部无法访问私有数据
console.log(Object.keys(person)) // []
```

**缓存计算结果**：

```javascript
const cache = new WeakMap()

function expensiveOperation(obj) {
  if (cache.has(obj)) {
    console.log('From cache')
    return cache.get(obj)
  }

  console.log('Computing...')
  const result = /* 复杂计算 */ obj.value * 2

  cache.set(obj, result)
  return result
}

const data = { value: 21 }
console.log(expensiveOperation(data)) // 'Computing...', 42
console.log(expensiveOperation(data)) // 'From cache', 42

// 当 data 被垃圾回收时，缓存也会自动清理
```

## 实战应用

### LRU 缓存

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity
    this.cache = new Map()
  }

  get(key) {
    if (!this.cache.has(key)) {
      return -1
    }

    // 访问后移到最后（最近使用）
    const value = this.cache.get(key)
    this.cache.delete(key)
    this.cache.set(key, value)
    return value
  }

  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key)
    } else if (this.cache.size >= this.capacity) {
      // 删除最久未使用的（第一个）
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }

    this.cache.set(key, value)
  }
}

const cache = new LRUCache(2)
cache.put(1, 1)
cache.put(2, 2)
console.log(cache.get(1)) // 1
cache.put(3, 3) // 淘汰 key 2
console.log(cache.get(2)) // -1
```

### 事件订阅系统

```javascript
class EventEmitter {
  constructor() {
    this.events = new Map()
  }

  on(event, handler) {
    if (!this.events.has(event)) {
      this.events.set(event, new Set())
    }
    this.events.get(event).add(handler)
  }

  off(event, handler) {
    if (this.events.has(event)) {
      this.events.get(event).delete(handler)
    }
  }

  emit(event, ...args) {
    if (this.events.has(event)) {
      for (const handler of this.events.get(event)) {
        handler(...args)
      }
    }
  }

  once(event, handler) {
    const wrapper = (...args) => {
      handler(...args)
      this.off(event, wrapper)
    }
    this.on(event, wrapper)
  }
}

const emitter = new EventEmitter()
emitter.on('data', (data) => console.log('Received:', data))
emitter.emit('data', { id: 1 }) // 'Received: { id: 1 }'
```

### 双向映射

```javascript
class BiMap {
  constructor() {
    this.forward = new Map()
    this.reverse = new Map()
  }

  set(key, value) {
    // 删除旧映射
    if (this.forward.has(key)) {
      this.reverse.delete(this.forward.get(key))
    }
    if (this.reverse.has(value)) {
      this.forward.delete(this.reverse.get(value))
    }

    this.forward.set(key, value)
    this.reverse.set(value, key)
  }

  getByKey(key) {
    return this.forward.get(key)
  }

  getByValue(value) {
    return this.reverse.get(value)
  }
}

const bimap = new BiMap()
bimap.set('a', 1)
bimap.set('b', 2)

console.log(bimap.getByKey('a')) // 1
console.log(bimap.getByValue(2)) // 'b'
```

---

Set 和 Map 填补了 JavaScript 数据结构的空白。Set 提供了高效的值唯一性保证，Map 支持任意类型的键，WeakSet 和 WeakMap 则通过弱引用解决了内存泄漏的问题。这些数据结构在现代 JavaScript 开发中使用非常广泛。
