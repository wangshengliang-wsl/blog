---
title: 对象的扩展
description: 深入理解 ES6+ 对象新特性，包括属性简写、计算属性名、方法简写、扩展运算符，以及 Object 新增方法的实战应用
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

对象是 JavaScript 的核心数据类型。ES6 对对象字面量语法进行了大幅简化，同时在 Object 构造函数上新增了大量实用方法，让对象操作更加高效。

## 属性的简洁表示法

### 属性简写

当属性名与变量名相同时，可以省略冒号和值：

```javascript
const name = '张三'
const age = 25

// ES5
const user1 = {
  name: name,
  age: age,
}

// ES6
const user2 = {
  name,
  age,
}

console.log(user2) // { name: '张三', age: 25 }
```

### 方法简写

对象方法可以省略 `function` 关键字：

```javascript
// ES5
const obj1 = {
  sayHello: function () {
    console.log('Hello')
  },
}

// ES6
const obj2 = {
  sayHello() {
    console.log('Hello')
  },
}

obj2.sayHello() // 'Hello'
```

简写方法与完整写法有一个区别：简写方法不能用作构造函数：

```javascript
const obj = {
  method() {},
}

new obj.method() // TypeError: obj.method is not a constructor
```

### Generator 方法简写

```javascript
const obj = {
  *generator() {
    yield 1
    yield 2
  },
}

for (const value of obj.generator()) {
  console.log(value) // 1, 2
}
```

### Getter 和 Setter

```javascript
const obj = {
  _value: 0,
  get value() {
    console.log('Getting value')
    return this._value
  },
  set value(newValue) {
    console.log('Setting value')
    this._value = newValue
  },
}

obj.value = 10 // 'Setting value'
console.log(obj.value) // 'Getting value', 10
```

## 计算属性名

ES6 允许在对象字面量中使用表达式作为属性名，用方括号包裹。

### 基本用法

```javascript
const prefix = 'user'

const obj = {
  [prefix + 'Name']: '张三',
  [prefix + 'Age']: 25,
  ['say' + 'Hello']() {
    console.log('Hello')
  },
}

console.log(obj.userName) // '张三'
console.log(obj.userAge) // 25
obj.sayHello() // 'Hello'
```

### 使用 Symbol

```javascript
const mySymbol = Symbol('description')

const obj = {
  [mySymbol]: 'Symbol value',
  [Symbol.iterator]() {
    // 实现迭代器
  },
}

console.log(obj[mySymbol]) // 'Symbol value'
```

### 动态生成属性名

```javascript
function createObject(key, value) {
  return {
    [key]: value,
    [`${key}Count`]: 1,
    [`get${key.charAt(0).toUpperCase() + key.slice(1)}`]() {
      return this[key]
    },
  }
}

const obj = createObject('name', '张三')
console.log(obj.name) // '张三'
console.log(obj.nameCount) // 1
console.log(obj.getName()) // '张三'
```

## 对象的扩展运算符

ES2018 将扩展运算符引入对象。

### 对象复制

```javascript
const original = { a: 1, b: 2 }
const copy = { ...original }

console.log(copy) // { a: 1, b: 2 }
console.log(copy === original) // false
```

这是浅拷贝：

```javascript
const obj = { a: 1, nested: { b: 2 } }
const copy = { ...obj }

copy.nested.b = 999
console.log(obj.nested.b) // 999，原对象也被修改了
```

### 对象合并

```javascript
const obj1 = { a: 1, b: 2 }
const obj2 = { c: 3, d: 4 }
const obj3 = { b: 20, e: 5 } // b 会覆盖

const merged = { ...obj1, ...obj2, ...obj3 }
console.log(merged) // { a: 1, b: 20, c: 3, d: 4, e: 5 }

// 等价于 Object.assign
const merged2 = Object.assign({}, obj1, obj2, obj3)
```

### 设置默认值

```javascript
const defaults = {
  host: 'localhost',
  port: 3000,
  protocol: 'http',
}

const userConfig = {
  port: 8080,
}

const config = { ...defaults, ...userConfig }
console.log(config)
// { host: 'localhost', port: 8080, protocol: 'http' }
```

### 解构时收集剩余属性

```javascript
const { a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 }

console.log(a) // 1
console.log(b) // 2
console.log(rest) // { c: 3, d: 4 }
```

这在过滤对象属性时很有用：

```javascript
// 移除敏感字段
const user = { id: 1, name: '张三', password: 'secret', token: 'abc' }
const { password, token, ...safeUser } = user
console.log(safeUser) // { id: 1, name: '张三' }
```

### 注意事项

扩展运算符只复制对象自身的可枚举属性：

```javascript
const proto = { inherited: 'from proto' }
const obj = Object.create(proto, {
  own: { value: 'own property', enumerable: true },
  nonEnum: { value: 'non enumerable', enumerable: false },
})

const spread = { ...obj }
console.log(spread) // { own: 'own property' }
// inherited 不会被复制（原型属性）
// nonEnum 不会被复制（不可枚举）
```

## Object 的新方法

### Object.is()

更精确的相等判断：

```javascript
// === 的特殊情况
console.log(+0 === -0) // true
console.log(NaN === NaN) // false

// Object.is 修正了这些情况
console.log(Object.is(+0, -0)) // false
console.log(Object.is(NaN, NaN)) // true

// 其他情况与 === 相同
console.log(Object.is('foo', 'foo')) // true
console.log(Object.is({}, {})) // false
```

### Object.assign()

将源对象的可枚举属性复制到目标对象：

```javascript
const target = { a: 1 }
const source1 = { b: 2 }
const source2 = { c: 3 }

const result = Object.assign(target, source1, source2)

console.log(result) // { a: 1, b: 2, c: 3 }
console.log(target === result) // true，target 被修改了
```

常见用法：

```javascript
// 1. 克隆对象（浅拷贝）
const clone = Object.assign({}, original)

// 2. 合并对象
const merged = Object.assign({}, obj1, obj2)

// 3. 添加属性
Object.assign(someObj, { newProp: 'value' })

// 4. 添加方法
Object.assign(SomeClass.prototype, {
  method1() {},
  method2() {},
})
```

注意事项：

```javascript
// 同名属性后面覆盖前面
const obj = Object.assign({ a: 1 }, { a: 2, b: 2 }, { a: 3 })
console.log(obj) // { a: 3, b: 2 }

// 只拷贝自身可枚举属性
// 不拷贝继承属性和不可枚举属性

// 浅拷贝
const obj1 = { a: { b: 1 } }
const obj2 = Object.assign({}, obj1)
obj1.a.b = 2
console.log(obj2.a.b) // 2

// 对数组的处理：按索引覆盖
console.log(Object.assign([1, 2, 3], [4, 5])) // [4, 5, 3]
```

### Object.keys()、Object.values()、Object.entries()

```javascript
const obj = { a: 1, b: 2, c: 3 }

// keys：返回键数组
console.log(Object.keys(obj)) // ['a', 'b', 'c']

// values：返回值数组
console.log(Object.values(obj)) // [1, 2, 3]

// entries：返回键值对数组
console.log(Object.entries(obj)) // [['a', 1], ['b', 2], ['c', 3]]

// 配合 for...of 使用
for (const [key, value] of Object.entries(obj)) {
  console.log(`${key}: ${value}`)
}

// 配合 Map 使用
const map = new Map(Object.entries(obj))
console.log(map.get('a')) // 1
```

### Object.fromEntries()

`Object.entries()` 的逆操作：

```javascript
const entries = [
  ['a', 1],
  ['b', 2],
  ['c', 3],
]
const obj = Object.fromEntries(entries)
console.log(obj) // { a: 1, b: 2, c: 3 }

// 从 Map 创建对象
const map = new Map([
  ['x', 10],
  ['y', 20],
])
const objFromMap = Object.fromEntries(map)
console.log(objFromMap) // { x: 10, y: 20 }

// 实用场景：转换对象
const original = { a: 1, b: 2, c: 3 }
const doubled = Object.fromEntries(
  Object.entries(original).map(([k, v]) => [k, v * 2])
)
console.log(doubled) // { a: 2, b: 4, c: 6 }

// 过滤对象属性
const filtered = Object.fromEntries(
  Object.entries(original).filter(([k, v]) => v > 1)
)
console.log(filtered) // { b: 2, c: 3 }
```

### Object.getOwnPropertyDescriptors()

获取对象所有自身属性的描述符：

```javascript
const obj = {
  name: '张三',
  get age() {
    return 25
  },
}

const descriptors = Object.getOwnPropertyDescriptors(obj)
console.log(descriptors)
// {
//   name: { value: '张三', writable: true, enumerable: true, configurable: true },
//   age: { get: [Function: get age], set: undefined, enumerable: true, configurable: true }
// }

// 完整克隆对象（包括 getter/setter）
const clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
```

### Object.hasOwn()

ES2022 新增，替代 `hasOwnProperty`：

```javascript
const obj = { name: '张三' }

// 传统方式
console.log(obj.hasOwnProperty('name')) // true

// 问题：对象可能没有 hasOwnProperty
const obj2 = Object.create(null)
obj2.name = '李四'
// obj2.hasOwnProperty('name'); // TypeError

// 安全方式（ES5）
console.log(Object.prototype.hasOwnProperty.call(obj2, 'name')) // true

// ES2022 推荐方式
console.log(Object.hasOwn(obj2, 'name')) // true
console.log(Object.hasOwn(obj, 'name')) // true
console.log(Object.hasOwn(obj, 'toString')) // false，继承的属性
```

### Object.groupBy()

ES2024 新增，按条件分组：

```javascript
const inventory = [
  { name: 'asparagus', type: 'vegetables', quantity: 5 },
  { name: 'bananas', type: 'fruit', quantity: 0 },
  { name: 'goat', type: 'meat', quantity: 23 },
  { name: 'cherries', type: 'fruit', quantity: 5 },
]

const result = Object.groupBy(inventory, ({ type }) => type)
console.log(result)
// {
//   vegetables: [{ name: 'asparagus', type: 'vegetables', quantity: 5 }],
//   fruit: [
//     { name: 'bananas', type: 'fruit', quantity: 0 },
//     { name: 'cherries', type: 'fruit', quantity: 5 }
//   ],
//   meat: [{ name: 'goat', type: 'meat', quantity: 23 }]
// }

// 自定义分组逻辑
const byQuantity = Object.groupBy(inventory, ({ quantity }) =>
  quantity > 0 ? 'inStock' : 'outOfStock'
)
```

## 属性遍历的顺序

ES6 规定了属性遍历的顺序：

1. 数值键（按升序）
2. 字符串键（按添加顺序）
3. Symbol 键（按添加顺序）

```javascript
const obj = {
  2: 'two',
  b: 'b',
  1: 'one',
  a: 'a',
  [Symbol('sym')]: 'symbol',
}

console.log(Object.keys(obj)) // ['1', '2', 'a', 'b']
console.log(Reflect.ownKeys(obj)) // ['1', '2', 'a', 'b', Symbol(sym)]
```

## 原型操作

### Object.setPrototypeOf() 和 Object.getPrototypeOf()

```javascript
const proto = {
  greet() {
    console.log('Hello')
  },
}
const obj = { name: '张三' }

// 设置原型
Object.setPrototypeOf(obj, proto)
obj.greet() // 'Hello'

// 获取原型
console.log(Object.getPrototypeOf(obj) === proto) // true
```

### **proto** 属性

虽然已被标准化，但建议使用 `Object.setPrototypeOf` 和 `Object.getPrototypeOf` 替代：

```javascript
const obj = {}
obj.__proto__ = {
  greet() {
    console.log('Hi')
  },
}
obj.greet() // 'Hi'

// 推荐
const obj2 = Object.create({
  greet() {
    console.log('Hi')
  },
})
obj2.greet() // 'Hi'
```

## super 关键字

ES6 允许在对象方法中使用 `super` 访问原型：

```javascript
const proto = {
  greet() {
    return 'Hello'
  },
}

const obj = {
  greet() {
    return super.greet() + ', World!'
  },
}

Object.setPrototypeOf(obj, proto)
console.log(obj.greet()) // 'Hello, World!'
```

注意：`super` 只能在对象方法的简写语法中使用：

```javascript
const obj = {
  // 正确
  method() {
    return super.toString()
  },

  // 错误
  // method: function() {
  //   return super.toString(); // SyntaxError
  // }
}
```

## 实战应用

### 深拷贝

```javascript
function deepClone(obj, seen = new WeakMap()) {
  // 处理基本类型和函数
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // 处理循环引用
  if (seen.has(obj)) {
    return seen.get(obj)
  }

  // 处理日期
  if (obj instanceof Date) {
    return new Date(obj.getTime())
  }

  // 处理正则
  if (obj instanceof RegExp) {
    return new RegExp(obj)
  }

  // 处理数组和对象
  const clone = Array.isArray(obj) ? [] : {}
  seen.set(obj, clone)

  for (const key of Reflect.ownKeys(obj)) {
    clone[key] = deepClone(obj[key], seen)
  }

  return clone
}

// 使用 structuredClone（现代浏览器）
const obj = { a: 1, b: { c: 2 } }
const clone = structuredClone(obj)
```

### 对象比较

```javascript
function shallowEqual(obj1, obj2) {
  if (obj1 === obj2) return true
  if (!obj1 || !obj2) return false

  const keys1 = Object.keys(obj1)
  const keys2 = Object.keys(obj2)

  if (keys1.length !== keys2.length) return false

  return keys1.every((key) => obj1[key] === obj2[key])
}

function deepEqual(obj1, obj2) {
  if (obj1 === obj2) return true
  if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false
  if (obj1 === null || obj2 === null) return false

  const keys1 = Object.keys(obj1)
  const keys2 = Object.keys(obj2)

  if (keys1.length !== keys2.length) return false

  return keys1.every((key) => deepEqual(obj1[key], obj2[key]))
}
```

### 对象路径访问

```javascript
function get(obj, path, defaultValue = undefined) {
  const keys = path.replace(/\[(\d+)\]/g, '.$1').split('.')
  let result = obj

  for (const key of keys) {
    if (result == null) return defaultValue
    result = result[key]
  }

  return result === undefined ? defaultValue : result
}

const data = {
  user: {
    profile: {
      name: '张三',
      addresses: [{ city: '北京' }, { city: '上海' }],
    },
  },
}

console.log(get(data, 'user.profile.name')) // '张三'
console.log(get(data, 'user.profile.addresses[0].city')) // '北京'
console.log(get(data, 'user.profile.age', 18)) // 18
```

### 对象扁平化和还原

```javascript
// 扁平化
function flatten(obj, prefix = '') {
  return Object.entries(obj).reduce((acc, [key, value]) => {
    const newKey = prefix ? `${prefix}.${key}` : key
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      Object.assign(acc, flatten(value, newKey))
    } else {
      acc[newKey] = value
    }
    return acc
  }, {})
}

// 还原
function unflatten(obj) {
  return Object.entries(obj).reduce((acc, [key, value]) => {
    const keys = key.split('.')
    let current = acc
    keys.forEach((k, i) => {
      if (i === keys.length - 1) {
        current[k] = value
      } else {
        current[k] = current[k] || {}
        current = current[k]
      }
    })
    return acc
  }, {})
}

const nested = { a: { b: { c: 1 } }, d: 2 }
const flat = flatten(nested)
console.log(flat) // { 'a.b.c': 1, d: 2 }

const restored = unflatten(flat)
console.log(restored) // { a: { b: { c: 1 } }, d: 2 }
```

---

ES6+ 对对象的增强让 JavaScript 的对象操作更加现代化。属性简写和计算属性名简化了对象创建，扩展运算符让对象合并变得直观，`Object.entries`/`Object.fromEntries` 让对象与数组的转换更加便捷。这些特性在日常开发中使用频率极高。
