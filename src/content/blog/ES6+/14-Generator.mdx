---
title: Generator 生成器函数
description: 深入掌握 ES6 Generator 函数，理解 yield 语法、双向数据传递、异步流程控制，以及与迭代器的关系
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

Generator 是 ES6 引入的一种特殊函数，可以暂停执行和恢复执行。它通过 `function*` 声明，内部使用 `yield` 表达式产出值，为异步编程和惰性求值提供了优雅的解决方案。

## Generator 基本概念

### 声明和调用

```javascript
// 声明 Generator 函数
function* gen() {
  yield 1
  yield 2
  yield 3
}

// 调用返回迭代器对象，不会立即执行函数体
const iterator = gen()

console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next()) // { value: 2, done: false }
console.log(iterator.next()) // { value: 3, done: false }
console.log(iterator.next()) // { value: undefined, done: true }
```

### 执行流程

Generator 函数遇到 `yield` 会暂停，调用 `next()` 继续执行：

```javascript
function* gen() {
  console.log('Step 1')
  yield 1
  console.log('Step 2')
  yield 2
  console.log('Step 3')
  return 3
}

const iterator = gen()
// 不输出任何内容

iterator.next()
// 输出 'Step 1'
// 返回 { value: 1, done: false }

iterator.next()
// 输出 'Step 2'
// 返回 { value: 2, done: false }

iterator.next()
// 输出 'Step 3'
// 返回 { value: 3, done: true }
```

### yield 表达式

`yield` 只能在 Generator 函数内部使用：

```javascript
// 错误：yield 在普通函数中
function normalFn() {
  // yield 1; // SyntaxError
}

// 正确
function* gen() {
  yield 1

  // yield 在表达式中需要括号
  console.log('Hello ' + (yield 'world'))
}
```

### 可迭代性

Generator 函数返回的迭代器同时实现了可迭代协议：

```javascript
function* gen() {
  yield 1
  yield 2
  yield 3
}

// for...of 遍历
for (const value of gen()) {
  console.log(value) // 1, 2, 3
}

// 展开运算符
console.log([...gen()]) // [1, 2, 3]

// Array.from
console.log(Array.from(gen())) // [1, 2, 3]

// 解构赋值
const [a, b, c] = gen()
console.log(a, b, c) // 1 2 3
```

注意：`return` 的值不会被 `for...of` 遍历到。

## yield\* 表达式

`yield*` 用于委托给另一个可迭代对象或 Generator：

```javascript
function* inner() {
  yield 2
  yield 3
}

function* outer() {
  yield 1
  yield* inner()
  yield 4
}

console.log([...outer()]) // [1, 2, 3, 4]
```

`yield*` 可以用于任何可迭代对象：

```javascript
function* gen() {
  yield* [1, 2, 3]
  yield* 'abc'
  yield* new Set([4, 5])
}

console.log([...gen()]) // [1, 2, 3, 'a', 'b', 'c', 4, 5]
```

获取 `yield*` 的返回值：

```javascript
function* inner() {
  yield 1
  yield 2
  return 'done'
}

function* outer() {
  const result = yield* inner()
  console.log('inner returned:', result)
  yield 3
}

const gen = outer()
console.log(gen.next()) // { value: 1, done: false }
console.log(gen.next()) // { value: 2, done: false }
console.log(gen.next())
// 'inner returned: done'
// { value: 3, done: false }
```

## 双向数据传递

### next() 传入值

`next()` 可以传入参数，作为上一个 `yield` 表达式的返回值：

```javascript
function* gen() {
  const a = yield 1
  console.log('a:', a)

  const b = yield 2
  console.log('b:', b)

  return a + b
}

const iterator = gen()

console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next(10)) // 'a: 10', { value: 2, done: false }
console.log(iterator.next(20)) // 'b: 20', { value: 30, done: true }
```

首次调用 `next()` 的参数会被忽略，因为此时没有上一个 `yield`。

### throw() 方法

在 Generator 内部抛出错误：

```javascript
function* gen() {
  try {
    yield 1
    yield 2
  } catch (e) {
    console.log('Caught:', e)
  }
  yield 3
}

const iterator = gen()
console.log(iterator.next()) // { value: 1, done: false }
iterator.throw(new Error('Something went wrong'))
// 'Caught: Error: Something went wrong'
// { value: 3, done: false }
```

如果错误未被捕获，会向外抛出：

```javascript
function* gen() {
  yield 1
  yield 2
}

const iterator = gen()
iterator.next()

try {
  iterator.throw(new Error('oops'))
} catch (e) {
  console.log('External catch:', e.message)
}
// 'External catch: oops'
```

### return() 方法

提前结束迭代器：

```javascript
function* gen() {
  yield 1
  yield 2
  yield 3
}

const iterator = gen()
console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.return('end')) // { value: 'end', done: true }
console.log(iterator.next()) // { value: undefined, done: true }
```

如果 Generator 内部有 `try...finally`，`finally` 仍会执行：

```javascript
function* gen() {
  try {
    yield 1
    yield 2
  } finally {
    yield 'finally'
  }
}

const iterator = gen()
console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.return('end'))
// { value: 'finally', done: false }（先执行 finally）
console.log(iterator.next()) // { value: 'end', done: true }
```

## Generator 作为对象方法

```javascript
const obj = {
  // 方法简写
  *generator() {
    yield 1
    yield 2
  },

  // 完整写法
  generator2: function* () {
    yield 3
    yield 4
  },
}

console.log([...obj.generator()]) // [1, 2]
console.log([...obj.generator2()]) // [3, 4]
```

## Generator 与 this

Generator 函数返回的迭代器是该函数的实例，但不能把 Generator 当作普通构造函数：

```javascript
function* Gen() {
  this.a = 1
  yield (this.b = 2)
}

// new Gen(); // 可以调用，但 this 不是返回的迭代器

const iterator = Gen.call(Gen.prototype)
console.log(iterator.next()) // { value: 2, done: false }
console.log(iterator.a) // 1
console.log(iterator.b) // 2
```

## 异步流程控制

### 自动执行器

```javascript
function run(generatorFn) {
  const gen = generatorFn()

  function next(data) {
    const result = gen.next(data)
    if (result.done) return result.value

    // 假设 yield 后面是 Promise
    result.value.then(next)
  }

  next()
}

// 使用
function* asyncTask() {
  const user = yield fetch('/api/user').then((r) => r.json())
  const posts = yield fetch(`/api/posts?userId=${user.id}`).then((r) =>
    r.json()
  )
  console.log(user, posts)
}

run(asyncTask)
```

### co 库风格

```javascript
function co(gen) {
  return new Promise((resolve, reject) => {
    const g = typeof gen === 'function' ? gen() : gen

    function step(nextFn) {
      let result
      try {
        result = nextFn()
      } catch (e) {
        return reject(e)
      }

      if (result.done) {
        return resolve(result.value)
      }

      Promise.resolve(result.value).then(
        (value) => step(() => g.next(value)),
        (err) => step(() => g.throw(err))
      )
    }

    step(() => g.next())
  })
}

// 使用
co(function* () {
  const a = yield Promise.resolve(1)
  const b = yield Promise.resolve(2)
  return a + b
}).then((result) => console.log(result)) // 3
```

## 实战应用

### 斐波那契数列

```javascript
function* fibonacci() {
  let [prev, curr] = [0, 1]
  while (true) {
    yield curr
    ;[prev, curr] = [curr, prev + curr]
  }
}

// 取前 10 个
function* take(iterable, n) {
  let count = 0
  for (const item of iterable) {
    if (count++ >= n) return
    yield item
  }
}

console.log([...take(fibonacci(), 10)])
// [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

### ID 生成器

```javascript
function* idGenerator(prefix = 'id') {
  let id = 1
  while (true) {
    yield `${prefix}_${id++}`
  }
}

const gen = idGenerator('user')
console.log(gen.next().value) // 'user_1'
console.log(gen.next().value) // 'user_2'
console.log(gen.next().value) // 'user_3'
```

### 惰性求值管道

```javascript
function* map(iterable, fn) {
  for (const item of iterable) {
    yield fn(item)
  }
}

function* filter(iterable, predicate) {
  for (const item of iterable) {
    if (predicate(item)) yield item
  }
}

function* take(iterable, n) {
  let count = 0
  for (const item of iterable) {
    if (count++ >= n) return
    yield item
  }
}

function* range(start, end) {
  for (let i = start; i <= end; i++) {
    yield i
  }
}

// 链式处理
const pipeline = take(
  filter(
    map(range(1, 100), (x) => x * 2),
    (x) => x % 3 === 0
  ),
  5
)

console.log([...pipeline]) // [6, 12, 18, 24, 30]
```

### 状态机

```javascript
function* loginFlow() {
  while (true) {
    const credentials = yield 'waiting_for_login'

    if (credentials.username === 'admin' && credentials.password === '123') {
      const action = yield 'logged_in'

      if (action === 'logout') {
        yield 'logged_out'
      }
    } else {
      yield 'login_failed'
    }
  }
}

const flow = loginFlow()
console.log(flow.next().value) // 'waiting_for_login'

console.log(flow.next({ username: 'admin', password: 'wrong' }).value)
// 'login_failed'

console.log(flow.next().value) // 'waiting_for_login'

console.log(flow.next({ username: 'admin', password: '123' }).value)
// 'logged_in'

console.log(flow.next('logout').value) // 'logged_out'
```

### 扁平化嵌套结构

```javascript
function* flatten(arr) {
  for (const item of arr) {
    if (Array.isArray(item)) {
      yield* flatten(item)
    } else {
      yield item
    }
  }
}

const nested = [1, [2, [3, [4, 5]]], 6]
console.log([...flatten(nested)]) // [1, 2, 3, 4, 5, 6]
```

### 并发控制

```javascript
async function* limitConcurrency(tasks, limit) {
  const executing = new Set()

  for (const task of tasks) {
    const promise = task().then((result) => {
      executing.delete(promise)
      return result
    })

    executing.add(promise)

    if (executing.size >= limit) {
      yield await Promise.race(executing)
    }
  }

  while (executing.size > 0) {
    yield await Promise.race(executing)
  }
}

// 使用
const tasks = urls.map((url) => () => fetch(url))

for await (const result of limitConcurrency(tasks, 3)) {
  console.log(result)
}
```

### 数据流处理

```javascript
function* parseCSV(text) {
  const lines = text.split('\n')
  const headers = lines[0].split(',')

  for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split(',')
    const obj = {}
    headers.forEach((header, index) => {
      obj[header.trim()] = values[index]?.trim()
    })
    yield obj
  }
}

const csv = `name,age,city
张三,25,北京
李四,30,上海
王五,28,广州`

for (const row of parseCSV(csv)) {
  console.log(row)
}
// { name: '张三', age: '25', city: '北京' }
// { name: '李四', age: '30', city: '上海' }
// { name: '王五', age: '28', city: '广州' }
```

## Generator vs async/await

Generator 和 async/await 都可以处理异步流程，但有重要区别：

```javascript
// Generator：需要执行器
function* fetchDataGen() {
  const user = yield fetch('/api/user')
  const posts = yield fetch(`/api/posts?userId=${user.id}`)
  return posts
}

// async/await：原生支持
async function fetchDataAsync() {
  const user = await fetch('/api/user')
  const posts = await fetch(`/api/posts?userId=${user.id}`)
  return posts
}
```

Generator 的优势：

- 可以双向通信（通过 `next()` 传值和 `yield` 返回值）
- 可以手动控制迭代过程
- 更适合惰性求值和无限序列

async/await 的优势：

- 语法更简洁
- 原生支持，无需执行器
- 错误处理更直观

---

Generator 是 JavaScript 中非常强大的特性，它改变了函数只能一次性执行完毕的传统。通过 `yield` 实现的暂停和恢复机制，Generator 为惰性求值、状态机、异步流程控制等场景提供了优雅的解决方案。虽然 async/await 在异步编程中更为常用，但理解 Generator 对于掌握现代 JavaScript 仍然非常重要。
