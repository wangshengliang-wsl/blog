---
title: ES Module 模块语法
description: 深入掌握 ES6 模块系统，理解 import/export 语法、默认导出、命名导出、模块聚合、以及与 CommonJS 的区别
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

ES6 引入了原生的模块系统（ES Module，简称 ESM），这是 JavaScript 语言层面的模块化方案。它提供了 `import` 和 `export` 语法，支持静态分析和树摇优化，是现代 JavaScript 开发的标准模块方案。

## 模块基础

### 什么是模块

模块是独立的代码单元，具有自己的作用域。模块中的变量、函数、类默认对外不可见，需要显式导出才能被其他模块使用。

```javascript
// utils.js - 一个模块
const privateVariable = 'private'

export const publicVariable = 'public'

export function publicFunction() {
  console.log(privateVariable)
}
```

### 模块的特点

ES Module 具有以下特点：

1. **严格模式**：模块代码自动运行在严格模式下
2. **模块作用域**：顶层变量不会污染全局作用域
3. **单例模式**：模块只会被执行一次，多次导入返回同一实例
4. **静态结构**：导入导出在编译时确定，支持静态分析
5. **异步加载**：浏览器中模块默认异步加载

### 在浏览器中使用

```html
<!-- 使用 type="module" 标记模块脚本 -->
<script type="module">
  import { greeting } from './utils.js'
  console.log(greeting)
</script>

<!-- 外部模块文件 -->
<script type="module" src="app.js"></script>

<!-- 兼容不支持模块的浏览器 -->
<script nomodule src="fallback.js"></script>
```

### 在 Node.js 中使用

```javascript
// 方式一：使用 .mjs 扩展名
// utils.mjs
export const name = 'utils';

// 方式二：在 package.json 中设置 type
// package.json
{
  "type": "module"
}

// 方式三：使用 .js 扩展名（需要上述配置）
// utils.js
export const name = 'utils';
```

## 导出语法

### 命名导出

命名导出允许导出多个值，每个值都有自己的名称：

```javascript
// 声明时导出
export const PI = 3.14159
export let count = 0
export function add(a, b) {
  return a + b
}
export class Calculator {
  // ...
}

// 声明后导出
const E = 2.71828
function multiply(a, b) {
  return a * b
}
class MathUtils {
  // ...
}

export { E, multiply, MathUtils }
```

### 重命名导出

```javascript
const internalName = 'internal'
function internalFunction() {}

// 导出时重命名
export { internalName as publicName, internalFunction as publicFunction }
```

### 默认导出

每个模块只能有一个默认导出：

```javascript
// 导出值
export default 42;

// 导出函数
export default function(x) {
  return x * 2;
}

// 导出类
export default class {
  constructor() {}
}

// 导出具名函数/类
export default function myFunction() {}
export default class MyClass {}

// 单独声明后默认导出
const config = { /* ... */ };
export default config;

// 等价于
export { config as default };
```

### 混合导出

```javascript
// 同时使用默认导出和命名导出
export const version = '1.0.0';
export const author = '张三';

export default function main() {
  console.log('Main function');
}

// 也可以写成
const version = '1.0.0';
const author = '张三';
function main() {}

export { version, author, main as default };
```

### 导出声明的限制

```javascript
// 正确
export const a = 1;
export function fn() {}
export class Cls {}

// 错误：不能导出表达式
// export 1;
// export 1 + 2;

// 错误：default 后面只能是表达式或声明
// export default const x = 1; // 语法错误

// 正确的默认导出
export default 1 + 2;  // 表达式
export default function() {}  // 函数声明
export default class {}  // 类声明
```

## 导入语法

### 导入命名导出

```javascript
// 导入指定的命名导出
import { PI, add, Calculator } from './math.js'

// 使用导入的值
console.log(PI)
console.log(add(1, 2))
const calc = new Calculator()
```

### 重命名导入

```javascript
// 避免命名冲突
import { add as addNumbers } from './math.js'
import { add as addStrings } from './string.js'

addNumbers(1, 2)
addStrings('Hello', 'World')
```

### 导入默认导出

```javascript
// 导入默认导出（名称可以任意）
import myFunction from './module.js'
import whatever from './module.js'
import $ from 'jquery'

myFunction()
```

### 混合导入

```javascript
// 同时导入默认导出和命名导出
import main, { version, author } from './module.js'

// 或者
import main, * as utils from './module.js'
console.log(utils.version)
```

### 命名空间导入

```javascript
// 将所有导出作为命名空间对象导入
import * as math from './math.js'

console.log(math.PI)
console.log(math.add(1, 2))
console.log(math.default) // 默认导出（如果有的话）
```

### 仅执行模块

```javascript
// 只执行模块代码，不导入任何值
import './polyfills.js'
import './init.js'

// 常用于：
// - 加载 polyfills
// - 注册全局事件
// - 执行初始化逻辑
```

### 导入的特性

```javascript
// 导入的值是只读的
import { count } from './counter.js'

// count = 10; // TypeError: Assignment to constant variable

// 但如果导出的是对象，可以修改其属性
import { config } from './config.js'
config.debug = true // 可以修改（但不推荐）

// 导入是实时绑定（Live Binding）
// counter.js
export let count = 0
export function increment() {
  count++
}

// main.js
import { count, increment } from './counter.js'
console.log(count) // 0
increment()
console.log(count) // 1（实时反映变化）
```

## 模块聚合（Re-export）

### 转发导出

```javascript
// utils/index.js
// 从其他模块导出
export { default as math } from './math.js';
export { format, parse } from './date.js';
export * from './string.js';

// 相当于
import { default as math } from './math.js';
import { format, parse } from './date.js';
import * as string from './string.js';
export { math, format, parse, ...string };
```

### 导出所有

```javascript
// 导出另一个模块的所有命名导出（不包括默认导出）
export * from './module.js'

// 导出所有并设置命名空间
export * as utils from './utils.js'
// 使用：import { utils } from './index.js';
```

### 选择性重导出

```javascript
// components/index.js
export { Button } from './Button.js'
export { Modal } from './Modal.js'
export { Form } from './Form.js'
export { Input, Textarea, Select } from './FormElements.js'

// 使用
import { Button, Modal, Input } from './components'
```

### 重命名重导出

```javascript
// 重命名后再导出
export { default as DefaultExport } from './module.js'
export { originalName as newName } from './module.js'

// 将命名导出转为默认导出
export { namedExport as default } from './module.js'
```

### 创建模块入口

```javascript
// lib/index.js - 库的入口文件
// 公共 API
export { createApp, App } from './core/app.js';
export { Router, Route, Link } from './router/index.js';
export { Store, createStore } from './store/index.js';

// 类型导出（TypeScript）
export type { AppConfig, RouteConfig } from './types.js';

// 默认导出
export { createApp as default } from './core/app.js';
```

## import() 动态导入

### 基本用法

`import()` 函数返回一个 Promise，实现运行时按需加载：

```javascript
// 动态导入
const module = await import('./module.js')
console.log(module.default)
console.log(module.namedExport)

// 或使用 .then()
import('./module.js')
  .then((module) => {
    console.log(module)
  })
  .catch((err) => {
    console.error('Failed to load module', err)
  })
```

### 条件导入

```javascript
// 根据条件导入不同模块
async function loadTheme(isDark) {
  if (isDark) {
    return import('./themes/dark.js')
  }
  return import('./themes/light.js')
}

// 根据环境导入
const config = await import(
  process.env.NODE_ENV === 'production' ? './config.prod.js' : './config.dev.js'
)
```

### 路由懒加载

```javascript
// React 路由懒加载
const Home = React.lazy(() => import('./pages/Home'))
const About = React.lazy(() => import('./pages/About'))
const Contact = React.lazy(() => import('./pages/Contact'))

// Vue 路由懒加载
const routes = [
  {
    path: '/',
    component: () => import('./views/Home.vue'),
  },
  {
    path: '/about',
    component: () => import('./views/About.vue'),
  },
]
```

### 并行动态导入

```javascript
// 并行加载多个模块
const [moduleA, moduleB, moduleC] = await Promise.all([
  import('./moduleA.js'),
  import('./moduleB.js'),
  import('./moduleC.js'),
])

// 有默认导出的解构
const [{ default: A }, { default: B }, { namedExport: C }] = await Promise.all([
  import('./A.js'),
  import('./B.js'),
  import('./C.js'),
])
```

### 带变量的动态导入

```javascript
// 动态路径
async function loadLocale(language) {
  const locale = await import(`./locales/${language}.js`)
  return locale.default
}

// 注意：路径中的变量部分需要一些静态信息
// 这样打包工具才能知道可能的文件范围
const lang = 'zh-CN'
const messages = await import(`./i18n/${lang}.json`)
```

## import.meta

`import.meta` 是一个包含模块元信息的对象：

```javascript
// 获取当前模块的 URL
console.log(import.meta.url)
// 浏览器: 'http://localhost:3000/src/app.js'
// Node.js: 'file:///path/to/app.js'

// 获取模块目录
const __dirname = new URL('.', import.meta.url).pathname

// 判断是否为主模块（Node.js）
// 需要比较 import.meta.url 和 process.argv[1]

// Vite 特有的 import.meta
console.log(import.meta.env.MODE) // 'development' 或 'production'
console.log(import.meta.env.VITE_API_URL) // 环境变量

// 热模块替换（Vite）
if (import.meta.hot) {
  import.meta.hot.accept((newModule) => {
    // 处理热更新
  })
}
```

## 模块设计模式

### 单例模式

```javascript
// database.js
let instance = null

class Database {
  constructor() {
    if (instance) {
      return instance
    }
    this.connection = null
    instance = this
  }

  connect(config) {
    this.connection = createConnection(config)
  }
}

export default new Database()

// 任何地方导入都是同一个实例
// main.js
import db from './database.js'
db.connect({ host: 'localhost' })

// other.js
import db from './database.js'
// db 是同一个实例，已经连接
```

### 工具模块

```javascript
// utils/string.js
export function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

export function truncate(str, length) {
  if (str.length <= length) return str
  return str.slice(0, length) + '...'
}

export function slugify(str) {
  return str
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^\w-]+/g, '')
}

// 命名空间导入使用
import * as stringUtils from './utils/string.js'
stringUtils.capitalize('hello')
```

### 配置模块

```javascript
// config.js
const config = {
  api: {
    baseUrl: 'https://api.example.com',
    timeout: 5000,
  },
  features: {
    darkMode: true,
    analytics: process.env.NODE_ENV === 'production',
  },
}

// 冻结配置防止意外修改
Object.freeze(config)
Object.freeze(config.api)
Object.freeze(config.features)

export default config

// 或者导出 getter 函数
export function getConfig(path) {
  return path.split('.').reduce((obj, key) => obj?.[key], config)
}
```

### 插件模块

```javascript
// plugins/logger.js
export default {
  name: 'logger',
  install(app, options = {}) {
    const prefix = options.prefix || '[App]'

    app.prototype.$log = function (message) {
      console.log(`${prefix} ${message}`)
    }

    app.mixin({
      created() {
        this.$log(`${this.$options.name} created`)
      },
    })
  },
}

// main.js
import { createApp } from 'vue'
import logger from './plugins/logger.js'

const app = createApp(App)
app.use(logger, { prefix: '[MyApp]' })
```

### 服务模块

```javascript
// services/api.js
const BASE_URL = 'https://api.example.com'

async function request(endpoint, options = {}) {
  const response = await fetch(`${BASE_URL}${endpoint}`, {
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
    ...options,
  })

  if (!response.ok) {
    throw new Error(`API Error: ${response.status}`)
  }

  return response.json()
}

export const userService = {
  getAll: () => request('/users'),
  getById: (id) => request(`/users/${id}`),
  create: (data) =>
    request('/users', {
      method: 'POST',
      body: JSON.stringify(data),
    }),
  update: (id, data) =>
    request(`/users/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    }),
  delete: (id) =>
    request(`/users/${id}`, {
      method: 'DELETE',
    }),
}

export const postService = {
  getAll: () => request('/posts'),
  getByUser: (userId) => request(`/users/${userId}/posts`),
}
```

## 与 CommonJS 的区别

### 语法对比

```javascript
// ES Module
import fs from 'fs'
import { readFile } from 'fs'
export const name = 'ESM'
export default function () {}

// CommonJS
const fs = require('fs')
const { readFile } = require('fs')
module.exports.name = 'CJS'
module.exports = function () {}
```

### 加载时机

```javascript
// ES Module：静态分析，编译时确定依赖
import { foo } from './module.js' // 必须在顶层

// CommonJS：运行时加载
if (condition) {
  const module = require('./module.js') // 可以条件加载
}

// ESM 动态导入实现类似效果
if (condition) {
  const module = await import('./module.js')
}
```

### 导出绑定

```javascript
// ES Module：导出的是绑定（实时）
// counter.js
export let count = 0
export function increment() {
  count++
}

// main.js
import { count, increment } from './counter.js'
console.log(count) // 0
increment()
console.log(count) // 1

// CommonJS：导出的是值的拷贝
// counter.js
let count = 0
module.exports = {
  count,
  increment() {
    count++
  },
}

// main.js
const { count, increment } = require('./counter.js')
console.log(count) // 0
increment()
console.log(count) // 0（仍然是 0）
```

### this 的值

```javascript
// ES Module：顶层 this 是 undefined
console.log(this) // undefined

// CommonJS：顶层 this 是 module.exports
console.log(this === module.exports) // true
```

### 互操作性

```javascript
// 在 ESM 中导入 CommonJS
import cjsModule from './cjs-module.cjs'
import { named } from './cjs-module.cjs' // 可能不支持

// 在 CommonJS 中导入 ESM（Node.js 需要使用动态导入）
// const esmModule = require('./esm-module.js'); // 不支持
const esmModule = await import('./esm-module.js') // 支持
```

## 最佳实践

### 命名约定

```javascript
// 文件名使用小写和连字符
// user-service.js
// form-validation.js

// 导出名称使用有意义的名称
export const MAX_RETRY_COUNT = 3
export function validateEmail(email) {}
export class UserRepository {}

// 默认导出使用 default 时注意命名
import UserService from './user-service.js' // 好
import us from './user-service.js' // 不好，不清晰
```

### 避免循环依赖

```javascript
// 避免 A 导入 B，B 又导入 A

// 解决方案 1：重构到第三个模块
// shared.js
export const sharedFunction = () => {}

// a.js
import { sharedFunction } from './shared.js'

// b.js
import { sharedFunction } from './shared.js'

// 解决方案 2：使用动态导入
// a.js
export async function useB() {
  const { bFunction } = await import('./b.js')
  return bFunction()
}
```

### 导出组织

```javascript
// 推荐：在文件底部集中导出
const privateHelper = () => {}

const publicFunction = () => {}
const PublicClass = class {}
const PUBLIC_CONSTANT = 42

export { publicFunction, PublicClass, PUBLIC_CONSTANT }

export default publicFunction
```

### 类型导出（TypeScript）

```typescript
// types.ts
export interface User {
  id: number
  name: string
}

export type UserRole = 'admin' | 'user' | 'guest'

// 使用 type-only 导入（TypeScript 3.8+）
import type { User, UserRole } from './types'

// 混合导入
import { createUser, type User } from './user'
```

---

ES Module 是 JavaScript 的标准模块系统，提供了清晰的导入导出语法和静态分析能力。理解其语法细节、与 CommonJS 的区别以及各种设计模式，是现代 JavaScript 开发的必备技能。在下一篇中，我们将深入探讨 ES Module 的加载机制和高级特性。
