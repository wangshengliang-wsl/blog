---
title: Reflect 元编程
description: 深入理解 ES6 Reflect 对象，掌握其 13 个静态方法，理解与 Proxy 的配合使用，以及在元编程中的实际应用
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

Reflect 是 ES6 新增的内置对象，它将 Object 对象上一些明显属于语言内部的方法移到 Reflect 上，并让这些方法返回更合理的结果。Reflect 与 Proxy 紧密配合，为 JavaScript 提供了完整的元编程能力。

## 为什么需要 Reflect

### 统一的函数式 API

ES5 中操作对象的方法分散在 Object 上，且行为不一致：

```javascript
// ES5：命令式操作
'name' in obj
delete obj.name

// ES6：函数式操作
Reflect.has(obj, 'name')
Reflect.deleteProperty(obj, 'name')
```

### 更合理的返回值

Object 方法在失败时可能抛出异常，Reflect 方法返回布尔值表示成功或失败：

```javascript
// ES5：Object.defineProperty 可能抛出异常
try {
  Object.defineProperty(obj, 'name', { value: '张三' })
} catch (e) {
  // 处理错误
}

// ES6：Reflect.defineProperty 返回布尔值
if (Reflect.defineProperty(obj, 'name', { value: '张三' })) {
  // 成功
} else {
  // 失败
}
```

### 与 Proxy 的完美配合

Reflect 的方法与 Proxy 的 handler 方法一一对应：

```javascript
const proxy = new Proxy(target, {
  get(target, prop, receiver) {
    console.log('Getting:', prop)
    return Reflect.get(target, prop, receiver)
  },
  set(target, prop, value, receiver) {
    console.log('Setting:', prop)
    return Reflect.set(target, prop, value, receiver)
  },
})
```

## Reflect 的 13 个静态方法

### Reflect.get(target, prop, receiver?)

获取对象属性：

```javascript
const obj = { name: '张三', age: 25 }
console.log(Reflect.get(obj, 'name')) // '张三'

// 带 receiver：影响 getter 中的 this
const objWithGetter = {
  _name: '张三',
  get name() {
    return this._name
  },
}

const proxy = {
  _name: '李四',
}

console.log(Reflect.get(objWithGetter, 'name')) // '张三'
console.log(Reflect.get(objWithGetter, 'name', proxy)) // '李四'
```

### Reflect.set(target, prop, value, receiver?)

设置对象属性：

```javascript
const obj = {}

const result = Reflect.set(obj, 'name', '张三')
console.log(result) // true
console.log(obj.name) // '张三'

// 对于不可配置或不可写的属性，返回 false
const frozen = Object.freeze({ name: '张三' })
console.log(Reflect.set(frozen, 'name', '李四')) // false
```

### Reflect.has(target, prop)

相当于 `in` 运算符：

```javascript
const obj = { name: '张三' }

console.log(Reflect.has(obj, 'name')) // true
console.log(Reflect.has(obj, 'age')) // false
console.log(Reflect.has(obj, 'toString')) // true（继承的属性）
```

### Reflect.deleteProperty(target, prop)

相当于 `delete` 运算符：

```javascript
const obj = { name: '张三', age: 25 }

console.log(Reflect.deleteProperty(obj, 'name')) // true
console.log(obj) // { age: 25 }

// 删除不存在的属性也返回 true
console.log(Reflect.deleteProperty(obj, 'address')) // true

// 删除不可配置的属性返回 false
const frozen = Object.freeze({ id: 1 })
console.log(Reflect.deleteProperty(frozen, 'id')) // false
```

### Reflect.construct(target, args, newTarget?)

相当于 `new target(...args)`：

```javascript
function Person(name, age) {
  this.name = name
  this.age = age
}

const person = Reflect.construct(Person, ['张三', 25])
console.log(person) // Person { name: '张三', age: 25 }
console.log(person instanceof Person) // true

// newTarget 参数：指定 new.target
function Animal(type) {
  this.type = type
  console.log('new.target:', new.target?.name)
}

function Dog(type) {
  this.type = type
}

Reflect.construct(Animal, ['dog'], Dog)
// 'new.target: Dog'
```

### Reflect.getPrototypeOf(target)

获取对象原型：

```javascript
const arr = [1, 2, 3]
console.log(Reflect.getPrototypeOf(arr) === Array.prototype) // true

const obj = Object.create({ name: '原型对象' })
console.log(Reflect.getPrototypeOf(obj)) // { name: '原型对象' }

// 与 Object.getPrototypeOf 的区别：参数必须是对象
// Object.getPrototypeOf('string'); // 会转换
// Reflect.getPrototypeOf('string'); // TypeError
```

### Reflect.setPrototypeOf(target, proto)

设置对象原型：

```javascript
const obj = {}
const proto = {
  greet() {
    console.log('Hello')
  },
}

const result = Reflect.setPrototypeOf(obj, proto)
console.log(result) // true
obj.greet() // 'Hello'

// 不可扩展的对象无法修改原型
const frozen = Object.preventExtensions({})
console.log(Reflect.setPrototypeOf(frozen, proto)) // false
```

### Reflect.apply(func, thisArg, args)

调用函数，相当于 `Function.prototype.apply.call(func, thisArg, args)`：

```javascript
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`
}

const context = { name: '张三' }
const result = Reflect.apply(greet, context, ['你好', '！'])
console.log(result) // '你好, 张三！'

// 实际应用：更安全的函数调用
const hasOwnProperty = Reflect.apply(
  Object.prototype.hasOwnProperty,
  { name: '张三' },
  ['name']
)
console.log(hasOwnProperty) // true
```

### Reflect.defineProperty(target, prop, descriptor)

定义属性：

```javascript
const obj = {}

const result = Reflect.defineProperty(obj, 'name', {
  value: '张三',
  writable: true,
  enumerable: true,
  configurable: true,
})

console.log(result) // true
console.log(obj.name) // '张三'

// 失败时返回 false，而非抛出异常
const frozen = Object.freeze({})
console.log(Reflect.defineProperty(frozen, 'name', { value: '张三' })) // false
```

### Reflect.getOwnPropertyDescriptor(target, prop)

获取属性描述符：

```javascript
const obj = { name: '张三' }

const descriptor = Reflect.getOwnPropertyDescriptor(obj, 'name')
console.log(descriptor)
// { value: '张三', writable: true, enumerable: true, configurable: true }

// 不存在的属性返回 undefined
console.log(Reflect.getOwnPropertyDescriptor(obj, 'age')) // undefined
```

### Reflect.isExtensible(target)

判断对象是否可扩展：

```javascript
const obj = {}
console.log(Reflect.isExtensible(obj)) // true

Object.preventExtensions(obj)
console.log(Reflect.isExtensible(obj)) // false

// Object.freeze 和 Object.seal 也会使对象不可扩展
const frozen = Object.freeze({})
console.log(Reflect.isExtensible(frozen)) // false
```

### Reflect.preventExtensions(target)

阻止对象扩展：

```javascript
const obj = {}
const result = Reflect.preventExtensions(obj)
console.log(result) // true

obj.name = '张三'
console.log(obj.name) // undefined（严格模式下报错）

console.log(Reflect.isExtensible(obj)) // false
```

### Reflect.ownKeys(target)

返回对象所有自身属性的键，包括 Symbol：

```javascript
const sym = Symbol('sym')
const obj = {
  name: '张三',
  [sym]: 'symbol value',
}

console.log(Reflect.ownKeys(obj)) // ['name', Symbol(sym)]

// 包含不可枚举属性
const objWithNonEnum = Object.defineProperty({}, 'hidden', {
  value: 'secret',
  enumerable: false,
})
console.log(Reflect.ownKeys(objWithNonEnum)) // ['hidden']
console.log(Object.keys(objWithNonEnum)) // []
```

## 与 Proxy 的配合使用

Reflect 方法与 Proxy trap 一一对应，在 Proxy handler 中使用 Reflect 是最佳实践：

```javascript
const target = {
  name: '张三',
  age: 25,
}

const handler = {
  get(target, prop, receiver) {
    console.log(`Getting ${prop}`)
    return Reflect.get(target, prop, receiver)
  },

  set(target, prop, value, receiver) {
    console.log(`Setting ${prop} = ${value}`)
    return Reflect.set(target, prop, value, receiver)
  },

  has(target, prop) {
    console.log(`Checking ${prop}`)
    return Reflect.has(target, prop)
  },

  deleteProperty(target, prop) {
    console.log(`Deleting ${prop}`)
    return Reflect.deleteProperty(target, prop)
  },
}

const proxy = new Proxy(target, handler)

proxy.name // 'Getting name'
proxy.age = 26 // 'Setting age = 26'
'name' in proxy // 'Checking name'
delete proxy.age // 'Deleting age'
```

### receiver 参数的重要性

`receiver` 参数确保在继承场景中 `this` 指向正确：

```javascript
const parent = {
  get name() {
    return this._name
  },
}

const child = Object.create(
  new Proxy(parent, {
    get(target, prop, receiver) {
      console.log('receiver === child:', receiver === child)
      return Reflect.get(target, prop, receiver)
    },
  })
)

child._name = '子对象'
console.log(child.name)
// 'receiver === child: true'
// '子对象'
```

如果不传 `receiver`，getter 中的 `this` 会指向原始目标对象而非代理对象。

## 实战应用

### 观察者模式

```javascript
function createObservable(target) {
  const observers = new Map()

  return new Proxy(target, {
    set(target, prop, value, receiver) {
      const oldValue = target[prop]
      const result = Reflect.set(target, prop, value, receiver)

      if (result && oldValue !== value) {
        const propObservers = observers.get(prop)
        if (propObservers) {
          propObservers.forEach((fn) => fn(value, oldValue, prop))
        }
      }

      return result
    },

    get(target, prop, receiver) {
      if (prop === 'observe') {
        return (propName, callback) => {
          if (!observers.has(propName)) {
            observers.set(propName, new Set())
          }
          observers.get(propName).add(callback)
        }
      }
      return Reflect.get(target, prop, receiver)
    },
  })
}

const user = createObservable({ name: '张三', age: 25 })

user.observe('age', (newVal, oldVal) => {
  console.log(`Age changed from ${oldVal} to ${newVal}`)
})

user.age = 26 // 'Age changed from 25 to 26'
```

### 属性访问控制

```javascript
function createAccessControl(target, rules) {
  return new Proxy(target, {
    get(target, prop, receiver) {
      const rule = rules[prop]
      if (rule?.readable === false) {
        throw new Error(`Property "${prop}" is not readable`)
      }
      return Reflect.get(target, prop, receiver)
    },

    set(target, prop, value, receiver) {
      const rule = rules[prop]
      if (rule?.writable === false) {
        throw new Error(`Property "${prop}" is not writable`)
      }
      if (rule?.validator && !rule.validator(value)) {
        throw new Error(`Invalid value for property "${prop}"`)
      }
      return Reflect.set(target, prop, value, receiver)
    },

    deleteProperty(target, prop) {
      const rule = rules[prop]
      if (rule?.deletable === false) {
        throw new Error(`Property "${prop}" cannot be deleted`)
      }
      return Reflect.deleteProperty(target, prop)
    },
  })
}

const user = createAccessControl(
  { name: '张三', id: 1 },
  {
    name: { writable: true, validator: (v) => typeof v === 'string' },
    id: { writable: false, deletable: false },
  }
)

user.name = '李四' // 正常
// user.id = 2;      // Error: Property "id" is not writable
// delete user.id;   // Error: Property "id" cannot be deleted
```

### 方法拦截和日志

```javascript
function createMethodLogger(obj, logFn = console.log) {
  return new Proxy(obj, {
    get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver)

      if (typeof value === 'function') {
        return function (...args) {
          const start = performance.now()
          const result = Reflect.apply(value, this, args)
          const duration = performance.now() - start

          logFn({
            method: prop,
            args,
            result,
            duration: `${duration.toFixed(2)}ms`,
          })

          return result
        }
      }

      return value
    },
  })
}

const math = createMethodLogger({
  add(a, b) {
    return a + b
  },
  multiply(a, b) {
    return a * b
  },
})

math.add(1, 2)
// { method: 'add', args: [1, 2], result: 3, duration: '0.02ms' }
```

### 链式 API 构建

```javascript
function createChainable(target) {
  return new Proxy(target, {
    get(target, prop, receiver) {
      const value = Reflect.get(target, prop, receiver)

      if (typeof value === 'function') {
        return function (...args) {
          const result = Reflect.apply(value, target, args)
          // 如果方法返回 undefined，则返回代理以支持链式调用
          return result === undefined ? receiver : result
        }
      }

      return value
    },
  })
}

const builder = createChainable({
  _value: '',
  append(str) {
    this._value += str
  },
  prepend(str) {
    this._value = str + this._value
  },
  getValue() {
    return this._value
  },
})

const result = builder.append('World').prepend('Hello ').append('!').getValue()

console.log(result) // 'Hello World!'
```

### 惰性属性初始化

```javascript
function withLazyInit(target, initializers) {
  return new Proxy(target, {
    get(target, prop, receiver) {
      if (prop in initializers && !(prop in target)) {
        const value = initializers[prop]()
        Reflect.set(target, prop, value, receiver)
      }
      return Reflect.get(target, prop, receiver)
    },
  })
}

const config = withLazyInit(
  {},
  {
    database() {
      console.log('Initializing database connection...')
      return { host: 'localhost', port: 5432 }
    },
    cache() {
      console.log('Initializing cache...')
      return new Map()
    },
  }
)

// 首次访问时初始化
console.log(config.database)
// 'Initializing database connection...'
// { host: 'localhost', port: 5432 }

// 再次访问不会重新初始化
console.log(config.database)
// { host: 'localhost', port: 5432 }
```

## Reflect vs Object 方法对比

| 操作       | Object                                                            | Reflect                              |
| ---------- | ----------------------------------------------------------------- | ------------------------------------ |
| 获取原型   | `Object.getPrototypeOf()`                                         | `Reflect.getPrototypeOf()`           |
| 设置原型   | `Object.setPrototypeOf()`                                         | `Reflect.setPrototypeOf()`           |
| 是否可扩展 | `Object.isExtensible()`                                           | `Reflect.isExtensible()`             |
| 阻止扩展   | `Object.preventExtensions()`                                      | `Reflect.preventExtensions()`        |
| 获取描述符 | `Object.getOwnPropertyDescriptor()`                               | `Reflect.getOwnPropertyDescriptor()` |
| 定义属性   | `Object.defineProperty()`                                         | `Reflect.defineProperty()`           |
| 获取所有键 | `Object.getOwnPropertyNames()` + `Object.getOwnPropertySymbols()` | `Reflect.ownKeys()`                  |

主要区别：

1. Reflect 方法失败时返回 `false`，Object 方法抛出异常
2. Reflect 方法对参数类型检查更严格
3. Reflect 提供了 `get`、`set`、`has`、`deleteProperty` 等函数式 API

---

Reflect 与 Proxy 共同构成了 JavaScript 的元编程基础。Reflect 提供了一套统一的、函数式的对象操作 API，其返回值的设计让错误处理更加优雅。在使用 Proxy 时，通过 Reflect 方法转发操作是推荐的做法，它能确保正确处理 receiver 和继承关系。
