---
title: 数组的扩展
description: 全面掌握 ES6+ 数组新特性，包括扩展运算符、Array.from/of、find/findIndex、flat/flatMap、at 等实用方法及其应用场景
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

数组是 JavaScript 中最常用的数据结构。ES6 及后续版本大幅扩展了数组的能力，从扩展运算符到各种实用方法，让数组操作更加便捷高效。

## 扩展运算符

扩展运算符（spread）`...` 将数组展开为逗号分隔的参数序列。

### 基本用法

```javascript
console.log(...[1, 2, 3]) // 1 2 3
console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5
```

### 函数调用

替代 `apply` 方法传递数组参数：

```javascript
// ES5
Math.max.apply(null, [1, 2, 3]) // 3

// ES6
Math.max(...[1, 2, 3]) // 3

// 多个数组
Math.max(...[1, 2], ...[3, 4], 5) // 5
```

### 数组复制

```javascript
const arr = [1, 2, 3]

// ES5
const copy1 = arr.slice()

// ES6
const copy2 = [...arr]

// 注意：这是浅拷贝
const nested = [
  [1, 2],
  [3, 4],
]
const copyNested = [...nested]
copyNested[0][0] = 999
console.log(nested[0][0]) // 999，原数组也被修改了
```

### 数组合并

```javascript
const arr1 = [1, 2]
const arr2 = [3, 4]
const arr3 = [5, 6]

// ES5
const merged1 = arr1.concat(arr2, arr3)

// ES6
const merged2 = [...arr1, ...arr2, ...arr3]
console.log(merged2) // [1, 2, 3, 4, 5, 6]

// 可以在任意位置插入
const middle = [0, ...arr1, 2.5, ...arr2]
console.log(middle) // [0, 1, 2, 2.5, 3, 4]
```

### 与解构结合

```javascript
const [first, ...rest] = [1, 2, 3, 4, 5]
console.log(first) // 1
console.log(rest) // [2, 3, 4, 5]

const [a, b, ...others] = []
console.log(a) // undefined
console.log(b) // undefined
console.log(others) // []
```

### 字符串转数组

正确处理 Unicode 字符：

```javascript
const str = '𠮷abc'

// ES5 问题
console.log(str.split('')) // ['�', '�', 'a', 'b', 'c']

// ES6 正确
console.log([...str]) // ['𠮷', 'a', 'b', 'c']

// 正确获取字符串长度
console.log([...'𠮷abc'].length) // 4
```

### 将类数组转为数组

```javascript
// NodeList
const divs = document.querySelectorAll('div')
const divArray = [...divs]

// arguments
function foo() {
  const args = [...arguments]
  return args
}

// 具有 Iterator 接口的对象
const set = new Set([1, 2, 3])
const setArray = [...set] // [1, 2, 3]

const map = new Map([
  ['a', 1],
  ['b', 2],
])
const mapArray = [...map] // [['a', 1], ['b', 2]]
```

## Array.from()

将类数组对象或可迭代对象转换为真正的数组。

### 基本用法

```javascript
// 类数组对象（有 length 属性）
const arrayLike = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3,
}

const arr1 = Array.from(arrayLike)
console.log(arr1) // ['a', 'b', 'c']

// DOM 集合
const divs = document.querySelectorAll('div')
const divArray = Array.from(divs)

// 字符串
const chars = Array.from('hello')
console.log(chars) // ['h', 'e', 'l', 'l', 'o']
```

### 映射函数

第二个参数是映射函数，相当于 `map`：

```javascript
const numbers = Array.from([1, 2, 3], (x) => x * 2)
console.log(numbers) // [2, 4, 6]

// 生成序列
const range = Array.from({ length: 5 }, (_, i) => i)
console.log(range) // [0, 1, 2, 3, 4]

// 生成指定范围
function range(start, end) {
  return Array.from({ length: end - start }, (_, i) => start + i)
}
console.log(range(1, 5)) // [1, 2, 3, 4]
```

### 第三个参数：this 绑定

```javascript
const context = {
  multiplier: 3,
}

const result = Array.from(
  [1, 2, 3],
  function (x) {
    return x * this.multiplier
  },
  context
)

console.log(result) // [3, 6, 9]
```

### vs 扩展运算符

```javascript
// 扩展运算符需要对象有 Iterator 接口
const arrayLike = { 0: 'a', 1: 'b', length: 2 }

// [...arrayLike]; // TypeError: arrayLike is not iterable

// Array.from 可以处理类数组
Array.from(arrayLike) // ['a', 'b']
```

## Array.of()

将参数转换为数组，解决 `Array()` 构造函数的歧义问题。

```javascript
// Array() 行为不一致
Array() // []
Array(3) // [empty × 3]，长度为 3 的空数组
Array(1, 2) // [1, 2]

// Array.of() 行为一致
Array.of() // []
Array.of(3) // [3]
Array.of(1, 2) // [1, 2]
Array.of(undefined) // [undefined]
```

## 数组实例的新方法

### find() 和 findIndex()

查找符合条件的元素或索引：

```javascript
const users = [
  { id: 1, name: '张三' },
  { id: 2, name: '李四' },
  { id: 3, name: '王五' },
]

// find：返回第一个符合条件的元素
const user = users.find((u) => u.id === 2)
console.log(user) // { id: 2, name: '李四' }

// findIndex：返回第一个符合条件的索引
const index = users.findIndex((u) => u.id === 2)
console.log(index) // 1

// 找不到返回 undefined / -1
console.log(users.find((u) => u.id === 999)) // undefined
console.log(users.findIndex((u) => u.id === 999)) // -1
```

回调函数接收三个参数：当前元素、当前索引、整个数组。

```javascript
const arr = [1, 2, 3, 4, 5]
arr.find((value, index, array) => {
  console.log(value, index, array)
  return value > 3
})
```

### findLast() 和 findLastIndex()

ES2023 新增，从后往前查找：

```javascript
const arr = [1, 2, 3, 2, 1]

console.log(arr.find((x) => x === 2)) // 2（第一个）
console.log(arr.findLast((x) => x === 2)) // 2（最后一个）

console.log(arr.findIndex((x) => x === 2)) // 1
console.log(arr.findLastIndex((x) => x === 2)) // 3
```

### includes()

判断数组是否包含某个值，返回布尔值：

```javascript
const arr = [1, 2, 3, NaN]

// ES5 的 indexOf 问题
console.log(arr.indexOf(NaN)) // -1，无法找到 NaN

// ES6 includes
console.log(arr.includes(2)) // true
console.log(arr.includes(NaN)) // true，可以正确判断 NaN
console.log(arr.includes(4)) // false

// 第二个参数指定起始位置
console.log([1, 2, 3].includes(1, 1)) // false，从索引 1 开始查找
console.log([1, 2, 3].includes(1, -2)) // false，从倒数第 2 个开始
```

### flat() 和 flatMap()

`flat()` 用于数组扁平化：

```javascript
const nested = [1, [2, [3, [4]]]]

console.log(nested.flat()) // [1, 2, [3, [4]]]，默认展开一层
console.log(nested.flat(2)) // [1, 2, 3, [4]]，展开两层
console.log(nested.flat(Infinity)) // [1, 2, 3, 4]，完全展开

// 会跳过空位
const sparse = [1, , [2, , 3]]
console.log(sparse.flat()) // [1, 2, 3]
```

`flatMap()` 相当于 `map` + `flat(1)`：

```javascript
const arr = [1, 2, 3]

// map 后 flat
const result1 = arr.map((x) => [x, x * 2]).flat()
console.log(result1) // [1, 2, 2, 4, 3, 6]

// flatMap 更简洁
const result2 = arr.flatMap((x) => [x, x * 2])
console.log(result2) // [1, 2, 2, 4, 3, 6]

// 实际应用：分词
const sentences = ['Hello World', 'Good Morning']
const words = sentences.flatMap((s) => s.split(' '))
console.log(words) // ['Hello', 'World', 'Good', 'Morning']
```

### fill()

用指定值填充数组：

```javascript
// 填充整个数组
const arr1 = [1, 2, 3].fill(0)
console.log(arr1) // [0, 0, 0]

// 填充指定范围 [start, end)
const arr2 = [1, 2, 3, 4, 5].fill(0, 1, 3)
console.log(arr2) // [1, 0, 0, 4, 5]

// 创建并初始化数组
const zeros = new Array(5).fill(0)
console.log(zeros) // [0, 0, 0, 0, 0]

// 注意：填充对象是同一个引用
const arr3 = new Array(3).fill({})
arr3[0].name = '张三'
console.log(arr3) // [{name: '张三'}, {name: '张三'}, {name: '张三'}]

// 正确创建独立对象
const arr4 = Array.from({ length: 3 }, () => ({}))
```

### copyWithin()

在数组内部复制元素：

```javascript
// copyWithin(target, start, end)
// 将 [start, end) 复制到 target 位置

const arr1 = [1, 2, 3, 4, 5].copyWithin(0, 3)
console.log(arr1) // [4, 5, 3, 4, 5]

const arr2 = [1, 2, 3, 4, 5].copyWithin(0, 3, 4)
console.log(arr2) // [4, 2, 3, 4, 5]

const arr3 = [1, 2, 3, 4, 5].copyWithin(-2, -3, -1)
console.log(arr3) // [1, 2, 3, 3, 4]
```

### at()

支持负索引的元素访问：

```javascript
const arr = ['a', 'b', 'c', 'd', 'e']

console.log(arr.at(0)) // 'a'
console.log(arr.at(-1)) // 'e'，最后一个
console.log(arr.at(-2)) // 'd'，倒数第二个

// 相比 [] 的优势
console.log(arr[arr.length - 1]) // 'e'，需要计算
console.log(arr.at(-1)) // 'e'，更简洁
```

### toReversed()、toSorted()、toSpliced()、with()

ES2023 新增的不可变方法，返回新数组而不修改原数组：

```javascript
const arr = [3, 1, 4, 1, 5]

// toReversed：reverse 的不可变版本
const reversed = arr.toReversed()
console.log(reversed) // [5, 1, 4, 1, 3]
console.log(arr) // [3, 1, 4, 1, 5]，原数组不变

// toSorted：sort 的不可变版本
const sorted = arr.toSorted((a, b) => a - b)
console.log(sorted) // [1, 1, 3, 4, 5]
console.log(arr) // [3, 1, 4, 1, 5]，原数组不变

// toSpliced：splice 的不可变版本
const spliced = arr.toSpliced(1, 2, 'a', 'b')
console.log(spliced) // [3, 'a', 'b', 1, 5]
console.log(arr) // [3, 1, 4, 1, 5]，原数组不变

// with：替换指定索引的元素
const replaced = arr.with(2, 100)
console.log(replaced) // [3, 1, 100, 1, 5]
console.log(arr) // [3, 1, 4, 1, 5]，原数组不变

// with 支持负索引
const replacedLast = arr.with(-1, 999)
console.log(replacedLast) // [3, 1, 4, 1, 999]
```

### entries()、keys()、values()

用于遍历数组：

```javascript
const arr = ['a', 'b', 'c']

// keys：遍历索引
for (const index of arr.keys()) {
  console.log(index) // 0, 1, 2
}

// values：遍历值
for (const value of arr.values()) {
  console.log(value) // 'a', 'b', 'c'
}

// entries：遍历索引和值
for (const [index, value] of arr.entries()) {
  console.log(index, value) // 0 'a', 1 'b', 2 'c'
}

// 转为数组
console.log([...arr.entries()]) // [[0, 'a'], [1, 'b'], [2, 'c']]
```

## 数组空位处理

ES6 对数组空位的处理变得更加一致，但最好避免创建带空位的数组。

```javascript
// 空位 vs undefined
const sparse = [1, , 3]
const explicit = [1, undefined, 3]

console.log(0 in sparse) // true
console.log(1 in sparse) // false，空位
console.log(1 in explicit) // true，有值

// ES6 方法对空位的处理
console.log([...[1, , 3]]) // [1, undefined, 3]
console.log(Array.from([1, , 3])) // [1, undefined, 3]
console.log([1, , 3].fill(0)) // [0, 0, 0]
console.log([1, , 3].find((x) => x === undefined)) // undefined
console.log([1, , 3].findIndex((x) => x === undefined)) // 1
```

## 实战应用

### 数组去重

```javascript
// 使用 Set
const unique = (arr) => [...new Set(arr)]
console.log(unique([1, 2, 2, 3, 3, 3])) // [1, 2, 3]

// 对象数组去重
const uniqueBy = (arr, key) => {
  const seen = new Set()
  return arr.filter((item) => {
    const k = item[key]
    if (seen.has(k)) return false
    seen.add(k)
    return true
  })
}

const users = [
  { id: 1, name: '张三' },
  { id: 2, name: '李四' },
  { id: 1, name: '张三2' },
]
console.log(uniqueBy(users, 'id'))
// [{ id: 1, name: '张三' }, { id: 2, name: '李四' }]
```

### 数组分组

```javascript
// ES2024 Object.groupBy
const items = [
  { type: 'fruit', name: 'apple' },
  { type: 'fruit', name: 'banana' },
  { type: 'vegetable', name: 'carrot' },
]

const grouped = Object.groupBy(items, (item) => item.type)
console.log(grouped)
// {
//   fruit: [{type: 'fruit', name: 'apple'}, {type: 'fruit', name: 'banana'}],
//   vegetable: [{type: 'vegetable', name: 'carrot'}]
// }

// 兼容写法
function groupBy(arr, keyFn) {
  return arr.reduce((acc, item) => {
    const key = keyFn(item)
    ;(acc[key] ||= []).push(item)
    return acc
  }, {})
}
```

### 数组分块

```javascript
function chunk(arr, size) {
  return Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>
    arr.slice(i * size, i * size + size)
  )
}

console.log(chunk([1, 2, 3, 4, 5], 2))
// [[1, 2], [3, 4], [5]]
```

### 数组交集、并集、差集

```javascript
const arr1 = [1, 2, 3, 4]
const arr2 = [3, 4, 5, 6]

// 并集
const union = [...new Set([...arr1, ...arr2])]
console.log(union) // [1, 2, 3, 4, 5, 6]

// 交集
const intersection = arr1.filter((x) => arr2.includes(x))
console.log(intersection) // [3, 4]

// 差集
const difference = arr1.filter((x) => !arr2.includes(x))
console.log(difference) // [1, 2]
```

### 数组洗牌

```javascript
function shuffle(arr) {
  const result = [...arr]
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1))
    ;[result[i], result[j]] = [result[j], result[i]]
  }
  return result
}

console.log(shuffle([1, 2, 3, 4, 5])) // 随机顺序
```

---

ES6+ 对数组的扩展覆盖了日常开发中的各种需求。扩展运算符和 `Array.from()` 让数组转换更加便捷，`find`、`includes`、`flat` 等方法让数组操作更加直观，ES2023 新增的不可变方法则为函数式编程提供了更好的支持。
