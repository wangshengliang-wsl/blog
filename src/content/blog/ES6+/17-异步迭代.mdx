---
title: 异步迭代器与 for await...of
description: 深入理解 ES2018 异步迭代协议，掌握 for await...of 循环、异步生成器的使用，以及处理流数据的实战技巧
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

ES2018 引入了异步迭代协议，允许异步地遍历数据。`for await...of` 循环可以遍历异步可迭代对象，异步生成器则让创建异步序列变得简单。这些特性对于处理流数据、分页加载等场景非常有用。

## 异步迭代协议

### 同步 vs 异步迭代

同步迭代器的 `next()` 返回 `{ value, done }` 对象，异步迭代器的 `next()` 返回一个 Promise：

```javascript
// 同步迭代器
const syncIterator = {
  [Symbol.iterator]() {
    let i = 0
    return {
      next() {
        return { value: i++, done: i > 3 }
      },
    }
  },
}

// 异步迭代器
const asyncIterator = {
  [Symbol.asyncIterator]() {
    let i = 0
    return {
      async next() {
        await delay(100)
        return { value: i++, done: i > 3 }
      },
    }
  },
}
```

### Symbol.asyncIterator

异步可迭代对象需要实现 `Symbol.asyncIterator` 方法：

```javascript
const asyncIterable = {
  [Symbol.asyncIterator]() {
    let count = 0
    return {
      next() {
        count++
        if (count <= 3) {
          return Promise.resolve({
            value: count,
            done: false,
          })
        }
        return Promise.resolve({
          value: undefined,
          done: true,
        })
      },
    }
  },
}

// 使用 for await...of
async function main() {
  for await (const value of asyncIterable) {
    console.log(value) // 1, 2, 3
  }
}
```

## for await...of 循环

### 基本用法

```javascript
async function processItems(asyncIterable) {
  for await (const item of asyncIterable) {
    console.log(item)
  }
}
```

### 遍历 Promise 数组

`for await...of` 可以遍历 Promise 数组：

```javascript
const promises = [
  Promise.resolve(1),
  new Promise((r) => setTimeout(() => r(2), 100)),
  Promise.resolve(3),
]

async function main() {
  for await (const value of promises) {
    console.log(value) // 1, 2, 3（按顺序，等待每个 Promise）
  }
}
```

对比 `Promise.all`：

```javascript
// for await...of 按顺序等待
async function sequential() {
  for await (const value of promises) {
    console.log(value)
  }
}

// Promise.all 并行等待
async function parallel() {
  const values = await Promise.all(promises)
  for (const value of values) {
    console.log(value)
  }
}
```

### 与普通 for...of 的区别

```javascript
// for...of 只能遍历同步可迭代对象
for (const value of [1, 2, 3]) {
  console.log(value)
}

// for await...of 可以遍历异步可迭代对象
for await (const value of asyncIterable) {
  console.log(value)
}

// for await...of 也可以遍历同步可迭代对象
for await (const value of [1, 2, 3]) {
  console.log(value) // 正常工作
}
```

## 异步生成器

### 基本语法

异步生成器结合了 async 函数和生成器：

```javascript
async function* asyncGenerator() {
  yield 1
  await delay(100)
  yield 2
  await delay(100)
  yield 3
}

async function main() {
  for await (const value of asyncGenerator()) {
    console.log(value) // 1, 2, 3（每个间隔 100ms）
  }
}
```

### yield 和 await

异步生成器中可以同时使用 `yield` 和 `await`：

```javascript
async function* fetchPages() {
  let page = 1
  while (true) {
    const response = await fetch(`/api/data?page=${page}`)
    const data = await response.json()

    if (data.items.length === 0) {
      return
    }

    yield data.items
    page++
  }
}

async function main() {
  for await (const items of fetchPages()) {
    console.log('Received page:', items)
  }
}
```

### 返回 Promise 的 yield

```javascript
async function* asyncGen() {
  yield Promise.resolve(1) // yield Promise
  yield await Promise.resolve(2) // await 后 yield 值
}

async function main() {
  for await (const value of asyncGen()) {
    console.log(value)
  }
}
// 输出：Promise { 1 }, 2
// 注意：第一个 yield 返回的是 Promise 对象本身
// 要获取值需要 yield await
```

### yield\* 与异步生成器

```javascript
async function* gen1() {
  yield 1
  yield 2
}

async function* gen2() {
  yield 'a'
  yield* gen1() // 委托给另一个异步生成器
  yield 'b'
}

async function main() {
  for await (const value of gen2()) {
    console.log(value) // 'a', 1, 2, 'b'
  }
}
```

## 实战应用

### 分页数据加载

```javascript
async function* paginate(fetchFn, pageSize = 10) {
  let page = 1
  let hasMore = true

  while (hasMore) {
    const response = await fetchFn({ page, pageSize })
    const { data, total } = response

    for (const item of data) {
      yield item
    }

    hasMore = page * pageSize < total
    page++
  }
}

// 使用
async function getAllUsers() {
  const users = []
  for await (const user of paginate(fetchUsers)) {
    users.push(user)
    console.log('Loaded user:', user.id)
  }
  return users
}
```

### 流式数据处理

```javascript
// 读取可读流
async function* readStream(stream) {
  const reader = stream.getReader()

  try {
    while (true) {
      const { done, value } = await reader.read()
      if (done) break
      yield value
    }
  } finally {
    reader.releaseLock()
  }
}

// 使用
async function processResponse(response) {
  for await (const chunk of readStream(response.body)) {
    console.log('Received chunk:', chunk)
  }
}
```

### 事件流

```javascript
async function* fromEvent(element, eventName) {
  const queue = []
  let resolve

  const handler = (event) => {
    if (resolve) {
      resolve({ value: event, done: false })
      resolve = null
    } else {
      queue.push(event)
    }
  }

  element.addEventListener(eventName, handler)

  try {
    while (true) {
      if (queue.length > 0) {
        yield queue.shift()
      } else {
        yield await new Promise((r) => (resolve = r)).then((r) => r.value)
      }
    }
  } finally {
    element.removeEventListener(eventName, handler)
  }
}

// 使用
async function main() {
  for await (const event of fromEvent(button, 'click')) {
    console.log('Button clicked:', event)
  }
}
```

### WebSocket 消息

```javascript
async function* websocketMessages(url) {
  const ws = new WebSocket(url)
  const queue = []
  let resolve
  let done = false

  ws.onmessage = (event) => {
    if (resolve) {
      resolve(event.data)
      resolve = null
    } else {
      queue.push(event.data)
    }
  }

  ws.onclose = () => {
    done = true
    if (resolve) resolve()
  }

  await new Promise((r) => (ws.onopen = r))

  try {
    while (!done) {
      if (queue.length > 0) {
        yield queue.shift()
      } else {
        const data = await new Promise((r) => (resolve = r))
        if (data !== undefined) yield data
      }
    }
  } finally {
    ws.close()
  }
}

// 使用
async function main() {
  for await (const message of websocketMessages('ws://example.com')) {
    console.log('Received:', message)
  }
}
```

### 轮询

```javascript
async function* poll(fn, interval) {
  while (true) {
    const result = await fn()
    yield result

    if (result.done) break
    await new Promise((r) => setTimeout(r, interval))
  }
}

// 使用
async function checkStatus() {
  for await (const status of poll(
    () => fetch('/api/status').then((r) => r.json()),
    5000
  )) {
    console.log('Status:', status)
    if (status.complete) break
  }
}
```

### 并发限制的批处理

```javascript
async function* batchProcess(items, batchSize, processor) {
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize)
    const results = await Promise.all(batch.map(processor))
    for (const result of results) {
      yield result
    }
  }
}

// 使用
async function main() {
  const urls = [
    /* 100 个 URL */
  ]

  for await (const data of batchProcess(urls, 10, async (url) => {
    const response = await fetch(url)
    return response.json()
  })) {
    console.log('Processed:', data)
  }
}
```

### 超时处理

```javascript
async function* withTimeout(asyncIterable, timeout) {
  const iterator = asyncIterable[Symbol.asyncIterator]()

  while (true) {
    const result = await Promise.race([
      iterator.next(),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Timeout')), timeout)
      ),
    ])

    if (result.done) break
    yield result.value
  }
}

// 使用
async function main() {
  try {
    for await (const value of withTimeout(asyncGenerator(), 5000)) {
      console.log(value)
    }
  } catch (error) {
    console.log('Iteration timed out')
  }
}
```

### 缓冲区

```javascript
async function* buffer(asyncIterable, size) {
  const buffer = []
  const iterator = asyncIterable[Symbol.asyncIterator]()

  // 预填充缓冲区
  for (let i = 0; i < size; i++) {
    const { done, value } = await iterator.next()
    if (done) break
    buffer.push(value)
  }

  // 边消费边填充
  while (buffer.length > 0) {
    yield buffer.shift()

    const { done, value } = await iterator.next()
    if (!done) {
      buffer.push(value)
    }
  }
}
```

## 错误处理

### try...catch

```javascript
async function main() {
  try {
    for await (const value of asyncGenerator()) {
      console.log(value)
    }
  } catch (error) {
    console.error('Error during iteration:', error)
  }
}
```

### 生成器内部错误处理

```javascript
async function* resilientGenerator(source) {
  const iterator = source[Symbol.asyncIterator]()

  while (true) {
    try {
      const { done, value } = await iterator.next()
      if (done) break
      yield value
    } catch (error) {
      console.error('Error fetching next item:', error)
      yield { error } // 或者跳过继续
    }
  }
}
```

### return 和 throw 方法

```javascript
async function* asyncGen() {
  try {
    yield 1
    yield 2
    yield 3
  } finally {
    console.log('Cleanup')
  }
}

async function main() {
  const gen = asyncGen()

  console.log(await gen.next()) // { value: 1, done: false }
  console.log(await gen.return('ended')) // 'Cleanup', { value: 'ended', done: true }

  // 或者使用 throw
  // await gen.throw(new Error('Stop'));
}
```

## Node.js 中的应用

### 读取文件流

```javascript
import { createReadStream } from 'fs'

async function* readLines(filePath) {
  const stream = createReadStream(filePath, { encoding: 'utf8' })
  let buffer = ''

  for await (const chunk of stream) {
    buffer += chunk
    const lines = buffer.split('\n')
    buffer = lines.pop()

    for (const line of lines) {
      yield line
    }
  }

  if (buffer) {
    yield buffer
  }
}

// 使用
for await (const line of readLines('./large-file.txt')) {
  console.log(line)
}
```

### 数据库游标

```javascript
async function* queryWithCursor(collection, query, batchSize = 100) {
  const cursor = collection.find(query).batchSize(batchSize)

  try {
    while (await cursor.hasNext()) {
      yield await cursor.next()
    }
  } finally {
    await cursor.close()
  }
}

// 使用
for await (const doc of queryWithCursor(usersCollection, { active: true })) {
  console.log('Processing user:', doc._id)
}
```

---

异步迭代器为处理异步数据序列提供了优雅的解决方案。`for await...of` 循环让异步遍历像同步遍历一样简单，异步生成器则提供了创建异步序列的强大能力。在处理流数据、分页加载、事件流等场景中，这些特性能让代码更加清晰和易于维护。
