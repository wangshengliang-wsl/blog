---
title: ES Module 加载机制
description: 深入理解 ES Module 的加载原理，掌握模块解析、循环依赖处理、浏览器与 Node.js 的差异，以及打包工具的模块处理策略
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

ES Module 的加载机制是理解现代 JavaScript 模块化的关键。本文将深入探讨模块的解析、加载、执行过程，以及在浏览器和 Node.js 环境中的差异，帮助你更好地理解和优化模块化代码。

## 模块加载流程

### 三个阶段

ES Module 的加载分为三个阶段：

1. **构建（Construction）**：查找、下载、解析模块文件
2. **实例化（Instantiation）**：在内存中分配空间，建立导入导出的连接
3. **求值（Evaluation）**：执行模块代码，填充变量值

```javascript
// 示例：加载流程
// 1. 构建：解析 import 语句，下载 module.js
// 2. 实例化：创建 count 和 increment 的内存绑定
// 3. 求值：执行 module.js，初始化 count = 0

import { count, increment } from './module.js'
```

### 模块记录（Module Record）

每个模块文件对应一个模块记录，包含：

```javascript
// 模块记录的抽象结构
ModuleRecord = {
  // 请求的模块说明符列表
  RequestedModules: ['./dep1.js', './dep2.js'],

  // 导入条目
  ImportEntries: [
    { ModuleRequest: './dep1.js', ImportName: 'foo', LocalName: 'foo' },
  ],

  // 导出条目
  ExportEntries: [{ ExportName: 'bar', LocalName: 'bar' }],

  // 模块代码
  Code: '...',

  // 模块环境记录
  Environment: {
    /* 变量绑定 */
  },
}
```

### 模块图（Module Graph）

```javascript
// main.js
import { a } from './a.js'
import { b } from './b.js'

// a.js
import { shared } from './shared.js'
export const a = 'a'

// b.js
import { shared } from './shared.js'
export const b = 'b'

// shared.js
export const shared = 'shared'

// 模块图结构：
//       main.js
//        /   \
//     a.js   b.js
//        \   /
//      shared.js
```

## 静态分析

### 编译时确定依赖

ES Module 的 import/export 是静态的，在编译时就能确定依赖关系：

```javascript
// 静态导入（编译时确定）
import { foo } from './module.js'

// 这些都是语法错误：
// import { foo } from getModulePath(); // 不能是表达式
// if (condition) import { foo } from './module.js'; // 不能在块中

// 动态导入是运行时确定
const module = await import(getModulePath()) // 这是允许的
```

### 静态分析的好处

```javascript
// 1. 树摇（Tree Shaking）
// utils.js
export function used() {
  return 'used'
}
export function unused() {
  return 'unused'
}

// main.js
import { used } from './utils.js'
// unused 函数可以在打包时被移除

// 2. 循环依赖检测
// 编译时就能发现潜在的循环依赖问题

// 3. 类型检查
// TypeScript 可以在编译时检查导入导出的类型
```

### import.meta.resolve()

解析模块说明符：

```javascript
// 获取模块的完整 URL
const resolvedPath = import.meta.resolve('./module.js')
console.log(resolvedPath)
// 'file:///path/to/project/module.js' 或
// 'https://example.com/module.js'

// 解析 npm 包
const lodashPath = import.meta.resolve('lodash')
```

## 循环依赖

### 循环依赖的处理

ES Module 支持循环依赖，但需要注意初始化顺序：

```javascript
// a.js
import { b } from './b.js'
console.log('a.js: b =', b)
export const a = 'a'

// b.js
import { a } from './a.js'
console.log('b.js: a =', a)
export const b = 'b'

// main.js
import { a } from './a.js'

// 执行顺序：
// 1. 加载 main.js，发现依赖 a.js
// 2. 加载 a.js，发现依赖 b.js
// 3. 加载 b.js，发现依赖 a.js（已在加载中，跳过）
// 4. 执行 b.js：此时 a 还未初始化，值为 undefined
// 5. 执行 a.js：此时 b 已初始化
// 6. 执行 main.js
```

### 解决循环依赖问题

```javascript
// 方案 1：使用函数包装
// a.js
import { getB } from './b.js'
export const a = 'a'
export function getA() {
  return a
}

console.log('a.js: b =', getB()) // 延迟访问

// b.js
import { getA } from './a.js'
export const b = 'b'
export function getB() {
  return b
}

console.log('b.js: a =', getA())

// 方案 2：重构消除循环
// shared.js
export const shared = 'shared'

// a.js
import { shared } from './shared.js'

// b.js
import { shared } from './shared.js'

// 方案 3：动态导入
// a.js
export const a = 'a'
export async function useB() {
  const { b } = await import('./b.js')
  return b
}
```

### Live Binding 与循环依赖

```javascript
// counter.js
export let count = 0
export function increment() {
  count++
}

// display.js
import { count, increment } from './counter.js'

export function display() {
  console.log('Count:', count)
}

export function update() {
  increment()
  display() // 会看到更新后的值
}

// Live binding 确保导入的值始终是最新的
// 这使得循环依赖中的值更新能够正确传播
```

## 浏览器中的模块加载

### 模块脚本的特性

```html
<!-- 模块脚本 -->
<script type="module" src="app.js"></script>

<!-- 特性：
1. 默认 defer（延迟执行，不阻塞 HTML 解析）
2. 自动严格模式
3. 顶层 this 是 undefined
4. 顶层 await 可用
5. 同一模块只执行一次
6. CORS 限制
-->

<!-- 内联模块 -->
<script type="module">
  import { init } from './app.js'
  init()
</script>

<!-- async 模块（立即执行，不等待 HTML 解析完成） -->
<script type="module" async src="analytics.js"></script>
```

### 模块预加载

```html
<!-- 预加载模块 -->
<link rel="modulepreload" href="./app.js" />
<link rel="modulepreload" href="./utils.js" />

<!-- 预加载依赖图 -->
<link rel="modulepreload" href="./main.js" />
<link rel="modulepreload" href="./dep1.js" />
<link rel="modulepreload" href="./dep2.js" />
```

### Import Maps

Import Maps 允许自定义模块说明符的解析：

```html
<script type="importmap">
  {
    "imports": {
      "lodash": "https://cdn.skypack.dev/lodash",
      "react": "https://cdn.skypack.dev/react",
      "react-dom": "https://cdn.skypack.dev/react-dom",
      "@/": "./src/",
      "#utils/": "./src/utils/"
    },
    "scopes": {
      "/vendor/": {
        "lodash": "./vendor/lodash.js"
      }
    }
  }
</script>

<script type="module">
  // 使用裸模块说明符
  import _ from 'lodash'
  import React from 'react'

  // 使用路径别名
  import { utils } from '@/utils.js'
  import { format } from '#utils/format.js'
</script>
```

### Service Worker 中的模块

```javascript
// sw.js - Service Worker 模块
import { precacheAndRoute } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'

precacheAndRoute(self.__WB_MANIFEST)

// 注册 Service Worker
navigator.serviceWorker.register('/sw.js', {
  type: 'module', // 指定为模块
})
```

## Node.js 中的模块加载

### 确定模块类型

Node.js 通过以下方式确定文件是 ESM 还是 CommonJS：

```javascript
// 1. 文件扩展名
// .mjs → ESM
// .cjs → CommonJS
// .js → 取决于 package.json

// 2. package.json 的 type 字段
{
  "type": "module"  // .js 文件作为 ESM
}

{
  "type": "commonjs"  // 默认，.js 文件作为 CommonJS
}

// 3. --input-type 命令行参数
// node --input-type=module -e "import fs from 'fs'"
```

### 模块解析算法

```javascript
// Node.js 模块解析
import './module.js';     // 相对路径，必须有扩展名
import '/absolute/path.js'; // 绝对路径
import 'package-name';    // npm 包
import '@scope/package';  // 作用域包
import '#internal';       // 子路径导入

// package.json exports 字段
{
  "name": "my-package",
  "exports": {
    ".": "./dist/index.js",
    "./utils": "./dist/utils.js",
    "./internal/*": null  // 禁止访问
  }
}

// 使用
import myPackage from 'my-package';
import utils from 'my-package/utils';
```

### 子路径导入（Subpath Imports）

```json
// package.json
{
  "imports": {
    "#utils/*": "./src/utils/*.js",
    "#components/*": "./src/components/*.js",
    "#config": {
      "development": "./config/dev.js",
      "production": "./config/prod.js"
    }
  }
}
```

```javascript
// 使用子路径导入
import { format } from '#utils/format'
import { Button } from '#components/Button'
import config from '#config'
```

### CommonJS 互操作

```javascript
// 在 ESM 中导入 CommonJS
import cjs from './commonjs-module.cjs'
import { readFile } from 'fs' // Node.js 内置模块

// CommonJS 默认导出作为 ESM 的默认导入
// module.exports = { foo: 1 } → import cjs from './cjs'
// module.exports.foo = 1 → import { foo } from './cjs'

// 在 CommonJS 中导入 ESM（需要动态导入）
// commonjs.cjs
const esmModule = await import('./esm-module.mjs')

// __dirname 和 __filename 的替代
import { fileURLToPath } from 'url'
import { dirname } from 'path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

// 或使用 import.meta
const __dirname = new URL('.', import.meta.url).pathname
```

### 条件导出

```json
// package.json
{
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "require": "./dist/cjs/index.js",
      "types": "./dist/types/index.d.ts"
    },
    "./utils": {
      "import": "./dist/esm/utils.js",
      "require": "./dist/cjs/utils.js"
    }
  }
}
```

## 打包工具的模块处理

### Webpack 模块处理

```javascript
// webpack.config.js
module.exports = {
  resolve: {
    // 模块解析配置
    extensions: ['.js', '.mjs', '.json'],
    alias: {
      '@': path.resolve(__dirname, 'src'),
      '~': path.resolve(__dirname, 'node_modules'),
    },
    mainFields: ['module', 'main'],
  },
  module: {
    rules: [
      {
        test: /\.m?js$/,
        type: 'javascript/auto',
      },
    ],
  },
  optimization: {
    // 代码分割
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
        },
      },
    },
  },
}
```

### Vite 模块处理

```javascript
// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  resolve: {
    alias: {
      '@': '/src',
    },
  },
  build: {
    rollupOptions: {
      output: {
        // 代码分割
        manualChunks: {
          vendor: ['react', 'react-dom'],
          utils: ['lodash', 'date-fns'],
        },
      },
    },
  },
  optimizeDeps: {
    // 预构建依赖
    include: ['lodash-es', 'vue'],
  },
})
```

### 树摇优化

```javascript
// utils.js
export function used() {
  return 'I am used'
}

export function unused() {
  return 'I am not used'
}

// main.js
import { used } from './utils.js'
console.log(used())

// 打包后，unused 函数会被移除

// 确保树摇生效的条件：
// 1. 使用 ES Module 语法
// 2. 包的 package.json 设置 "sideEffects": false
// 3. 避免导入有副作用的代码
```

### 代码分割

```javascript
// 路由级别的代码分割
const routes = [
  {
    path: '/',
    component: () => import('./pages/Home.js'),
  },
  {
    path: '/about',
    component: () => import('./pages/About.js'),
  },
]

// 组件级别的代码分割
const HeavyComponent = React.lazy(() => import('./HeavyComponent'))

// 显式命名 chunk
import(/* webpackChunkName: "charts" */ './charts/LineChart.js')

// Vite 中的分割
const module = await import('./module.js?split')
```

## 性能优化

### 模块预加载策略

```javascript
// 预测性预加载
function setupRoutePreloading() {
  document.addEventListener('mouseover', (e) => {
    const link = e.target.closest('a')
    if (link && link.href.startsWith(location.origin)) {
      const route = new URL(link.href).pathname
      preloadRoute(route)
    }
  })
}

// 预加载路由模块
const preloadedRoutes = new Set()

function preloadRoute(route) {
  if (preloadedRoutes.has(route)) return
  preloadedRoutes.add(route)

  const routeConfig = routes.find((r) => r.path === route)
  if (routeConfig?.component) {
    // 触发动态导入预加载
    routeConfig.component()
  }
}
```

### 模块加载优先级

```html
<!-- 关键模块：立即加载 -->
<link rel="modulepreload" href="/src/critical.js" fetchpriority="high" />

<!-- 非关键模块：空闲时加载 -->
<script type="module">
  requestIdleCallback(() => {
    import('./non-critical.js')
  })
</script>

<!-- 可见时加载 -->
<script type="module">
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        import('./lazy-component.js')
        observer.disconnect()
      }
    })
  })
  observer.observe(document.querySelector('#lazy-section'))
</script>
```

### 减少模块数量

```javascript
// 不推荐：大量小模块
// utils/add.js
export const add = (a, b) => a + b

// utils/subtract.js
export const subtract = (a, b) => a - b

// 推荐：合理聚合
// utils/math.js
export const add = (a, b) => a + b
export const subtract = (a, b) => a - b
export const multiply = (a, b) => a * b
export const divide = (a, b) => a / b

// 使用 barrel 文件聚合导出
// components/index.js
export { Button } from './Button'
export { Modal } from './Modal'
export { Form } from './Form'
```

### 缓存策略

```javascript
// 使用内容哈希命名
// webpack.config.js
output: {
  filename: '[name].[contenthash].js',
  chunkFilename: '[name].[contenthash].js'
}

// vite.config.js
build: {
  rollupOptions: {
    output: {
      entryFileNames: '[name].[hash].js',
      chunkFileNames: '[name].[hash].js'
    }
  }
}

// 长期缓存分离
// - vendor.js（第三方库，很少变化）
// - app.js（应用代码，经常变化）
```

## 调试模块

### Source Maps

```javascript
// webpack.config.js
devtool: 'source-map',  // 生产环境
devtool: 'eval-source-map',  // 开发环境

// vite.config.js
build: {
  sourcemap: true
}
```

### 模块加载日志

```javascript
// 监控模块加载
const originalImport = window.import
window.import = function (specifier) {
  console.log('Loading module:', specifier)
  const startTime = performance.now()

  return originalImport.call(this, specifier).then((module) => {
    console.log(`Loaded ${specifier} in ${performance.now() - startTime}ms`)
    return module
  })
}

// 或使用 Performance API
performance
  .getEntriesByType('resource')
  .filter((entry) => entry.initiatorType === 'script')
  .forEach((entry) => {
    console.log(entry.name, entry.duration)
  })
```

### 浏览器开发者工具

```javascript
// Sources 面板：
// - 查看模块依赖图
// - 设置模块断点
// - 查看模块作用域

// Network 面板：
// - 查看模块加载顺序
// - 分析模块大小
// - 检查缓存状态

// Performance 面板：
// - 模块评估时间
// - 主线程阻塞
```

## 未来发展

### Module Declarations

```javascript
// 提案：内联模块声明
module myModule {
  export const x = 1;
  export function foo() {}
}

import { x, foo } from myModule;
```

### Import Assertions

```javascript
// JSON 导入
import config from './config.json' with { type: 'json' }

// CSS 导入
import styles from './styles.css' with { type: 'css' }
document.adoptedStyleSheets = [...document.adoptedStyleSheets, styles]

// WebAssembly 导入
import wasmModule from './module.wasm' with { type: 'webassembly' }
```

### Module Fragments

```javascript
// 提案：模块片段
import { foo } from './module.js#fragment';

// module.js
export fragment { foo } from './internal/foo.js';
```

---

理解 ES Module 的加载机制对于编写高效、可维护的 JavaScript 代码至关重要。从静态分析到动态导入，从浏览器环境到 Node.js 环境，模块系统的各个方面都影响着应用的性能和开发体验。掌握这些知识，能够帮助你更好地组织代码结构，优化加载性能，并解决各种模块化相关的问题。
