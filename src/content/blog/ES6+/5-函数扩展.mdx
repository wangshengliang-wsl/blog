---
title: 函数的扩展
description: 深入掌握 ES6+ 函数新特性，包括默认参数、rest 参数、箭头函数、尾调用优化，以及函数的 name 属性和各种实战技巧
pubDate: 2025-11-27
toc: true
ogImage: true
category: ES6+
---

函数是 JavaScript 的一等公民，ES6 对函数进行了全方位增强。默认参数让接口设计更清晰，rest 参数取代了 arguments，箭头函数不仅语法简洁还改变了 this 绑定规则。

## 默认参数

### 基本用法

ES6 之前，参数默认值需要在函数体内判断：

```javascript
// ES5 写法
function greet(name) {
  name = name || '朋友'
  console.log('你好，' + name)
}

// 问题：空字符串、0、false 也会触发默认值
greet('') // '你好，朋友'（非预期）
greet(0) // '你好，朋友'（非预期）
```

ES6 允许直接在参数列表设置默认值：

```javascript
function greet(name = '朋友') {
  console.log(`你好，${name}`)
}

greet() // '你好，朋友'
greet('张三') // '你好，张三'
greet('') // '你好，'（空字符串正常传入）
greet(undefined) // '你好，朋友'（只有 undefined 触发默认值）
greet(null) // '你好，null'（null 不触发默认值）
```

### 默认值表达式

默认值可以是任意表达式，且惰性求值：

```javascript
let counter = 0

function getDefault() {
  counter++
  return counter
}

function foo(x = getDefault()) {
  console.log(x)
}

foo(10) // 10，不调用 getDefault
foo() // 1
foo() // 2
```

### 默认值与解构结合

```javascript
function fetchData({ url, method = 'GET', headers = {} } = {}) {
  console.log(url, method, headers)
}

fetchData({ url: '/api/users' })
// '/api/users', 'GET', {}

fetchData()
// undefined, 'GET', {}
```

注意两种写法的区别：

```javascript
// 写法一：解构有默认值
function f1({ x = 0, y = 0 } = {}) {
  console.log(x, y)
}

// 写法二：参数有默认值，解构无默认值
function f2({ x, y } = { x: 0, y: 0 }) {
  console.log(x, y)
}

f1() // 0, 0
f2() // 0, 0

f1({ x: 3, y: 8 }) // 3, 8
f2({ x: 3, y: 8 }) // 3, 8

f1({ x: 3 }) // 3, 0
f2({ x: 3 }) // 3, undefined

f1({}) // 0, 0
f2({}) // undefined, undefined
```

第一种写法更健壮，推荐使用。

### 参数作用域

设置默认值后，参数初始化时会形成一个单独的作用域：

```javascript
let x = 1

function foo(x, y = x) {
  console.log(y)
}

foo(2) // 2，y 取参数 x 的值，不是外层的 x

// 更复杂的例子
function bar(x = y, y = 2) {
  console.log(x, y)
}

bar() // ReferenceError: Cannot access 'y' before initialization
```

### 参数的 length 属性

函数的 `length` 属性返回没有默认值的参数个数：

```javascript
console.log(function (a) {}.length) // 1
console.log(function (a = 1) {}.length) // 0
console.log(function (a, b = 2, c) {}.length) // 1（只计算 b 之前的）

// rest 参数不计入
console.log(function (a, ...args) {}.length) // 1
```

## rest 参数

rest 参数用 `...变量名` 表示，将多余的参数收集成数组，取代了 `arguments`。

### 基本用法

```javascript
function sum(...numbers) {
  return numbers.reduce((total, n) => total + n, 0)
}

console.log(sum(1, 2, 3)) // 6
console.log(sum(1, 2, 3, 4, 5)) // 15
```

### 与普通参数结合

```javascript
function push(array, ...items) {
  items.forEach((item) => array.push(item))
  return array
}

const arr = [1, 2]
console.log(push(arr, 3, 4, 5)) // [1, 2, 3, 4, 5]
```

### rest vs arguments

```javascript
// ES5 的 arguments
function oldSum() {
  // arguments 是类数组，不是真正的数组
  var args = Array.prototype.slice.call(arguments)
  return args.reduce(function (a, b) {
    return a + b
  }, 0)
}

// ES6 的 rest 参数
function newSum(...args) {
  // args 是真正的数组
  return args.reduce((a, b) => a + b, 0)
}
```

注意事项：

- rest 参数必须是最后一个参数
- 函数的 `length` 属性不包括 rest 参数
- 箭头函数没有 `arguments`，只能用 rest 参数

```javascript
// 错误：rest 参数后面不能有其他参数
function f(a, ...rest, b) {} // SyntaxError
```

## 箭头函数

箭头函数是 ES6 最常用的新特性之一。

### 基本语法

```javascript
// 传统函数
const add1 = function (a, b) {
  return a + b
}

// 箭头函数
const add2 = (a, b) => {
  return a + b
}

// 简写：单个表达式可省略大括号和 return
const add3 = (a, b) => a + b

// 单个参数可省略括号
const double = (n) => n * 2

// 无参数必须有括号
const random = () => Math.random()
```

返回对象字面量需要加括号：

```javascript
const createUser = (name, age) => ({ name, age })
console.log(createUser('张三', 25)) // { name: '张三', age: 25 }

// 不加括号会被解析为函数体
const wrong = () => {
  name: '张三'
} // 返回 undefined
```

### this 绑定

箭头函数最重要的特性是 **没有自己的 this**，而是继承定义时所在上下文的 this：

```javascript
// 传统函数：this 由调用方式决定
const obj1 = {
  name: '张三',
  greet: function () {
    setTimeout(function () {
      console.log(`你好，${this.name}`)
    }, 100)
  },
}
obj1.greet() // '你好，undefined'（this 指向全局）

// 箭头函数：this 继承外层
const obj2 = {
  name: '张三',
  greet: function () {
    setTimeout(() => {
      console.log(`你好，${this.name}`)
    }, 100)
  },
}
obj2.greet() // '你好，张三'
```

这使得箭头函数非常适合用在回调中：

```javascript
class Counter {
  constructor() {
    this.count = 0
  }

  start() {
    // 箭头函数继承 start 方法的 this
    setInterval(() => {
      this.count++
      console.log(this.count)
    }, 1000)
  }
}
```

### 没有 arguments

箭头函数没有自己的 `arguments` 对象，但可以使用 rest 参数：

```javascript
// 传统函数
function foo() {
  console.log(arguments)
}
foo(1, 2, 3) // [1, 2, 3]

// 箭头函数
const bar = () => {
  console.log(arguments) // ReferenceError: arguments is not defined
}

// 使用 rest 参数
const baz = (...args) => {
  console.log(args) // [1, 2, 3]
}
baz(1, 2, 3)
```

### 不能作为构造函数

箭头函数不能用 `new` 调用：

```javascript
const Foo = () => {}
new Foo() // TypeError: Foo is not a constructor
```

### 不能用作 Generator

箭头函数不能使用 `yield` 关键字：

```javascript
const gen = () => {
  yield 1; // SyntaxError
};
```

### 不适用的场景

**对象方法**：需要访问对象自身时不适合用箭头函数：

```javascript
// 错误：this 不指向 obj
const obj = {
  name: '张三',
  greet: () => {
    console.log(`你好，${this.name}`)
  },
}
obj.greet() // '你好，undefined'

// 正确：使用普通函数或简写
const obj2 = {
  name: '张三',
  greet() {
    console.log(`你好，${this.name}`)
  },
}
obj2.greet() // '你好，张三'
```

**原型方法**：同样的原因：

```javascript
function Cat(name) {
  this.name = name
}

// 错误
Cat.prototype.meow = () => {
  console.log(`${this.name} says meow`)
}

// 正确
Cat.prototype.meow = function () {
  console.log(`${this.name} says meow`)
}
```

**事件处理器**（需要访问事件目标时）：

```javascript
// 错误：this 不指向按钮
button.addEventListener('click', () => {
  console.log(this) // window
})

// 正确：使用普通函数
button.addEventListener('click', function () {
  console.log(this) // button 元素
})

// 或者通过 event 参数
button.addEventListener('click', (event) => {
  console.log(event.target) // button 元素
})
```

## 尾调用优化

尾调用是指函数的最后一步调用另一个函数。

### 什么是尾调用

```javascript
// 是尾调用
function f(x) {
  return g(x)
}

// 不是尾调用：有后续操作
function f(x) {
  return g(x) + 1
}

// 不是尾调用：没有 return
function f(x) {
  g(x)
}

// 不是尾调用：赋值操作
function f(x) {
  let y = g(x)
  return y
}
```

### 尾递归

ES6 规范要求在严格模式下对尾调用进行优化，避免栈溢出：

```javascript
// 普通递归：可能栈溢出
function factorial(n) {
  if (n === 1) return 1
  return n * factorial(n - 1)
}

// 尾递归优化
function factorial(n, total = 1) {
  if (n === 1) return total
  return factorial(n - 1, n * total)
}

// 斐波那契数列
function fibonacci(n, prev = 0, current = 1) {
  if (n === 0) return prev
  if (n === 1) return current
  return fibonacci(n - 1, current, prev + current)
}
```

注意：目前只有 Safari 实现了尾调用优化，V8/Node.js 出于各种原因未实现。在实践中，可以用循环代替递归避免栈溢出。

### 蹦床函数

一种模拟尾调用优化的技术：

```javascript
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f()
  }
  return f
}

function factorial(n, total = 1) {
  if (n === 1) return total
  return () => factorial(n - 1, n * total)
}

console.log(trampoline(factorial(100000))) // 不会栈溢出
```

## 函数的 name 属性

函数的 `name` 属性返回函数名：

```javascript
function foo() {}
console.log(foo.name) // 'foo'

const bar = function () {}
console.log(bar.name) // 'bar'（ES6 行为，ES5 返回空字符串）

const baz = function qux() {}
console.log(baz.name) // 'qux'
```

特殊情况：

```javascript
// bind 返回的函数
console.log(foo.bind({}).name) // 'bound foo'

// 构造函数
console.log(new Function().name) // 'anonymous'

// getter/setter
const obj = {
  get prop() {},
  set prop(val) {},
}
const descriptor = Object.getOwnPropertyDescriptor(obj, 'prop')
console.log(descriptor.get.name) // 'get prop'
console.log(descriptor.set.name) // 'set prop'

// Symbol 作为函数名
const sym = Symbol('description')
const obj2 = {
  [sym]() {},
}
console.log(obj2[sym].name) // '[description]'
```

## 实战应用

### 函数柯里化

```javascript
const curry = (fn) => {
  const arity = fn.length
  return function curried(...args) {
    if (args.length >= arity) {
      return fn.apply(this, args)
    }
    return (...moreArgs) => curried.apply(this, [...args, ...moreArgs])
  }
}

const add = (a, b, c) => a + b + c
const curriedAdd = curry(add)

console.log(curriedAdd(1)(2)(3)) // 6
console.log(curriedAdd(1, 2)(3)) // 6
console.log(curriedAdd(1)(2, 3)) // 6
console.log(curriedAdd(1, 2, 3)) // 6
```

### 函数组合

```javascript
const compose = (...fns) =>
  fns.reduce(
    (f, g) =>
      (...args) =>
        f(g(...args))
  )

const pipe = (...fns) =>
  fns.reduce(
    (f, g) =>
      (...args) =>
        g(f(...args))
  )

const add10 = (x) => x + 10
const multiply2 = (x) => x * 2
const subtract5 = (x) => x - 5

const composed = compose(subtract5, multiply2, add10)
console.log(composed(5)) // ((5 + 10) * 2) - 5 = 25

const piped = pipe(add10, multiply2, subtract5)
console.log(piped(5)) // ((5 + 10) * 2) - 5 = 25
```

### 防抖和节流

```javascript
// 防抖：连续触发只执行最后一次
function debounce(fn, delay = 300) {
  let timer = null
  return function (...args) {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 节流：一段时间内只执行一次
function throttle(fn, interval = 300) {
  let lastTime = 0
  return function (...args) {
    const now = Date.now()
    if (now - lastTime >= interval) {
      lastTime = now
      fn.apply(this, args)
    }
  }
}

// 使用
const handleScroll = debounce(() => {
  console.log('scrolled')
}, 200)

const handleResize = throttle(() => {
  console.log('resized')
}, 100)
```

### 函数重载模拟

```javascript
function createOverload() {
  const fnMap = new Map()

  function overloaded(...args) {
    const key = args.map((arg) => typeof arg).join(',')
    const fn = fnMap.get(key) || fnMap.get('default')
    if (fn) {
      return fn.apply(this, args)
    }
    throw new Error(`No overload found for signature: ${key}`)
  }

  overloaded.addImpl = function (types, fn) {
    fnMap.set(types, fn)
    return overloaded
  }

  return overloaded
}

const calculate = createOverload()
  .addImpl('number,number', (a, b) => a + b)
  .addImpl('string,string', (a, b) => `${a} ${b}`)
  .addImpl('number', (a) => a * a)

console.log(calculate(1, 2)) // 3
console.log(calculate('hello', 'world')) // 'hello world'
console.log(calculate(5)) // 25
```

---

ES6 的函数扩展让 JavaScript 的函数式编程更加便利。默认参数和 rest 参数简化了函数签名设计，箭头函数解决了 this 绑定的历史难题，为后续的框架和库设计奠定了基础。理解这些特性对于写出现代 JavaScript 代码至关重要。
