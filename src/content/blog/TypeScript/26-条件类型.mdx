---
title: 'æ¡ä»¶ç±»å‹'
description: 'TypeScript æ¡ä»¶ç±»å‹è¯¦è§£ï¼šæ¡ä»¶è¡¨è¾¾å¼ã€åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹ã€ç±»å‹æ¨æ–­ä¸æ¡ä»¶ç±»å‹ç»“åˆ'
pubDate: 2024-02-09
toc: true
ogImage: true
category: 'TypeScript'
tags: ['TypeScript', 'æ¡ä»¶ç±»å‹', 'Conditional Types', 'ç±»å‹æ¨æ–­', 'é«˜çº§ç±»å‹']
---

æ¡ä»¶ç±»å‹ï¼ˆConditional Typesï¼‰å…è®¸æ ¹æ®ç±»å‹å…³ç³»é€‰æ‹©ä¸åŒçš„ç±»å‹ï¼Œç±»ä¼¼äºç±»å‹çº§åˆ«çš„ if-else è¯­å¥ã€‚

## åŸºæœ¬è¯­æ³•

æ¡ä»¶ç±»å‹ä½¿ç”¨ `extends` å…³é”®å­—åˆ¤æ–­ç±»å‹å…³ç³»ï¼š

```typescript
// TypeScript 5.x

// åŸºæœ¬è¯­æ³•ï¼šT extends U ? X : Y
type IsString<T> = T extends string ? true : false

type A = IsString<string> // true
type B = IsString<number> // false
type C = IsString<'hello'> // true

// å®é™…åº”ç”¨
type NonNullable<T> = T extends null | undefined ? never : T

type D = NonNullable<string | null> // string
type E = NonNullable<number | undefined> // number
type F = NonNullable<null> // never

// åµŒå¥—æ¡ä»¶
type TypeName<T> = T extends string
  ? 'string'
  : T extends number
    ? 'number'
    : T extends boolean
      ? 'boolean'
      : T extends undefined
        ? 'undefined'
        : T extends Function
          ? 'function'
          : 'object'

type T1 = TypeName<string> // 'string'
type T2 = TypeName<number[]> // 'object'
type T3 = TypeName<() => void> // 'function'
```

## åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹

å½“æ¡ä»¶ç±»å‹ä½œç”¨äºè”åˆç±»å‹æ—¶ï¼Œä¼šè‡ªåŠ¨åˆ†é…åˆ°æ¯ä¸ªæˆå‘˜ï¼š

```typescript
// åˆ†å¸ƒå¼æ¡ä»¶ç±»å‹
type ToArray<T> = T extends any ? T[] : never

type StrArr = ToArray<string> // string[]
type NumArr = ToArray<number> // number[]

// è”åˆç±»å‹ä¼šè¢«åˆ†é…
type Mixed = ToArray<string | number>
// string[] | number[]ï¼ˆä¸æ˜¯ (string | number)[]ï¼‰

// è¿‡æ»¤è”åˆç±»å‹
type Filter<T, U> = T extends U ? T : never

type OnlyStrings = Filter<string | number | boolean, string>
// string

type OnlyNumbers = Filter<string | number | boolean, number>
// number

// æ’é™¤ç±»å‹
type MyExclude<T, U> = T extends U ? never : T

type WithoutString = MyExclude<string | number | boolean, string>
// number | boolean

// æå–ç±»å‹
type MyExtract<T, U> = T extends U ? T : never

type OnlyStringOrNumber = MyExtract<string | number | boolean, string | number>
// string | number
```

## ç¦ç”¨åˆ†å¸ƒå¼è¡Œä¸º

ä½¿ç”¨å…ƒç»„åŒ…è£…ç±»å‹å‚æ•°å¯ä»¥ç¦ç”¨åˆ†å¸ƒå¼è¡Œä¸ºï¼š

```typescript
// åˆ†å¸ƒå¼ï¼ˆé»˜è®¤ï¼‰
type Distributed<T> = T extends any ? T[] : never
type D1 = Distributed<string | number> // string[] | number[]

// éåˆ†å¸ƒå¼
type NonDistributed<T> = [T] extends [any] ? T[] : never
type D2 = NonDistributed<string | number> // (string | number)[]

// æ£€æŸ¥è”åˆç±»å‹
type IsUnion<T> = [T] extends [UnionToIntersection<T>] ? false : true

type Check1 = IsUnion<string> // false
type Check2 = IsUnion<string | number> // true

// è¾…åŠ©ç±»å‹
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I
) => void
  ? I
  : never
```

## æ¡ä»¶ç±»å‹çº¦æŸ

åœ¨æ¡ä»¶åˆ†æ”¯ä¸­ä½¿ç”¨ç±»å‹çº¦æŸï¼š

```typescript
// çº¦æŸ T å¿…é¡»æœ‰ length å±æ€§
type GetLength<T> = T extends { length: infer L } ? L : never

type StrLength = GetLength<string> // number
type ArrLength = GetLength<number[]> // number
type NoLength = GetLength<number> // never

// çº¦æŸ T å¿…é¡»æ˜¯å‡½æ•°
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never

type FnReturn = GetReturnType<() => string> // string
type NotFn = GetReturnType<string> // never

// å¤šå±‚çº¦æŸ
type DeepValue<T, K extends string> = K extends keyof T
  ? T[K]
  : K extends `${infer First}.${infer Rest}`
    ? First extends keyof T
      ? DeepValue<T[First], Rest>
      : never
    : never
```

## å®ç”¨æ¡ä»¶ç±»å‹

```typescript
// æ£€æŸ¥ç±»å‹ç›¸ç­‰
type Equals<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false

type E1 = Equals<string, string> // true
type E2 = Equals<string, number> // false
type E3 = Equals<{ a: 1 }, { a: 1 }> // true

// æ£€æŸ¥æ˜¯å¦ä¸º any
type IsAny<T> = 0 extends 1 & T ? true : false

type A1 = IsAny<any> // true
type A2 = IsAny<unknown> // false
type A3 = IsAny<string> // false

// æ£€æŸ¥æ˜¯å¦ä¸º never
type IsNever<T> = [T] extends [never] ? true : false

type N1 = IsNever<never> // true
type N2 = IsNever<string> // false

// æ£€æŸ¥æ˜¯å¦ä¸ºæ•°ç»„
type IsArray<T> = T extends any[] ? true : false

type Arr1 = IsArray<string[]> // true
type Arr2 = IsArray<string> // false

// æ£€æŸ¥æ˜¯å¦ä¸ºå…ƒç»„
type IsTuple<T> = T extends readonly any[]
  ? number extends T['length']
    ? false
    : true
  : false

type Tup1 = IsTuple<[string, number]> // true
type Tup2 = IsTuple<string[]> // false
```

## æ¡ä»¶ç±»å‹ä¸æ³›å‹

```typescript
// æ ¹æ®ç±»å‹é€‰æ‹©è¡Œä¸º
type Flatten<T> = T extends any[] ? T[number] : T

type Flat1 = Flatten<string[]> // string
type Flat2 = Flatten<string> // string
type Flat3 = Flatten<number[][]> // number[]

// æ·±åº¦å±•å¹³
type DeepFlatten<T> = T extends any[] ? DeepFlatten<T[number]> : T

type Deep1 = DeepFlatten<string[][][]> // string
type Deep2 = DeepFlatten<number> // number

// æ¡ä»¶é»˜è®¤å€¼
type WithDefault<T, D> = T extends undefined | null ? D : T

type WD1 = WithDefault<string, 'default'> // string
type WD2 = WithDefault<undefined, 'default'> // 'default'

// å¯é€‰å±æ€§æ£€æµ‹
type OptionalKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? K : never
}[keyof T]

interface Example {
  required: string
  optional?: number
  alsoOptional?: boolean
}

type OptKeys = OptionalKeys<Example>
// 'optional' | 'alsoOptional'
```

## å®é™…åº”ç”¨

### Promise è§£åŒ…

```typescript
// è§£åŒ… Promise
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T

type P1 = UnwrapPromise<Promise<string>> // string
type P2 = UnwrapPromise<string> // string

// æ·±åº¦è§£åŒ…
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T

type A1 = Awaited<Promise<Promise<string>>> // string
type A2 = Awaited<Promise<number>> // number

// å‡½æ•°è¿”å›å€¼è§£åŒ…
type UnwrapReturnType<T extends (...args: any[]) => any> = Awaited<
  ReturnType<T>
>

async function fetchUser() {
  return { id: 1, name: 'å¼ ä¸‰' }
}

type User = UnwrapReturnType<typeof fetchUser>
// { id: number; name: string }
```

### äº‹ä»¶å¤„ç†

```typescript
type EventType = 'click' | 'focus' | 'blur'

type EventPayload<T extends EventType> = T extends 'click'
  ? { x: number; y: number }
  : T extends 'focus'
    ? { target: HTMLElement }
    : T extends 'blur'
      ? { relatedTarget: HTMLElement | null }
      : never

function handleEvent<T extends EventType>(type: T, payload: EventPayload<T>) {
  switch (type) {
    case 'click':
      const clickPayload = payload as EventPayload<'click'>
      console.log(clickPayload.x, clickPayload.y)
      break
    case 'focus':
      const focusPayload = payload as EventPayload<'focus'>
      console.log(focusPayload.target)
      break
  }
}

handleEvent('click', { x: 100, y: 200 })
handleEvent('focus', { target: document.body })
```

### è·¯ç”±å‚æ•°

```typescript
type ExtractParams<T extends string> =
  T extends `${string}:${infer Param}/${infer Rest}`
    ? Param | ExtractParams<Rest>
    : T extends `${string}:${infer Param}`
      ? Param
      : never

type Params1 = ExtractParams<'/users/:id'>
// 'id'

type Params2 = ExtractParams<'/posts/:postId/comments/:commentId'>
// 'postId' | 'commentId'

// æ„å»ºå‚æ•°å¯¹è±¡
type RouteParams<T extends string> = {
  [K in ExtractParams<T>]: string
}

type UserParams = RouteParams<'/users/:id'>
// { id: string }

type PostParams = RouteParams<'/posts/:postId/comments/:commentId'>
// { postId: string; commentId: string }
```

### API å“åº”ç±»å‹

```typescript
type ApiResponse<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E }

type ExtractData<T> = T extends { success: true; data: infer D } ? D : never

type ExtractError<T> = T extends { success: false; error: infer E } ? E : never

type Response = ApiResponse<{ id: number; name: string }>

type Data = ExtractData<Response>
// { id: number; name: string }

type Err = ExtractError<Response>
// Error

// å¤„ç†å‡½æ•°
async function handleResponse<T>(response: ApiResponse<T>): Promise<T> {
  if (response.success) {
    return response.data
  }
  throw response.error
}
```

### å‡½æ•°é‡è½½é€‰æ‹©

```typescript
type Overload<T, U> = T extends string
  ? (value: T) => string
  : T extends number
    ? (value: T) => number
    : (value: T) => U

function process(value: string): string
function process(value: number): number
function process(value: any): any {
  return value
}

// ç±»å‹æ¨æ–­
type ProcessString = Overload<string, never> // (value: string) => string
type ProcessNumber = Overload<number, never> // (value: number) => number
```

## å¸¸è§é—®é¢˜

### ğŸ™‹ æ¡ä»¶ç±»å‹å¯ä»¥é€’å½’å—ï¼Ÿ

```typescript
// TypeScript æ”¯æŒæ¡ä»¶ç±»å‹é€’å½’
type Reverse<T extends any[]> = T extends [infer First, ...infer Rest]
  ? [...Reverse<Rest>, First]
  : []

type Reversed = Reverse<[1, 2, 3]>
// [3, 2, 1]

// æ³¨æ„ï¼šè¿‡æ·±çš„é€’å½’ä¼šå¯¼è‡´é”™è¯¯
// TypeScript æœ‰é€’å½’æ·±åº¦é™åˆ¶
```

### ğŸ™‹ ä¸ºä»€ä¹ˆæ¡ä»¶ç±»å‹ç»“æœæ˜¯ neverï¼Ÿ

```typescript
type Result<T> = T extends string ? T : never

// never å‡ºç°çš„æƒ…å†µï¼š
type R1 = Result<number> // neverï¼ˆæ¡ä»¶ä¸æ»¡è¶³ï¼‰
type R2 = Result<never> // neverï¼ˆnever æ˜¯ç©ºè”åˆç±»å‹ï¼‰

// è”åˆç±»å‹åˆ†é…åå…¨æ˜¯ never
type R3 = Result<number | boolean>
// neverï¼ˆä¸¤ä¸ªåˆ†æ”¯éƒ½æ˜¯ neverï¼Œåˆå¹¶åè¿˜æ˜¯ neverï¼‰
```

### ğŸ™‹ å¦‚ä½•è°ƒè¯•æ¡ä»¶ç±»å‹ï¼Ÿ

```typescript
// ä½¿ç”¨è¾…åŠ©ç±»å‹å±•å¼€
type Debug<T> = { [K in keyof T]: T[K] }

type Complex<T> = T extends object ? { [K in keyof T]: Complex<T[K]> } : T

// å…·ä½“åŒ–æŸ¥çœ‹
type Test = Debug<Complex<{ a: { b: string } }>>
// æ‚¬åœæŸ¥çœ‹å±•å¼€åçš„ç±»å‹
```

## æ€»ç»“

| ç‰¹æ€§       | è¯­æ³•                  | ç”¨é€”                   |
| ---------- | --------------------- | ---------------------- |
| æ¡ä»¶è¡¨è¾¾å¼ | `T extends U ? X : Y` | ç±»å‹çº§åˆ«çš„ if-else     |
| åˆ†å¸ƒå¼æ¡ä»¶ | è”åˆç±»å‹è‡ªåŠ¨åˆ†é…      | å¯¹æ¯ä¸ªè”åˆæˆå‘˜åº”ç”¨æ¡ä»¶ |
| ç¦ç”¨åˆ†å¸ƒ   | `[T] extends [U]`     | é˜²æ­¢è”åˆç±»å‹åˆ†é…       |
| ç±»å‹æ¨æ–­   | `infer R`             | åœ¨æ¡ä»¶ä¸­æå–ç±»å‹       |
| åµŒå¥—æ¡ä»¶   | å¤šå±‚ `? :`            | å¤šæ¡ä»¶åˆ¤æ–­             |

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†å­¦ä¹  infer å…³é”®å­—ï¼Œæ·±å…¥äº†è§£æ¡ä»¶ç±»å‹ä¸­çš„ç±»å‹æ¨æ–­ã€‚
