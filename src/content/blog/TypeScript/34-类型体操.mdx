---
title: 'ç±»å‹ä½“æ“å…¥é—¨'
description: 'TypeScript ç±»å‹ä½“æ“å…¥é—¨ï¼šé€’å½’ç±»å‹ã€ç±»å‹ç¼–ç¨‹æŠ€å·§ã€å¸¸è§ç±»å‹æŒ‘æˆ˜è§£æ'
pubDate: 2024-02-17
toc: true
ogImage: true
category: 'TypeScript'
tags: ['TypeScript', 'ç±»å‹ä½“æ“', 'ç±»å‹ç¼–ç¨‹', 'é€’å½’ç±»å‹', 'é«˜çº§ç±»å‹']
---

ç±»å‹ä½“æ“ï¼ˆType Gymnasticsï¼‰æ˜¯æŒ‡ä½¿ç”¨ TypeScript ç±»å‹ç³»ç»Ÿè¿›è¡Œå¤æ‚çš„ç±»å‹æ¨å¯¼å’Œè½¬æ¢ã€‚æŒæ¡è¿™äº›æŠ€å·§å¯ä»¥åˆ›å»ºæ›´ç²¾ç¡®ã€æ›´å¼ºå¤§çš„ç±»å‹ã€‚

## ç±»å‹ç¼–ç¨‹åŸºç¡€

ç±»å‹ç¼–ç¨‹çš„æ ¸å¿ƒå·¥å…·ï¼š

```typescript
// TypeScript 5.x

// 1. æ¡ä»¶ç±»å‹ - ç±»å‹çº§åˆ«çš„ if-else
type IsString<T> = T extends string ? true : false

// 2. æ˜ å°„ç±»å‹ - ç±»å‹çº§åˆ«çš„ for-in
type Readonly<T> = { readonly [K in keyof T]: T[K] }

// 3. é€’å½’ç±»å‹ - ç±»å‹çº§åˆ«çš„é€’å½’
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K]
}

// 4. æ¨¡æ¿å­—é¢é‡ - ç±»å‹çº§åˆ«çš„å­—ç¬¦ä¸²æ“ä½œ
type EventName<T extends string> = `on${Capitalize<T>}`

// 5. infer - ç±»å‹çº§åˆ«çš„æ¨¡å¼åŒ¹é…
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T
```

## æ•°ç»„æ“ä½œ

### è·å–æ•°ç»„é•¿åº¦

```typescript
type Length<T extends readonly unknown[]> = T['length']

type L1 = Length<[1, 2, 3]> // 3
type L2 = Length<[]> // 0
```

### è·å–å¤´éƒ¨å’Œå°¾éƒ¨

```typescript
type Head<T extends unknown[]> = T extends [infer H, ...unknown[]] ? H : never

type Tail<T extends unknown[]> = T extends [unknown, ...infer R] ? R : never

type Last<T extends unknown[]> = T extends [...unknown[], infer L] ? L : never

type H = Head<[1, 2, 3]> // 1
type T = Tail<[1, 2, 3]> // [2, 3]
type L = Last<[1, 2, 3]> // 3
```

### æ•°ç»„åè½¬

```typescript
type Reverse<T extends unknown[]> = T extends [infer First, ...infer Rest]
  ? [...Reverse<Rest>, First]
  : []

type R = Reverse<[1, 2, 3]> // [3, 2, 1]
```

### æ•°ç»„æ‰å¹³åŒ–

```typescript
type Flatten<T extends unknown[]> = T extends [infer First, ...infer Rest]
  ? First extends unknown[]
    ? [...Flatten<First>, ...Flatten<Rest>]
    : [First, ...Flatten<Rest>]
  : []

type F = Flatten<[1, [2, [3, 4]], 5]>
// [1, 2, 3, 4, 5]
```

### æ•°ç»„å»é‡

```typescript
type Includes<T extends unknown[], U> = T extends [infer First, ...infer Rest]
  ? Equal<First, U> extends true
    ? true
    : Includes<Rest, U>
  : false

type Unique<T extends unknown[], Result extends unknown[] = []> = T extends [
  infer First,
  ...infer Rest,
]
  ? Includes<Result, First> extends true
    ? Unique<Rest, Result>
    : Unique<Rest, [...Result, First]>
  : Result

// è¾…åŠ©ç±»å‹
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false

type U = Unique<[1, 2, 1, 3, 2]>
// [1, 2, 3]
```

## å¯¹è±¡æ“ä½œ

### æ·±åº¦å¿…éœ€

```typescript
type DeepRequired<T> = T extends object
  ? {
      [K in keyof T]-?: DeepRequired<T[K]>
    }
  : T

interface User {
  name?: string
  address?: {
    city?: string
    street?: string
  }
}

type RequiredUser = DeepRequired<User>
// æ‰€æœ‰å±æ€§éƒ½å˜ä¸ºå¿…éœ€
```

### æ·±åº¦å¯é€‰

```typescript
type DeepPartial<T> = T extends object
  ? {
      [K in keyof T]?: DeepPartial<T[K]>
    }
  : T
```

### å¯¹è±¡è·¯å¾„ç±»å‹

```typescript
type Path<T, K extends keyof T = keyof T> = K extends string | number
  ? T[K] extends object
    ? K | `${K}.${Path<T[K]>}`
    : K
  : never

interface Config {
  database: {
    host: string
    port: number
  }
  server: {
    port: number
  }
}

type ConfigPath = Path<Config>
// 'database' | 'server' | 'database.host' | 'database.port' | 'server.port'
```

### è·¯å¾„å–å€¼ç±»å‹

```typescript
type PathValue<T, P extends string> = P extends `${infer K}.${infer Rest}`
  ? K extends keyof T
    ? PathValue<T[K], Rest>
    : never
  : P extends keyof T
    ? T[P]
    : never

type DbHost = PathValue<Config, 'database.host'> // string
type ServerPort = PathValue<Config, 'server.port'> // number
```

## å­—ç¬¦ä¸²æ“ä½œ

### é©¼å³°è½¬æ¢

```typescript
type CamelCase<S extends string> = S extends `${infer P}_${infer Q}`
  ? `${P}${Capitalize<CamelCase<Q>>}`
  : S extends `${infer P}-${infer Q}`
    ? `${P}${Capitalize<CamelCase<Q>>}`
    : S

type C1 = CamelCase<'hello_world'> // 'helloWorld'
type C2 = CamelCase<'foo-bar-baz'> // 'fooBarBaz'
```

### è›‡å½¢è½¬æ¢

```typescript
type SnakeCase<S extends string> = S extends `${infer C}${infer Rest}`
  ? C extends Uppercase<C>
    ? C extends Lowercase<C>
      ? `${C}${SnakeCase<Rest>}`
      : `_${Lowercase<C>}${SnakeCase<Rest>}`
    : `${C}${SnakeCase<Rest>}`
  : S

type S1 = SnakeCase<'helloWorld'> // 'hello_world'
type S2 = SnakeCase<'fooBarBaz'> // 'foo_bar_baz'
```

### å­—ç¬¦ä¸²æ›¿æ¢

```typescript
type Replace<
  S extends string,
  From extends string,
  To extends string,
> = From extends ''
  ? S
  : S extends `${infer Before}${From}${infer After}`
    ? `${Before}${To}${After}`
    : S

type ReplaceAll<
  S extends string,
  From extends string,
  To extends string,
> = From extends ''
  ? S
  : S extends `${infer Before}${From}${infer After}`
    ? ReplaceAll<`${Before}${To}${After}`, From, To>
    : S

type R1 = Replace<'hello world', ' ', '-'> // 'hello-world'
type R2 = ReplaceAll<'a.b.c', '.', '/'> // 'a/b/c'
```

### å»é™¤ç©ºæ ¼

```typescript
type TrimLeft<S extends string> = S extends
  | ` ${infer Rest}`
  | `\n${infer Rest}`
  | `\t${infer Rest}`
  ? TrimLeft<Rest>
  : S

type TrimRight<S extends string> = S extends
  | `${infer Rest} `
  | `${infer Rest}\n`
  | `${infer Rest}\t`
  ? TrimRight<Rest>
  : S

type Trim<S extends string> = TrimLeft<TrimRight<S>>

type T = Trim<'  hello  '> // 'hello'
```

## å‡½æ•°æ“ä½œ

### æŸ¯é‡ŒåŒ–ç±»å‹

```typescript
type Curry<F> = F extends (...args: infer A) => infer R
  ? A extends [infer First, ...infer Rest]
    ? Rest extends []
      ? (arg: First) => R
      : (arg: First) => Curry<(...args: Rest) => R>
    : () => R
  : never

type Add = (a: number, b: number, c: number) => number
type CurriedAdd = Curry<Add>
// (arg: number) => (arg: number) => (arg: number) => number
```

### å‡½æ•°é‡è½½æå–

```typescript
// è·å–æœ€åä¸€ä¸ªé‡è½½çš„ç±»å‹
type OverloadedReturnType<T> = T extends {
  (...args: any[]): infer R
  (...args: any[]): any
}
  ? R
  : T extends (...args: any[]) => infer R
    ? R
    : never
```

## æ•°å­¦è¿ç®—

TypeScript ç±»å‹ç³»ç»Ÿå¯ä»¥è¿›è¡Œæœ‰é™çš„æ•°å­¦è¿ç®—ï¼š

### è®¡æ•°

```typescript
type BuildTuple<
  L extends number,
  T extends unknown[] = [],
> = T['length'] extends L ? T : BuildTuple<L, [...T, unknown]>

type Add<A extends number, B extends number> = [
  ...BuildTuple<A>,
  ...BuildTuple<B>,
]['length']

type Sum = Add<3, 4> // 7
```

### å‡æ³•

```typescript
type Subtract<A extends number, B extends number> =
  BuildTuple<A> extends [...BuildTuple<B>, ...infer Rest]
    ? Rest['length']
    : never

type Diff = Subtract<10, 3> // 7
```

### æ¯”è¾ƒ

```typescript
type GreaterThan<
  A extends number,
  B extends number,
  Acc extends unknown[] = [],
> = A extends B
  ? false
  : Acc['length'] extends A
    ? false
    : Acc['length'] extends B
      ? true
      : GreaterThan<A, B, [...Acc, unknown]>

type GT1 = GreaterThan<5, 3> // true
type GT2 = GreaterThan<3, 5> // false
```

## å®ç”¨ç±»å‹

### å¿…éœ€å±æ€§

```typescript
type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

type OptionalKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? K : never
}[keyof T]

interface User {
  id: number
  name: string
  age?: number
  email?: string
}

type Required = RequiredKeys<User> // 'id' | 'name'
type Optional = OptionalKeys<User> // 'age' | 'email'
```

### è”åˆè½¬äº¤å‰

```typescript
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I
) => void
  ? I
  : never

type U = { a: string } | { b: number }
type I = UnionToIntersection<U>
// { a: string } & { b: number }
```

### è”åˆè½¬å…ƒç»„

```typescript
type UnionToTuple<T, Last = LastOfUnion<T>> = [T] extends [never]
  ? []
  : [...UnionToTuple<Exclude<T, Last>>, Last]

type LastOfUnion<T> =
  UnionToIntersection<T extends any ? () => T : never> extends () => infer R
    ? R
    : never

type Tuple = UnionToTuple<'a' | 'b' | 'c'>
// ['a', 'b', 'c']
```

### Promise å€¼æå–

```typescript
type PromiseValue<T> =
  T extends Promise<infer V>
    ? V extends Promise<any>
      ? PromiseValue<V>
      : V
    : T

type P = PromiseValue<Promise<Promise<string>>>
// string
```

## ç±»å‹æŒ‘æˆ˜ç¤ºä¾‹

### å®ç° Pick

```typescript
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P]
}

interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>
// { title: string; completed: boolean }
```

### å®ç° Readonly

```typescript
type MyReadonly<T> = {
  readonly [K in keyof T]: T[K]
}
```

### å®ç° Exclude

```typescript
type MyExclude<T, U> = T extends U ? never : T

type Result = MyExclude<'a' | 'b' | 'c', 'a'>
// 'b' | 'c'
```

### å®ç° ReturnType

```typescript
type MyReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R
  : never

function fn() {
  return { x: 10, y: 20 }
}

type R = MyReturnType<typeof fn>
// { x: number; y: number }
```

## è°ƒè¯•æŠ€å·§

### ç±»å‹å±•å¼€

```typescript
// å±•å¼€ç±»å‹ä»¥ä¾¿æŸ¥çœ‹
type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never

type ExpandRecursive<T> = T extends object
  ? T extends infer O
    ? { [K in keyof O]: ExpandRecursive<O[K]> }
    : never
  : T

// ä½¿ç”¨
type Complex = { a: string } & { b: number }
type Expanded = Expand<Complex>
// { a: string; b: number }
```

### ç±»å‹æ–­è¨€

```typescript
// æ£€æŸ¥ç±»å‹ç›¸ç­‰
type Expect<T extends true> = T
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false

// æµ‹è¯•
type Test1 = Expect<Equal<MyPick<Todo, 'title'>, { title: string }>>
type Test2 = Expect<Equal<1, 1>>
```

## å¸¸è§é—®é¢˜

### ğŸ™‹ é€’å½’æ·±åº¦é™åˆ¶ï¼Ÿ

```typescript
// TypeScript æœ‰é€’å½’æ·±åº¦é™åˆ¶ï¼ˆçº¦ 1000 å±‚ï¼‰
// ä½¿ç”¨å°¾é€’å½’ä¼˜åŒ–
type DeepFlat<T, Acc extends unknown[] = []> = T extends [
  infer First,
  ...infer Rest,
]
  ? First extends unknown[]
    ? DeepFlat<[...First, ...Rest], Acc>
    : DeepFlat<Rest, [...Acc, First]>
  : Acc
```

### ğŸ™‹ å¦‚ä½•å¤„ç†è”åˆç±»å‹åˆ†å‘ï¼Ÿ

```typescript
// è”åˆç±»å‹ä¼šè‡ªåŠ¨åˆ†å‘
type ToArray<T> = T extends any ? T[] : never
type Result = ToArray<string | number> // string[] | number[]

// ç¦æ­¢åˆ†å‘
type ToArrayNoDistribute<T> = [T] extends [any] ? T[] : never
type Result2 = ToArrayNoDistribute<string | number> // (string | number)[]
```

## æ€»ç»“

| æŠ€å·§       | ç”¨é€”       | ç¤ºä¾‹                              |
| ---------- | ---------- | --------------------------------- |
| æ¡ä»¶ç±»å‹   | ç±»å‹åˆ†æ”¯   | `T extends U ? X : Y`             |
| æ˜ å°„ç±»å‹   | éå†å±æ€§   | `{ [K in keyof T]: T[K] }`        |
| é€’å½’ç±»å‹   | åµŒå¥—å¤„ç†   | `T extends [infer F, ...infer R]` |
| æ¨¡æ¿å­—é¢é‡ | å­—ç¬¦ä¸²æ“ä½œ | `` `${T}` ``                      |
| infer      | æ¨¡å¼åŒ¹é…   | `T extends Promise<infer U>`      |

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†å­¦ä¹  TypeScript æœ€ä½³å®è·µï¼Œäº†è§£å¦‚ä½•åœ¨å®é™…é¡¹ç›®ä¸­æ›´å¥½åœ°ä½¿ç”¨ TypeScriptã€‚
