---
title: 'æ˜ å°„ç±»å‹'
description: 'TypeScript æ˜ å°„ç±»å‹è¯¦è§£ï¼šåŸºç¡€æ˜ å°„ã€ä¿®é¥°ç¬¦æ§åˆ¶ã€é”®é‡æ˜ å°„ã€æ¨¡æ¿å­—é¢é‡æ˜ å°„'
pubDate: 2024-02-08
toc: true
ogImage: true
category: 'TypeScript'
tags: ['TypeScript', 'æ˜ å°„ç±»å‹', 'Mapped Types', 'ç±»å‹è½¬æ¢', 'é«˜çº§ç±»å‹']
---

æ˜ å°„ç±»å‹ï¼ˆMapped Typesï¼‰å…è®¸æˆ‘ä»¬åŸºäºç°æœ‰ç±»å‹åˆ›å»ºæ–°ç±»å‹ï¼Œé€šè¿‡éå†é”®æ¥è½¬æ¢æ¯ä¸ªå±æ€§ã€‚

## åŸºç¡€æ˜ å°„

ä½¿ç”¨ `in` å…³é”®å­—éå†ç±»å‹çš„é”®ï¼š

```typescript
// TypeScript 5.x

// åŸºæœ¬è¯­æ³•
type Mapped<T> = {
  [K in keyof T]: T[K]
}

interface User {
  id: number
  name: string
  email: string
}

// åˆ›å»ºç›¸åŒç±»å‹
type UserCopy = Mapped<User>
// { id: number; name: string; email: string }

// å°†æ‰€æœ‰å±æ€§å˜ä¸ºå¯é€‰
type MyPartial<T> = {
  [K in keyof T]?: T[K]
}

type PartialUser = MyPartial<User>
// { id?: number; name?: string; email?: string }

// å°†æ‰€æœ‰å±æ€§å˜ä¸ºåªè¯»
type MyReadonly<T> = {
  readonly [K in keyof T]: T[K]
}

type ReadonlyUser = MyReadonly<User>
// { readonly id: number; readonly name: string; readonly email: string }
```

## ä¿®é¥°ç¬¦æ§åˆ¶

ä½¿ç”¨ `+` å’Œ `-` æ·»åŠ æˆ–ç§»é™¤ä¿®é¥°ç¬¦ï¼š

```typescript
interface OptionalUser {
  id?: number
  name?: string
  email?: string
}

// ç§»é™¤å¯é€‰ä¿®é¥°ç¬¦
type Required<T> = {
  [K in keyof T]-?: T[K]
}

type RequiredUser = Required<OptionalUser>
// { id: number; name: string; email: string }

// ç§»é™¤åªè¯»ä¿®é¥°ç¬¦
interface ReadonlyUser {
  readonly id: number
  readonly name: string
}

type Mutable<T> = {
  -readonly [K in keyof T]: T[K]
}

type MutableUser = Mutable<ReadonlyUser>
// { id: number; name: string }

// åŒæ—¶æ§åˆ¶å¤šä¸ªä¿®é¥°ç¬¦
type FullyMutable<T> = {
  -readonly [K in keyof T]-?: T[K]
}

interface StrictUser {
  readonly id?: number
  readonly name?: string
}

type FlexibleUser = FullyMutable<StrictUser>
// { id: number; name: string }
```

## å€¼ç±»å‹è½¬æ¢

æ˜ å°„æ—¶è½¬æ¢å±æ€§çš„å€¼ç±»å‹ï¼š

```typescript
// å°†æ‰€æœ‰å±æ€§å˜ä¸ºå­—ç¬¦ä¸²
type Stringify<T> = {
  [K in keyof T]: string
}

interface Product {
  id: number
  name: string
  price: number
  inStock: boolean
}

type StringProduct = Stringify<Product>
// { id: string; name: string; price: string; inStock: string }

// å°†æ‰€æœ‰å±æ€§åŒ…è£…ä¸º Promise
type Promisify<T> = {
  [K in keyof T]: Promise<T[K]>
}

type AsyncProduct = Promisify<Product>
// { id: Promise<number>; name: Promise<string>; ... }

// å°†æ‰€æœ‰å±æ€§å˜ä¸ºæ•°ç»„
type Arrayify<T> = {
  [K in keyof T]: T[K][]
}

type ArrayProduct = Arrayify<Product>
// { id: number[]; name: string[]; ... }

// æ¡ä»¶è½¬æ¢
type Nullable<T> = {
  [K in keyof T]: T[K] | null
}

type NullableProduct = Nullable<Product>
// { id: number | null; name: string | null; ... }
```

## é”®é‡æ˜ å°„

ä½¿ç”¨ `as` å­å¥é‡å‘½åé”®ï¼š

```typescript
// æ·»åŠ å‰ç¼€
type Prefixed<T, P extends string> = {
  [K in keyof T as `${P}${Capitalize<K & string>}`]: T[K]
}

interface User {
  name: string
  age: number
}

type GetterUser = Prefixed<User, 'get'>
// { getName: string; getAge: number }

// æ·»åŠ åç¼€
type Suffixed<T, S extends string> = {
  [K in keyof T as `${K & string}${S}`]: T[K]
}

type UserHandler = Suffixed<User, 'Handler'>
// { nameHandler: string; ageHandler: number }

// è¿‡æ»¤é”®
type OnlyStrings<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K]
}

interface Mixed {
  name: string
  age: number
  email: string
  active: boolean
}

type StringProps = OnlyStrings<Mixed>
// { name: string; email: string }

// æ’é™¤ç‰¹å®šé”®
type OmitByType<T, U> = {
  [K in keyof T as T[K] extends U ? never : K]: T[K]
}

type WithoutNumbers = OmitByType<Mixed, number>
// { name: string; email: string; active: boolean }
```

## Getter/Setter ç”Ÿæˆ

```typescript
// ç”Ÿæˆ getter ç±»å‹
type Getters<T> = {
  [K in keyof T as `get${Capitalize<K & string>}`]: () => T[K]
}

// ç”Ÿæˆ setter ç±»å‹
type Setters<T> = {
  [K in keyof T as `set${Capitalize<K & string>}`]: (value: T[K]) => void
}

interface State {
  count: number
  name: string
  loading: boolean
}

type StateGetters = Getters<State>
// {
//   getCount: () => number
//   getName: () => string
//   getLoading: () => boolean
// }

type StateSetters = Setters<State>
// {
//   setCount: (value: number) => void
//   setName: (value: string) => void
//   setLoading: (value: boolean) => void
// }

// ç»„åˆ getter å’Œ setter
type WithAccessors<T> = T & Getters<T> & Setters<T>

type FullState = WithAccessors<State>
```

## æ·±åº¦æ˜ å°„

é€’å½’å¤„ç†åµŒå¥—å¯¹è±¡ï¼š

```typescript
// æ·±åº¦åªè¯»
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object
    ? T[K] extends Function
      ? T[K]
      : DeepReadonly<T[K]>
    : T[K]
}

interface NestedConfig {
  database: {
    host: string
    port: number
    credentials: {
      username: string
      password: string
    }
  }
  server: {
    port: number
  }
}

type ReadonlyConfig = DeepReadonly<NestedConfig>
// æ‰€æœ‰åµŒå¥—å±æ€§éƒ½å˜ä¸ºåªè¯»

// æ·±åº¦å¯é€‰
type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object
    ? T[K] extends Function
      ? T[K]
      : DeepPartial<T[K]>
    : T[K]
}

type PartialConfig = DeepPartial<NestedConfig>
// æ‰€æœ‰åµŒå¥—å±æ€§éƒ½å˜ä¸ºå¯é€‰

// æ·±åº¦å¿…éœ€
type DeepRequired<T> = {
  [K in keyof T]-?: T[K] extends object
    ? T[K] extends Function
      ? T[K]
      : DeepRequired<T[K]>
    : T[K]
}
```

## æ¡ä»¶æ˜ å°„

æ ¹æ®å±æ€§ç±»å‹åº”ç”¨ä¸åŒè½¬æ¢ï¼š

```typescript
// æ ¹æ®ç±»å‹æ¡ä»¶è½¬æ¢
type ConditionalMap<T> = {
  [K in keyof T]: T[K] extends string
    ? `string:${T[K]}`
    : T[K] extends number
      ? `number:${T[K]}`
      : T[K]
}

// æå–ç‰¹å®šç±»å‹çš„é”®
type KeysOfType<T, U> = {
  [K in keyof T]: T[K] extends U ? K : never
}[keyof T]

interface User {
  id: number
  name: string
  email: string
  age: number
  active: boolean
}

type StringKeys = KeysOfType<User, string>
// 'name' | 'email'

type NumberKeys = KeysOfType<User, number>
// 'id' | 'age'

// åªä¿ç•™ç‰¹å®šç±»å‹çš„å±æ€§
type PickByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K]
}

type StringProps = PickByType<User, string>
// { name: string; email: string }
```

## å®é™…åº”ç”¨

### è¡¨å•éªŒè¯ç±»å‹

```typescript
interface FormFields {
  username: string
  email: string
  age: number
  agreed: boolean
}

// ç”Ÿæˆé”™è¯¯ç±»å‹
type FormErrors<T> = {
  [K in keyof T]?: string
}

// ç”Ÿæˆè§¦æ‘¸çŠ¶æ€ç±»å‹
type FormTouched<T> = {
  [K in keyof T]?: boolean
}

// ç”ŸæˆéªŒè¯å™¨ç±»å‹
type FormValidators<T> = {
  [K in keyof T]?: (value: T[K]) => string | undefined
}

// å®Œæ•´è¡¨å•çŠ¶æ€
interface FormState<T> {
  values: T
  errors: FormErrors<T>
  touched: FormTouched<T>
}

const formState: FormState<FormFields> = {
  values: {
    username: '',
    email: '',
    age: 0,
    agreed: false,
  },
  errors: {
    username: 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º',
  },
  touched: {
    username: true,
    email: true,
  },
}
```

### API å“åº”è½¬æ¢

```typescript
interface ApiEntity {
  id: number
  created_at: string
  updated_at: string
}

interface User extends ApiEntity {
  name: string
  email: string
}

// é©¼å³°è½¬æ¢ç±»å‹
type CamelCase<S extends string> = S extends `${infer P}_${infer Q}`
  ? `${P}${Capitalize<CamelCase<Q>>}`
  : S

type CamelCaseKeys<T> = {
  [K in keyof T as CamelCase<K & string>]: T[K]
}

type CamelUser = CamelCaseKeys<User>
// { id: number; createdAt: string; updatedAt: string; name: string; email: string }

// æ·»åŠ æ—¶é—´æˆ³ç±»å‹è½¬æ¢
type WithDates<T> = {
  [K in keyof T]: K extends 'created_at' | 'updated_at'
    ? Date
    : K extends `${string}_at`
      ? Date
      : T[K]
}

type UserWithDates = WithDates<User>
// { id: number; created_at: Date; updated_at: Date; name: string; email: string }
```

### äº‹ä»¶å¤„ç†å™¨æ˜ å°„

```typescript
interface Events {
  click: { x: number; y: number }
  focus: { target: HTMLElement }
  input: { value: string }
}

// ç”Ÿæˆäº‹ä»¶å¤„ç†å™¨ç±»å‹
type EventHandlers<T> = {
  [K in keyof T as `on${Capitalize<K & string>}`]: (event: T[K]) => void
}

type AppEventHandlers = EventHandlers<Events>
// {
//   onClick: (event: { x: number; y: number }) => void
//   onFocus: (event: { target: HTMLElement }) => void
//   onInput: (event: { value: string }) => void
// }

// ç”Ÿæˆäº‹ä»¶ç›‘å¬å™¨æ–¹æ³•
type EventListenerMethods<T> = {
  [K in keyof T as `add${Capitalize<K & string>}Listener`]: (
    handler: (event: T[K]) => void
  ) => void
} & {
  [K in keyof T as `remove${Capitalize<K & string>}Listener`]: (
    handler: (event: T[K]) => void
  ) => void
}

type EventEmitter = EventListenerMethods<Events>
```

### çŠ¶æ€ç®¡ç†

```typescript
interface State {
  user: { name: string } | null
  count: number
  loading: boolean
}

// ç”Ÿæˆ action ç±»å‹
type Actions<T> = {
  [K in keyof T as `set${Capitalize<K & string>}`]: {
    type: `SET_${Uppercase<K & string>}`
    payload: T[K]
  }
}[keyof T]

type AppAction = Actions<State>
// { type: 'SET_USER'; payload: { name: string } | null }
// | { type: 'SET_COUNT'; payload: number }
// | { type: 'SET_LOADING'; payload: boolean }

// ç”Ÿæˆ reducer ç±»å‹
type Reducers<T> = {
  [K in keyof T]: (state: T, payload: T[K]) => T
}
```

## å¸¸è§é—®é¢˜

### ğŸ™‹ æ˜ å°„ç±»å‹ä¼šä¿ç•™å¯é€‰æ€§å—ï¼Ÿ

```typescript
interface Original {
  required: string
  optional?: number
}

// é»˜è®¤ä¿ç•™ä¿®é¥°ç¬¦
type Mapped = {
  [K in keyof Original]: Original[K]
}
// { required: string; optional?: number }

// æ˜¾å¼ä¿ç•™
type PreserveModifiers<T> = {
  [K in keyof T]: T[K]
}

// ç§»é™¤å¯é€‰
type MakeRequired<T> = {
  [K in keyof T]-?: T[K]
}
// { required: string; optional: number }
```

### ğŸ™‹ å¦‚ä½•åªæ˜ å°„éƒ¨åˆ†é”®ï¼Ÿ

```typescript
interface User {
  id: number
  name: string
  email: string
  password: string
}

// ä½¿ç”¨ Pick é™åˆ¶é”®
type PublicUser = {
  [K in keyof Pick<User, 'id' | 'name' | 'email'>]: User[K]
}

// æˆ–è€…ä½¿ç”¨ as è¿‡æ»¤
type ExcludePassword = {
  [K in keyof User as Exclude<K, 'password'>]: User[K]
}
```

### ğŸ™‹ æ˜ å°„ç±»å‹å¯ä»¥æ·»åŠ æ–°å±æ€§å—ï¼Ÿ

```typescript
// æ˜ å°„ç±»å‹åªèƒ½è½¬æ¢ç°æœ‰å±æ€§
// ä½¿ç”¨äº¤å‰ç±»å‹æ·»åŠ æ–°å±æ€§
type WithTimestamp<T> = {
  [K in keyof T]: T[K]
} & {
  timestamp: Date
}

interface User {
  name: string
}

type TimestampedUser = WithTimestamp<User>
// { name: string } & { timestamp: Date }
```

## æ€»ç»“

| ç‰¹æ€§       | è¯­æ³•                   | ç”¨é€”           |
| ---------- | ---------------------- | -------------- |
| åŸºç¡€æ˜ å°„   | `[K in keyof T]: T[K]` | éå†æ‰€æœ‰å±æ€§   |
| æ·»åŠ ä¿®é¥°ç¬¦ | `+readonly`, `+?`      | æ·»åŠ åªè¯»/å¯é€‰  |
| ç§»é™¤ä¿®é¥°ç¬¦ | `-readonly`, `-?`      | ç§»é™¤åªè¯»/å¯é€‰  |
| é”®é‡æ˜ å°„   | `as NewKey`            | é‡å‘½åæˆ–è¿‡æ»¤é”® |
| å€¼è½¬æ¢     | `: NewType`            | è½¬æ¢å±æ€§ç±»å‹   |

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†å­¦ä¹ æ¡ä»¶ç±»å‹ï¼Œäº†è§£å¦‚ä½•æ ¹æ®æ¡ä»¶é€‰æ‹©ç±»å‹ã€‚
