---
title: 'æ³›å‹å®æˆ˜'
description: 'TypeScript æ³›å‹å®æˆ˜ï¼šæ³›å‹ç»„ä»¶ã€æ³›å‹ API å°è£…ã€å¸¸è§è®¾è®¡æ¨¡å¼çš„æ³›å‹åº”ç”¨'
pubDate: 2024-02-04
toc: true
ogImage: true
category: 'TypeScript'
tags: ['TypeScript', 'æ³›å‹', 'å®æˆ˜', 'è®¾è®¡æ¨¡å¼', 'APIå°è£…']
---

å­¦ä¹ äº†æ³›å‹çš„åŸºç¡€çŸ¥è¯†åï¼Œæœ¬ç¯‡é€šè¿‡å®é™…æ¡ˆä¾‹å±•ç¤ºæ³›å‹åœ¨çœŸå®é¡¹ç›®ä¸­çš„åº”ç”¨ã€‚

## é€šç”¨ API å“åº”å¤„ç†

```typescript
// TypeScript 5.x

// é€šç”¨å“åº”ç±»å‹
interface ApiResponse<T> {
  code: number
  message: string
  data: T
  timestamp: number
}

// åˆ†é¡µå“åº”
interface PaginatedData<T> {
  items: T[]
  total: number
  page: number
  pageSize: number
  hasMore: boolean
}

// é€šç”¨è¯·æ±‚å‡½æ•°
async function request<T>(
  url: string,
  options?: RequestInit
): Promise<ApiResponse<T>> {
  const response = await fetch(url, options)
  return response.json()
}

// ä½¿ç”¨
interface User {
  id: number
  name: string
  email: string
}

const userResponse = await request<User>('/api/user/1')
console.log(userResponse.data.name) // ç±»å‹å®‰å…¨

const usersResponse = await request<PaginatedData<User>>('/api/users')
console.log(usersResponse.data.items[0].name) // ç±»å‹å®‰å…¨
```

## çŠ¶æ€ç®¡ç†

```typescript
// é€šç”¨çŠ¶æ€ç®¡ç†å™¨
class Store<S extends object> {
  private state: S
  private listeners: Set<(state: S) => void> = new Set()

  constructor(initialState: S) {
    this.state = initialState
  }

  getState(): Readonly<S> {
    return this.state
  }

  setState<K extends keyof S>(key: K, value: S[K]): void
  setState(partial: Partial<S>): void
  setState<K extends keyof S>(
    keyOrPartial: K | Partial<S>,
    value?: S[K]
  ): void {
    if (typeof keyOrPartial === 'string') {
      this.state = { ...this.state, [keyOrPartial]: value }
    } else {
      this.state = { ...this.state, ...keyOrPartial }
    }
    this.notify()
  }

  subscribe(listener: (state: S) => void): () => void {
    this.listeners.add(listener)
    return () => this.listeners.delete(listener)
  }

  private notify(): void {
    this.listeners.forEach((l) => l(this.state))
  }
}

// ä½¿ç”¨
interface AppState {
  user: { name: string } | null
  theme: 'light' | 'dark'
  loading: boolean
}

const store = new Store<AppState>({
  user: null,
  theme: 'light',
  loading: false,
})

store.setState('loading', true)
store.setState({ user: { name: 'å¼ ä¸‰' } })
```

## è¡¨å•å¤„ç†

```typescript
// è¡¨å•å­—æ®µç±»å‹
interface FormField<T> {
  value: T
  error?: string
  touched: boolean
  validate(): boolean
}

// è¡¨å•ç±»å‹
type FormFields<T> = {
  [K in keyof T]: FormField<T[K]>
}

// è¡¨å•ç®¡ç†å™¨
class FormManager<T extends object> {
  private fields: FormFields<T>
  private validators: Partial<
    Record<keyof T, (value: any) => string | undefined>
  >

  constructor(
    initialValues: T,
    validators?: Partial<Record<keyof T, (value: any) => string | undefined>>
  ) {
    this.validators = validators || {}
    this.fields = {} as FormFields<T>

    for (const key in initialValues) {
      this.fields[key] = {
        value: initialValues[key],
        touched: false,
        validate: () => this.validateField(key),
      }
    }
  }

  private validateField(key: keyof T): boolean {
    const validator = this.validators[key]
    if (validator) {
      const error = validator(this.fields[key].value)
      this.fields[key].error = error
      return !error
    }
    return true
  }

  setValue<K extends keyof T>(key: K, value: T[K]): void {
    this.fields[key].value = value
    this.fields[key].touched = true
    this.validateField(key)
  }

  getValues(): T {
    const values = {} as T
    for (const key in this.fields) {
      values[key] = this.fields[key].value
    }
    return values
  }

  isValid(): boolean {
    return Object.keys(this.fields).every((key) =>
      this.validateField(key as keyof T)
    )
  }
}

// ä½¿ç”¨
interface LoginForm {
  email: string
  password: string
}

const form = new FormManager<LoginForm>(
  { email: '', password: '' },
  {
    email: (v) => (!v.includes('@') ? 'æ— æ•ˆçš„é‚®ç®±' : undefined),
    password: (v) => (v.length < 6 ? 'å¯†ç è‡³å°‘6ä½' : undefined),
  }
)

form.setValue('email', 'test@test.com')
form.setValue('password', '123456')
console.log(form.isValid()) // true
```

## äº‹ä»¶ç³»ç»Ÿ

```typescript
type EventHandler<T> = (payload: T) => void

class EventEmitter<EventMap extends Record<string, any>> {
  private handlers = new Map<keyof EventMap, Set<Function>>()

  on<K extends keyof EventMap>(
    event: K,
    handler: EventHandler<EventMap[K]>
  ): () => void {
    if (!this.handlers.has(event)) {
      this.handlers.set(event, new Set())
    }
    this.handlers.get(event)!.add(handler)
    return () => this.off(event, handler)
  }

  off<K extends keyof EventMap>(
    event: K,
    handler: EventHandler<EventMap[K]>
  ): void {
    this.handlers.get(event)?.delete(handler)
  }

  emit<K extends keyof EventMap>(event: K, payload: EventMap[K]): void {
    this.handlers.get(event)?.forEach((handler) => handler(payload))
  }

  once<K extends keyof EventMap>(
    event: K,
    handler: EventHandler<EventMap[K]>
  ): void {
    const wrapper: EventHandler<EventMap[K]> = (payload) => {
      handler(payload)
      this.off(event, wrapper)
    }
    this.on(event, wrapper)
  }
}

// ä½¿ç”¨
interface AppEvents {
  'login': { userId: string; timestamp: number }
  'logout': undefined
  'error': Error
  'data:update': { type: string; data: unknown }
}

const emitter = new EventEmitter<AppEvents>()

emitter.on('login', ({ userId, timestamp }) => {
  console.log(`User ${userId} logged in at ${timestamp}`)
})

emitter.emit('login', { userId: '123', timestamp: Date.now() })
```

## ä¾èµ–æ³¨å…¥å®¹å™¨

```typescript
type Constructor<T = any> = new (...args: any[]) => T

class Container {
  private instances = new Map<Constructor, any>()
  private factories = new Map<Constructor, () => any>()

  register<T>(ctor: Constructor<T>, factory: () => T): void {
    this.factories.set(ctor, factory)
  }

  registerSingleton<T>(ctor: Constructor<T>, factory: () => T): void {
    this.factories.set(ctor, () => {
      if (!this.instances.has(ctor)) {
        this.instances.set(ctor, factory())
      }
      return this.instances.get(ctor)
    })
  }

  resolve<T>(ctor: Constructor<T>): T {
    const factory = this.factories.get(ctor)
    if (!factory) {
      throw new Error(`No registration for ${ctor.name}`)
    }
    return factory()
  }
}

// ä½¿ç”¨
interface Logger {
  log(message: string): void
}

class ConsoleLogger implements Logger {
  log(message: string) {
    console.log(message)
  }
}

class UserService {
  constructor(private logger: Logger) {}

  createUser(name: string) {
    this.logger.log(`Creating user: ${name}`)
  }
}

const container = new Container()
container.registerSingleton(ConsoleLogger, () => new ConsoleLogger())
container.register(
  UserService,
  () => new UserService(container.resolve(ConsoleLogger))
)

const userService = container.resolve(UserService)
userService.createUser('å¼ ä¸‰')
```

## ç±»å‹å®‰å…¨çš„è·¯ç”±

```typescript
// è·¯ç”±å®šä¹‰
type RouteParams<T extends string> =
  T extends `${string}:${infer Param}/${infer Rest}`
    ? { [K in Param | keyof RouteParams<Rest>]: string }
    : T extends `${string}:${infer Param}`
      ? { [K in Param]: string }
      : {}

// è·¯ç”±å™¨
class Router<Routes extends Record<string, string>> {
  private routes = new Map<keyof Routes, Function>()

  register<K extends keyof Routes>(
    path: K,
    handler: (params: RouteParams<Routes[K] & string>) => void
  ): void {
    this.routes.set(path, handler)
  }

  navigate<K extends keyof Routes>(
    path: K,
    params: RouteParams<Routes[K] & string>
  ): void {
    const handler = this.routes.get(path)
    if (handler) {
      handler(params)
    }
  }
}

// ä½¿ç”¨
type AppRoutes = {
  home: '/'
  user: '/user/:id'
  post: '/post/:postId/comment/:commentId'
}

const router = new Router<AppRoutes>()

router.register('user', (params) => {
  console.log(`User ID: ${params.id}`) // ç±»å‹å®‰å…¨
})

router.register('post', (params) => {
  console.log(`Post: ${params.postId}, Comment: ${params.commentId}`)
})

router.navigate('user', { id: '123' })
```

## å¸¸è§é—®é¢˜

### ğŸ™‹ æ³›å‹ä¼šå¢åŠ è¿è¡Œæ—¶å¼€é”€å—ï¼Ÿ

ä¸ä¼šã€‚æ³›å‹åªåœ¨ç¼–è¯‘æ—¶å­˜åœ¨ï¼Œç¼–è¯‘åçš„ JavaScript æ²¡æœ‰ç±»å‹ä¿¡æ¯ã€‚

### ğŸ™‹ å¦‚ä½•è°ƒè¯•å¤æ‚çš„æ³›å‹ç±»å‹ï¼Ÿ

ä½¿ç”¨ç±»å‹åˆ«åå±•å¼€ï¼š

```typescript
// å¤æ‚ç±»å‹
type Complex<T> = T extends object ? { [K in keyof T]: Complex<T[K]> } : T

// è°ƒè¯•ï¼šåˆ›å»ºå…·ä½“å®ä¾‹æŸ¥çœ‹ç±»å‹
type Debug = Complex<{ a: { b: string } }>
// é¼ æ ‡æ‚¬åœæŸ¥çœ‹å±•å¼€åçš„ç±»å‹
```

## æ€»ç»“

æ³›å‹çš„å®æˆ˜åº”ç”¨åœºæ™¯ï¼š

- API å“åº”å°è£…
- çŠ¶æ€ç®¡ç†
- è¡¨å•å¤„ç†
- äº‹ä»¶ç³»ç»Ÿ
- ä¾èµ–æ³¨å…¥
- è·¯ç”±ç³»ç»Ÿ

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†è¿›å…¥ç±»å‹ç³»ç»Ÿè¿›é˜¶ï¼Œå­¦ä¹ ç±»å‹å®ˆå«ã€‚
