---
title: 'infer å…³é”®å­—'
description: 'TypeScript infer å…³é”®å­—è¯¦è§£ï¼šç±»å‹æ¨æ–­ã€æå–å‡½æ•°è¿”å›å€¼ã€æå–æ•°ç»„å…ƒç´ ã€æå– Promise ç±»å‹'
pubDate: 2024-02-10
toc: true
ogImage: true
category: 'TypeScript'
tags: ['TypeScript', 'infer', 'ç±»å‹æ¨æ–­', 'æ¡ä»¶ç±»å‹', 'é«˜çº§ç±»å‹']
---

`infer` å…³é”®å­—ç”¨äºåœ¨æ¡ä»¶ç±»å‹ä¸­æ¨æ–­ç±»å‹ï¼Œå®ƒå¯ä»¥æ•è·ç±»å‹çš„æŸä¸ªéƒ¨åˆ†ä¾›åç»­ä½¿ç”¨ã€‚

## åŸºæœ¬è¯­æ³•

`infer` åªèƒ½åœ¨æ¡ä»¶ç±»å‹çš„ `extends` å­å¥ä¸­ä½¿ç”¨ï¼š

```typescript
// TypeScript 5.x

// åŸºæœ¬è¯­æ³•ï¼šåœ¨ extends å­å¥ä¸­ä½¿ç”¨ infer å£°æ˜ç±»å‹å˜é‡
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never

// ä½¿ç”¨
function greet(): string {
  return 'hello'
}

type GreetReturn = GetReturnType<typeof greet>
// string

function add(a: number, b: number): number {
  return a + b
}

type AddReturn = GetReturnType<typeof add>
// number

// éå‡½æ•°ç±»å‹è¿”å› never
type NotFunction = GetReturnType<string>
// never
```

## æå–å‡½æ•°ç±»å‹

### è¿”å›å€¼ç±»å‹

```typescript
// æå–è¿”å›å€¼ï¼ˆå†…ç½® ReturnType çš„å®ç°ï¼‰
type MyReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R
  : any

type R1 = MyReturnType<() => string> // string
type R2 = MyReturnType<(x: number) => boolean> // boolean
type R3 = MyReturnType<typeof Math.random> // number

// å¤„ç†å¼‚æ­¥å‡½æ•°
type AsyncReturnType<T extends (...args: any) => Promise<any>> = T extends (
  ...args: any
) => Promise<infer R>
  ? R
  : never

async function fetchData() {
  return { id: 1, name: 'å¼ ä¸‰' }
}

type Data = AsyncReturnType<typeof fetchData>
// { id: number; name: string }
```

### å‚æ•°ç±»å‹

```typescript
// æå–å‚æ•°ç±»å‹ï¼ˆå†…ç½® Parameters çš„å®ç°ï¼‰
type MyParameters<T extends (...args: any) => any> = T extends (
  ...args: infer P
) => any
  ? P
  : never

function example(name: string, age: number, active: boolean) {}

type Params = MyParameters<typeof example>
// [name: string, age: number, active: boolean]

// æå–ç¬¬ä¸€ä¸ªå‚æ•°
type FirstParam<T extends (...args: any) => any> = T extends (
  first: infer F,
  ...rest: any
) => any
  ? F
  : never

type First = FirstParam<typeof example>
// string

// æå–å‰©ä½™å‚æ•°
type RestParams<T extends (...args: any) => any> = T extends (
  first: any,
  ...rest: infer R
) => any
  ? R
  : never

type Rest = RestParams<typeof example>
// [age: number, active: boolean]

// æå–æœ€åä¸€ä¸ªå‚æ•°
type LastParam<T extends any[]> = T extends [...any, infer L] ? L : never

type Last = LastParam<Parameters<typeof example>>
// boolean
```

### this å‚æ•°

```typescript
// æå– this å‚æ•°ç±»å‹
type ThisParameterType<T> = T extends (this: infer U, ...args: any[]) => any
  ? U
  : unknown

function greet(this: { name: string }) {
  console.log(`Hello, ${this.name}`)
}

type GreetThis = ThisParameterType<typeof greet>
// { name: string }

// ç§»é™¤ this å‚æ•°
type OmitThisParameter<T> = T extends (this: any, ...args: infer A) => infer R
  ? (...args: A) => R
  : T

type GreetWithoutThis = OmitThisParameter<typeof greet>
// () => void
```

## æå–æ•°ç»„ç±»å‹

```typescript
// æå–æ•°ç»„å…ƒç´ ç±»å‹
type ElementType<T> = T extends (infer E)[] ? E : never

type E1 = ElementType<string[]> // string
type E2 = ElementType<number[]> // number
type E3 = ElementType<(string | number)[]> // string | number

// æå–å…ƒç»„ç¬¬ä¸€ä¸ªå…ƒç´ 
type Head<T extends any[]> = T extends [infer H, ...any[]] ? H : never

type H1 = Head<[string, number, boolean]> // string
type H2 = Head<[]> // never

// æå–å…ƒç»„æœ€åä¸€ä¸ªå…ƒç´ 
type Tail<T extends any[]> = T extends [...any[], infer L] ? L : never

type T1 = Tail<[string, number, boolean]> // boolean

// æå–é™¤ç¬¬ä¸€ä¸ªå¤–çš„å…ƒç´ 
type Rest<T extends any[]> = T extends [any, ...infer R] ? R : never

type R1 = Rest<[1, 2, 3]> // [2, 3]
type R2 = Rest<[1]> // []

// æå–é™¤æœ€åä¸€ä¸ªå¤–çš„å…ƒç´ 
type Init<T extends any[]> = T extends [...infer I, any] ? I : never

type I1 = Init<[1, 2, 3]> // [1, 2]
```

## æå– Promise ç±»å‹

```typescript
// æå– Promise å†…éƒ¨ç±»å‹
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T

type P1 = UnwrapPromise<Promise<string>> // string
type P2 = UnwrapPromise<Promise<number[]>> // number[]
type P3 = UnwrapPromise<string> // stringï¼ˆé Promise è¿”å›åŸç±»å‹ï¼‰

// æ·±åº¦è§£åŒ…ï¼ˆå†…ç½® Awaited çš„å®ç°ï¼‰
type DeepAwaited<T> = T extends Promise<infer U> ? DeepAwaited<U> : T

type D1 = DeepAwaited<Promise<Promise<string>>> // string
type D2 = DeepAwaited<Promise<Promise<Promise<number>>>> // number

// æå– PromiseLike
type UnwrapPromiseLike<T> = T extends PromiseLike<infer U> ? U : T

const thenable = {
  then: (resolve: (value: string) => void) => resolve('hello'),
}

type Thenable = UnwrapPromiseLike<typeof thenable>
// string
```

## æå–å¯¹è±¡ç±»å‹

```typescript
// æå–å¯¹è±¡å±æ€§ç±»å‹
type PropertyType<T, K extends keyof T> = T extends { [P in K]: infer V }
  ? V
  : never

interface User {
  id: number
  name: string
  email: string
}

type IdType = PropertyType<User, 'id'> // number

// æå–æ„é€ å‡½æ•°å®ä¾‹ç±»å‹
type InstanceType<T extends new (...args: any) => any> = T extends new (
  ...args: any
) => infer R
  ? R
  : any

class User {
  constructor(public name: string) {}
}

type UserInstance = InstanceType<typeof User>
// User

// æå–æ„é€ å‡½æ•°å‚æ•°
type ConstructorParameters<T extends new (...args: any) => any> =
  T extends new (...args: infer P) => any ? P : never

type UserParams = ConstructorParameters<typeof User>
// [name: string]
```

## å¤šä¸ª infer

åœ¨åŒä¸€ä¸ªæ¡ä»¶ä¸­å¯ä»¥ä½¿ç”¨å¤šä¸ª `infer`ï¼š

```typescript
// åŒæ—¶æå–é”®å’Œå€¼
type KeyValue<T> = T extends { key: infer K; value: infer V } ? [K, V] : never

type KV = KeyValue<{ key: 'name'; value: string }>
// ['name', string]

// æå–å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼
type FunctionParts<T> = T extends (...args: infer P) => infer R
  ? { params: P; return: R }
  : never

type Parts = FunctionParts<(a: string, b: number) => boolean>
// { params: [a: string, b: number]; return: boolean }

// æå–å…ƒç»„çš„å¤´å°¾
type HeadAndTail<T extends any[]> = T extends [infer H, ...infer T]
  ? { head: H; tail: T }
  : never

type HT = HeadAndTail<[1, 2, 3, 4]>
// { head: 1; tail: [2, 3, 4] }
```

## æ¡ä»¶æ¨æ–­

ç»“åˆæ¡ä»¶ç±»å‹è¿›è¡Œå¤æ‚æ¨æ–­ï¼š

```typescript
// æ ¹æ®ç±»å‹é€‰æ‹©æ¨æ–­æ–¹å¼
type Unpacked<T> = T extends (infer U)[]
  ? U
  : T extends (...args: any[]) => infer U
    ? U
    : T extends Promise<infer U>
      ? U
      : T

type T0 = Unpacked<string> // string
type T1 = Unpacked<string[]> // string
type T2 = Unpacked<() => string> // string
type T3 = Unpacked<Promise<string>> // string

// åµŒå¥—è§£åŒ…
type DeepUnpacked<T> = T extends (infer U)[]
  ? DeepUnpacked<U>
  : T extends (...args: any[]) => infer U
    ? DeepUnpacked<U>
    : T extends Promise<infer U>
      ? DeepUnpacked<U>
      : T

type D0 = DeepUnpacked<Promise<string[]>> // string
type D1 = DeepUnpacked<() => Promise<number[]>> // number
```

## å®é™…åº”ç”¨

### ç±»å‹è½¬æ¢å·¥å…·

```typescript
// å°†å¯¹è±¡æ–¹æ³•è½¬æ¢ä¸ºå¼‚æ­¥ç‰ˆæœ¬
type AsyncMethods<T> = {
  [K in keyof T]: T[K] extends (...args: infer A) => infer R
    ? (...args: A) => Promise<R>
    : T[K]
}

interface UserService {
  getUser(id: number): User
  updateUser(user: User): void
  deleteUser(id: number): boolean
}

type AsyncUserService = AsyncMethods<UserService>
// {
//   getUser: (id: number) => Promise<User>
//   updateUser: (user: User) => Promise<void>
//   deleteUser: (id: number) => Promise<boolean>
// }
```

### è·¯ç”±å‚æ•°æå–

```typescript
// ä»è·¯ç”±è·¯å¾„æå–å‚æ•°
type ExtractRouteParams<T extends string> =
  T extends `${infer Start}:${infer Param}/${infer Rest}`
    ? { [K in Param | keyof ExtractRouteParams<Rest>]: string }
    : T extends `${infer Start}:${infer Param}`
      ? { [K in Param]: string }
      : {}

type Params1 = ExtractRouteParams<'/users/:id'>
// { id: string }

type Params2 = ExtractRouteParams<'/users/:userId/posts/:postId'>
// { userId: string; postId: string }

type Params3 = ExtractRouteParams<'/home'>
// {}
```

### äº‹ä»¶å¤„ç†å™¨æå–

```typescript
// ä»ç»„ä»¶ç±»å‹æå–äº‹ä»¶å¤„ç†å™¨
type ExtractEventHandlers<T> = {
  [K in keyof T as K extends `on${infer Event}` ? Event : never]: T[K] extends (
    ...args: infer A
  ) => any
    ? A
    : never
}

interface ButtonProps {
  onClick: (e: MouseEvent) => void
  onHover: (e: MouseEvent) => void
  onFocus: (e: FocusEvent) => void
  disabled: boolean
  label: string
}

type ButtonEvents = ExtractEventHandlers<ButtonProps>
// {
//   Click: [e: MouseEvent]
//   Hover: [e: MouseEvent]
//   Focus: [e: FocusEvent]
// }
```

### Vue ç»„ä»¶ Props æ¨æ–­

```typescript
// æ¨¡æ‹Ÿ Vue ç»„ä»¶ props æ¨æ–­
type ExtractProps<T> = T extends { props: infer P } ? P : {}

type ExtractEmits<T> = T extends { emits: infer E } ? E : {}

const component = {
  props: {
    title: String,
    count: Number,
  },
  emits: ['update', 'delete'],
}

type Props = ExtractProps<typeof component>
// { title: StringConstructor; count: NumberConstructor }
```

### æŸ¯é‡ŒåŒ–ç±»å‹

```typescript
// å‡½æ•°æŸ¯é‡ŒåŒ–ç±»å‹
type Curry<F> = F extends (...args: infer A) => infer R
  ? A extends [infer First, ...infer Rest]
    ? (arg: First) => Curry<(...args: Rest) => R>
    : R
  : never

function add(a: number, b: number, c: number): number {
  return a + b + c
}

type CurriedAdd = Curry<typeof add>
// (arg: number) => (arg: number) => (arg: number) => number
```

## å¸¸è§é—®é¢˜

### ğŸ™‹ infer å¯ä»¥åœ¨ extends ä¹‹å¤–ä½¿ç”¨å—ï¼Ÿ

```typescript
// âŒ é”™è¯¯ï¼šinfer åªèƒ½åœ¨æ¡ä»¶ç±»å‹çš„ extends å­å¥ä¸­ä½¿ç”¨
// type Wrong<T> = infer U;

// âœ… æ­£ç¡®
type Right<T> = T extends infer U ? U : never
```

### ğŸ™‹ å¤šä¸ª infer åŒåä¼šæ€æ ·ï¼Ÿ

```typescript
// åŒå infer ä¼šè¢«æ¨æ–­ä¸ºè”åˆç±»å‹
type Foo<T> = T extends { a: infer U; b: infer U } ? U : never

type Result = Foo<{ a: string; b: number }>
// string | number

// åå˜ä½ç½®ï¼šè”åˆ
type Bar<T> = T extends { a: (x: infer U) => void; b: (x: infer U) => void }
  ? U
  : never

type Result2 = Bar<{ a: (x: string) => void; b: (x: number) => void }>
// string & number = neverï¼ˆé€†å˜ä½ç½®ï¼‰
```

### ğŸ™‹ å¦‚ä½•æ¨æ–­å­—é¢é‡ç±»å‹ï¼Ÿ

```typescript
// ä½¿ç”¨ const æ–­è¨€ä¿ç•™å­—é¢é‡ç±»å‹
function createConfig<T extends string>(key: T) {
  return { key }
}

const config = createConfig('api-key' as const)
// { key: 'api-key' }

// åœ¨ infer ä¸­æ¨æ–­å­—é¢é‡
type ExtractLiteral<T> = T extends `${infer L}` ? L : never

type Lit = ExtractLiteral<'hello'>
// 'hello'
```

## æ€»ç»“

| ç”¨é€”         | è¯­æ³•                        | ç¤ºä¾‹                 |
| ------------ | --------------------------- | -------------------- |
| æå–è¿”å›å€¼   | `(...args) => infer R`      | `ReturnType<T>`      |
| æå–å‚æ•°     | `(...args: infer P) => any` | `Parameters<T>`      |
| æå–æ•°ç»„å…ƒç´  | `(infer E)[]`               | `ElementType<T>`     |
| æå– Promise | `Promise<infer U>`          | `Awaited<T>`         |
| æå–å®ä¾‹     | `new (...args) => infer R`  | `InstanceType<T>`    |
| æå–å…ƒç»„     | `[infer H, ...infer T]`     | `Head<T>`, `Tail<T>` |

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†å­¦ä¹ æ¨¡æ¿å­—é¢é‡ç±»å‹ï¼Œäº†è§£å¦‚ä½•åœ¨ç±»å‹å±‚é¢æ“ä½œå­—ç¬¦ä¸²ã€‚
