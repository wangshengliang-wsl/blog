---
title: Google验证登录
titleIcon: logos:google-icon
description: Google验证登录
pubDate: 2025-11-17
toc: true
ogImage: true
category: 杂谈
---

最近在做用户系统，需要接入第三方登录。Google OAuth 算是比较常用的方案，流程虽然不复杂，但配置稍微复杂一点，特别是 Google Cloud Console 那一堆设置，第一次用确实容易懵。趁着刚踩完坑，把完整的流程和代码整理出来，给同样在对接 Google 登录的朋友参考。

![Google OAuth 授权流程](https://images.unsplash.com/photo-1573804633927-bfcbcd909acd?auto=format&fit=crop&w=1200&q=80)

## Google OAuth 的特点

Google OAuth 基于 OAuth 2.0 标准，但有一些自己的特色：

1. **OpenID Connect 支持**：Google 支持 OpenID Connect，可以直接获取 ID token，里面包含用户信息，不用再单独调 API。
2. **Scope 更细粒度**：Google 的 scope 分得很细，`openid`、`email`、`profile` 是分开的，可以按需申请。
3. **授权页面可定制**：可以在 Google Cloud Console 配置授权页面的品牌信息，用户体验更好。
4. **审核机制**：如果申请敏感权限（比如访问 Gmail），需要经过 Google 审核。

整体流程就是：跳转授权 → 获取 code → 换 token → 拿用户信息。

## Google OAuth 完整流程

### 第一步：在 Google Cloud Console 创建 OAuth 2.0 客户端

首先得去 Google Cloud Console 创建项目：

1. 打开 [Google Cloud Console](https://console.cloud.google.com/)
2. 创建新项目或选择现有项目
3. 启用 **Google+ API**（虽然 Google+ 已经关闭，但 OAuth 还是需要这个 API）
4. 进入 **API 和服务** → **凭据**
5. 点击 **创建凭据** → **OAuth 客户端 ID**
6. 如果第一次创建，需要先配置 **OAuth 同意屏幕**：
   - 选择用户类型（内部/外部）
   - 填写应用名称、支持邮箱、应用 Logo 等
   - 添加测试用户（如果应用还在测试阶段）
7. 创建 OAuth 客户端 ID：
   - **应用类型**：选择"网页应用"
   - **名称**：随便起个名字
   - **已授权的 JavaScript 来源**：你的网站域名，比如 `https://example.com`
   - **已授权的重定向 URI**：回调地址，比如 `https://example.com/api/auth/callback/google`

创建完会给你 `Client ID` 和 `Client Secret`，这两个后面会用到。**注意：Client Secret 只显示一次，记得保存好。**

![Google Cloud Console OAuth 配置](https://images.unsplash.com/photo-1558494949-ef010cbdcc31?auto=format&fit=crop&w=1200&q=80)

### 第二步：引导用户跳转到 Google 授权页

用户点击"用 Google 登录"按钮时，需要跳转到 Google 的授权页面：

```
https://accounts.google.com/o/oauth2/v2/auth?
  client_id=YOUR_CLIENT_ID&
  redirect_uri=YOUR_CALLBACK_URL&
  response_type=code&
  scope=openid%20email%20profile&
  state=RANDOM_STRING&
  access_type=offline&
  prompt=consent
```

参数说明：

- `client_id`：你的 Client ID
- `redirect_uri`：回调地址，必须和注册时填的一样
- `response_type`：固定为 `code`（授权码模式）
- `scope`：请求的权限范围，`openid email profile` 表示获取用户基本信息和邮箱
- `state`：随机字符串，用来防止 CSRF 攻击，建议用 UUID
- `access_type`：`offline` 表示需要 refresh_token（用于长期访问），`online` 表示只要 access_token
- `prompt`：`consent` 表示强制显示授权页面，`none` 表示静默授权（如果用户已授权过）

前端代码示例：

```tsx
// 前端跳转逻辑
const handleGoogleLogin = () => {
  const clientId = process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID
  const redirectUri = `${window.location.origin}/api/auth/callback/google`
  const state = crypto.randomUUID() // 生成随机 state

  // 把 state 存到 localStorage，回调时验证
  localStorage.setItem('google_oauth_state', state)

  const params = new URLSearchParams({
    client_id: clientId!,
    redirect_uri: redirectUri,
    response_type: 'code',
    scope: 'openid email profile',
    state: state,
    access_type: 'offline', // 获取 refresh_token
    prompt: 'consent', // 强制显示授权页面
  })

  window.location.href = `https://accounts.google.com/o/oauth2/v2/auth?${params}`
}
```

### 第三步：Google 回调并返回授权码

用户确认授权后，Google 会跳转回你的回调地址，并带上 `code` 和 `state`：

```
https://example.com/api/auth/callback/google?code=xxx&state=xxx
```

如果用户拒绝授权，会带上 `error` 参数：

```
https://example.com/api/auth/callback/google?error=access_denied&state=xxx
```

这时候需要：

1. 验证 `state` 是否匹配（防止 CSRF）
2. 检查是否有 `error` 参数
3. 用 `code` 去换 `access_token` 和 `refresh_token`

### 第四步：用授权码换取 Access Token

拿到 `code` 后，需要调用 Google Token API 换取 `access_token`：

```ts
// Next.js API Route 示例
// app/api/auth/callback/google/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  const code = searchParams.get('code')
  const state = searchParams.get('state')
  const error = searchParams.get('error')

  // 检查用户是否拒绝授权
  if (error) {
    return NextResponse.redirect(
      new URL('/login?error=access_denied', request.url)
    )
  }

  // 验证 state（从 cookie 或 session 中获取）
  const savedState = request.cookies.get('google_oauth_state')?.value
  if (state !== savedState) {
    return NextResponse.json({ error: 'Invalid state' }, { status: 400 })
  }

  // 用 code 换 access_token
  const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: new URLSearchParams({
      client_id: process.env.GOOGLE_CLIENT_ID!,
      client_secret: process.env.GOOGLE_CLIENT_SECRET!,
      code: code!,
      grant_type: 'authorization_code',
      redirect_uri: `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/callback/google`,
    }),
  })

  const tokenData = await tokenResponse.json()

  if (tokenData.error) {
    return NextResponse.json(
      { error: tokenData.error_description || 'Failed to get access token' },
      { status: 400 }
    )
  }

  const { access_token, refresh_token, id_token } = tokenData

  // 方法一：使用 ID token（推荐，因为包含用户信息）
  if (id_token) {
    // 解析 ID token（需要验证签名，这里简化处理）
    const userInfo = parseIdToken(id_token)
    // 或者直接调用用户信息 API
  }

  // 方法二：用 access_token 获取用户信息
  const userResponse = await fetch(
    'https://www.googleapis.com/oauth2/v3/userinfo',
    {
      headers: {
        Authorization: `Bearer ${access_token}`,
      },
    }
  )

  const userData = await userResponse.json()

  // 这里应该创建或更新用户，设置 session
  // 伪代码示例
  // const user = await createOrUpdateUser({
  //   googleId: userData.sub,
  //   email: userData.email,
  //   name: userData.name,
  //   avatar: userData.picture,
  // })
  // await setSession(user)

  // 重定向到首页或仪表板
  return NextResponse.redirect(new URL('/', request.url))
}

// 解析 ID token（简化版，生产环境需要验证签名）
function parseIdToken(idToken: string) {
  const parts = idToken.split('.')
  const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString('utf-8'))
  return payload
}
```

### 第五步：获取用户信息

Google 返回的用户信息包括：

- `sub`：Google 用户 ID（subject）
- `email`：邮箱地址
- `email_verified`：邮箱是否已验证
- `name`：显示名称
- `picture`：头像地址
- `given_name`：名
- `family_name`：姓
- `locale`：语言设置

如果使用 ID token，这些信息都在 token 的 payload 里，不需要再调 API。如果使用 access_token，需要调用 `https://www.googleapis.com/oauth2/v3/userinfo` 获取。

## 完整代码示例

这里给一个 Next.js 的完整实现：

```ts
// app/api/auth/google/route.ts - 发起授权
import { NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function GET() {
  const clientId = process.env.GOOGLE_CLIENT_ID
  const redirectUri = `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/callback/google`
  const state = crypto.randomUUID()

  // 把 state 存到 cookie
  cookies().set('google_oauth_state', state, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 600, // 10 分钟
  })

  const params = new URLSearchParams({
    client_id: clientId!,
    redirect_uri: redirectUri,
    response_type: 'code',
    scope: 'openid email profile',
    state: state,
    access_type: 'offline', // 获取 refresh_token
    prompt: 'consent', // 强制显示授权页面
  })

  return NextResponse.redirect(
    `https://accounts.google.com/o/oauth2/v2/auth?${params}`
  )
}
```

```ts
// app/api/auth/callback/google/route.ts - 处理回调
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'
import jwt from 'jsonwebtoken'

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  const code = searchParams.get('code')
  const state = searchParams.get('state')
  const error = searchParams.get('error')

  // 检查用户是否拒绝授权
  if (error) {
    return NextResponse.redirect(
      new URL('/login?error=access_denied', request.url)
    )
  }

  // 验证 state
  const savedState = cookies().get('google_oauth_state')?.value
  cookies().delete('google_oauth_state')

  if (!code || state !== savedState) {
    return NextResponse.redirect(
      new URL('/login?error=invalid_state', request.url)
    )
  }

  try {
    // 换取 access_token
    const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        client_id: process.env.GOOGLE_CLIENT_ID!,
        client_secret: process.env.GOOGLE_CLIENT_SECRET!,
        code: code,
        grant_type: 'authorization_code',
        redirect_uri: `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/callback/google`,
      }),
    })

    const tokenData = await tokenResponse.json()

    if (tokenData.error) {
      throw new Error(
        tokenData.error_description || 'Failed to get access token'
      )
    }

    const { access_token, refresh_token, id_token } = tokenData

    // 解析 ID token 获取用户信息（推荐方式）
    let userData
    if (id_token) {
      // 注意：生产环境需要验证 ID token 的签名
      // 这里简化处理，直接解析 payload
      const parts = id_token.split('.')
      const payload = JSON.parse(
        Buffer.from(parts[1], 'base64').toString('utf-8')
      )
      userData = {
        sub: payload.sub,
        email: payload.email,
        email_verified: payload.email_verified,
        name: payload.name,
        picture: payload.picture,
        given_name: payload.given_name,
        family_name: payload.family_name,
      }
    } else {
      // 如果没有 ID token，用 access_token 获取用户信息
      const userResponse = await fetch(
        'https://www.googleapis.com/oauth2/v3/userinfo',
        {
          headers: {
            Authorization: `Bearer ${access_token}`,
          },
        }
      )
      userData = await userResponse.json()
    }

    // 创建或更新用户（这里需要根据你的数据库实现）
    // const user = await upsertUser({
    //   googleId: userData.sub,
    //   email: userData.email,
    //   name: userData.name,
    //   avatar: userData.picture,
    //   emailVerified: userData.email_verified,
    // })

    // 保存 refresh_token（用于后续刷新 access_token）
    // await saveRefreshToken(user.id, refresh_token)

    // 设置 session（这里需要根据你的认证方案实现）
    // await setSession(user)

    // 重定向到首页
    return NextResponse.redirect(new URL('/', request.url))
  } catch (error) {
    console.error('Google OAuth error:', error)
    return NextResponse.redirect(
      new URL('/login?error=oauth_failed', request.url)
    )
  }
}
```

前端调用：

```tsx
// components/google-login-button.tsx
'use client'

export function GoogleLoginButton() {
  const handleClick = () => {
    window.location.href = '/api/auth/google'
  }

  return (
    <button
      onClick={handleClick}
      className="flex items-center gap-2 px-4 py-2 bg-white text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50 shadow-sm"
    >
      <svg className="w-5 h-5" viewBox="0 0 24 24">
        <path
          fill="#4285F4"
          d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
        />
        <path
          fill="#34A853"
          d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
        />
        <path
          fill="#FBBC05"
          d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
        />
        <path
          fill="#EA4335"
          d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
        />
      </svg>
      用 Google 登录
    </button>
  )
}
```

## Refresh Token 的使用

Google 的 `access_token` 默认 1 小时过期，如果要做长期登录，需要用 `refresh_token` 刷新：

```ts
// 刷新 access_token
async function refreshAccessToken(refreshToken: string) {
  const response = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: new URLSearchParams({
      client_id: process.env.GOOGLE_CLIENT_ID!,
      client_secret: process.env.GOOGLE_CLIENT_SECRET!,
      refresh_token: refreshToken,
      grant_type: 'refresh_token',
    }),
  })

  const data = await response.json()
  return data.access_token
}
```

**注意**：`refresh_token` 只在用户第一次授权时返回（如果 `prompt=consent`），后续授权不会返回新的 `refresh_token`，除非用户撤销授权后重新授权。

## 环境变量配置

记得在 `.env.local` 里配置这些变量：

```bash
GOOGLE_CLIENT_ID=your_client_id
GOOGLE_CLIENT_SECRET=your_client_secret
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

生产环境记得把 `NEXT_PUBLIC_APP_URL` 改成你的域名。

## 常见问题和踩坑

**OAuth 同意屏幕配置**：第一次创建 OAuth 客户端时，Google 会要求配置 OAuth 同意屏幕。如果应用还在测试阶段，记得添加测试用户，否则只有项目所有者能登录。

**重定向 URI 不匹配**：Google 对重定向 URI 要求很严格，必须完全匹配，包括协议、域名、端口、路径。本地开发用 `http://localhost:3000`，生产环境用 `https://example.com`，记得分别添加到已授权的重定向 URI。

**Refresh Token 不返回**：如果 `access_type=offline` 但没返回 `refresh_token`，可能是因为用户之前已经授权过了。需要设置 `prompt=consent` 强制显示授权页面，或者让用户先撤销授权。

**ID Token 验证**：生产环境使用 ID token 时，一定要验证签名，防止被伪造。可以用 Google 的公钥验证，或者用 `google-auth-library` 这样的库。

**Scope 权限不足**：如果申请的 scope 不够，用户信息可能不完整。比如只申请 `email` 不申请 `profile`，就拿不到 `name` 和 `picture`。

**测试用户限制**：如果应用还在测试阶段，只有添加到测试用户列表的用户才能登录。应用发布后，所有用户都能用。

**Rate Limit**：Google OAuth API 有速率限制，但一般不会触发，除非你的应用用户量特别大。

## 安全建议

1. **永远不要把 Client Secret 暴露到前端**：Secret 只能放在服务端，前端只用 Client ID。
2. **State 参数必须验证**：防止 CSRF 攻击，每次授权都生成新的 state。
3. **HTTPS 必须**：生产环境一定要用 HTTPS，否则 token 可能被中间人攻击。
4. **验证 ID Token 签名**：如果使用 ID token，一定要验证签名，防止被伪造。
5. **Token 存储安全**：access_token 和 refresh_token 存到数据库要加密，或者用 session 管理。
6. **定期刷新 Token**：access_token 过期前用 refresh_token 刷新，避免用户频繁重新登录。

## 总结

Google OAuth 流程虽然看起来步骤多，但实现起来其实不复杂。核心流程就是：跳转授权 → 获取 code → 换 token → 拿用户信息 → 创建会话。

第一次对接可能会在 OAuth 同意屏幕配置、重定向 URI 匹配、refresh_token 获取这些地方卡住，但踩过一次坑就顺了。如果你们也在做第三方登录，Google OAuth 算是个不错的选择，特别是需要长期登录的场景，refresh_token 用起来很方便。

如果你也在对接 Google OAuth，或者有其他第三方登录的踩坑经验，欢迎在评论区分享，大家一起避坑。
