---
title: Github验证登录
titleIcon: skill-icons:github-dark
description: Github验证登录
pubDate: 2025-11-17
toc: true
ogImage: true
category: 杂谈
---

最近在做用户系统，需要接入第三方登录。GitHub OAuth 算是开发者最常用的方案之一，流程虽然不复杂，但第一次对接的时候还是踩了不少坑。趁着记忆还新鲜，把完整的授权流程和代码实现整理出来，给同样在折腾第三方登录的朋友参考。

![GitHub OAuth 授权流程](https://images.unsplash.com/photo-1618401471353-b98afee0b2eb?auto=format&fit=crop&w=1200&q=80)

## OAuth 2.0 是什么

简单说，OAuth 2.0 就是一套授权标准，让你不用把密码给第三方应用，就能授权它访问你的资源。GitHub OAuth 就是基于这个标准实现的。

整个流程大概是这样：用户点击"用 GitHub 登录"，跳转到 GitHub 授权页面，用户确认后，GitHub 会给你一个授权码（code），然后你用这个 code 去换 access_token，有了 token 就能调用 GitHub API 获取用户信息了。

听起来有点绕，但用起来其实挺顺手的。

## GitHub OAuth 完整流程

### 第一步：在 GitHub 创建 OAuth App

首先得去 GitHub 注册一个 OAuth App：

1. 打开 [GitHub Developer Settings](https://github.com/settings/developers)
2. 点击 **New OAuth App**
3. 填写应用信息：
   - **Application name**：你的应用名称
   - **Homepage URL**：你的网站地址，比如 `https://example.com`
   - **Authorization callback URL**：回调地址，比如 `https://example.com/api/auth/callback/github`
4. 点击 **Register application**

注册完会给你 `Client ID` 和 `Client Secret`，这两个后面会用到。**注意：Client Secret 只显示一次，记得保存好。**

![GitHub OAuth App 创建页面](https://images.unsplash.com/photo-1551650975-87deedd944c3?auto=format&fit=crop&w=1200&q=80)

### 第二步：引导用户跳转到 GitHub 授权页

用户点击"用 GitHub 登录"按钮时，需要跳转到 GitHub 的授权页面：

```
https://github.com/login/oauth/authorize?
  client_id=YOUR_CLIENT_ID&
  redirect_uri=YOUR_CALLBACK_URL&
  scope=user:email&
  state=RANDOM_STRING
```

参数说明：

- `client_id`：你的 Client ID
- `redirect_uri`：回调地址，必须和注册时填的一样
- `scope`：请求的权限范围，`user:email` 表示获取用户邮箱
- `state`：随机字符串，用来防止 CSRF 攻击，建议用 UUID

前端代码示例：

```tsx
// 前端跳转逻辑
const handleGitHubLogin = () => {
  const clientId = process.env.NEXT_PUBLIC_GITHUB_CLIENT_ID
  const redirectUri = `${window.location.origin}/api/auth/callback/github`
  const state = crypto.randomUUID() // 生成随机 state

  // 把 state 存到 localStorage，回调时验证
  localStorage.setItem('github_oauth_state', state)

  const params = new URLSearchParams({
    client_id: clientId!,
    redirect_uri: redirectUri,
    scope: 'user:email',
    state: state,
  })

  window.location.href = `https://github.com/login/oauth/authorize?${params}`
}
```

### 第三步：GitHub 回调并返回授权码

用户确认授权后，GitHub 会跳转回你的回调地址，并带上 `code` 和 `state`：

```
https://example.com/api/auth/callback/github?code=xxx&state=xxx
```

这时候需要：

1. 验证 `state` 是否匹配（防止 CSRF）
2. 用 `code` 去换 `access_token`

### 第四步：用授权码换取 Access Token

拿到 `code` 后，需要调用 GitHub API 换取 `access_token`：

```ts
// Next.js API Route 示例
// app/api/auth/callback/github/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  const code = searchParams.get('code')
  const state = searchParams.get('state')

  // 验证 state（从 cookie 或 session 中获取）
  const savedState = request.cookies.get('github_oauth_state')?.value
  if (state !== savedState) {
    return NextResponse.json({ error: 'Invalid state' }, { status: 400 })
  }

  // 用 code 换 access_token
  const tokenResponse = await fetch(
    'https://github.com/login/oauth/access_token',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({
        client_id: process.env.GITHUB_CLIENT_ID,
        client_secret: process.env.GITHUB_CLIENT_SECRET,
        code: code,
      }),
    }
  )

  const tokenData = await tokenResponse.json()
  const accessToken = tokenData.access_token

  if (!accessToken) {
    return NextResponse.json(
      { error: 'Failed to get access token' },
      { status: 400 }
    )
  }

  // 用 access_token 获取用户信息
  const userResponse = await fetch('https://api.github.com/user', {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/json',
    },
  })

  const userData = await userResponse.json()

  // 获取用户邮箱（需要额外请求）
  const emailResponse = await fetch('https://api.github.com/user/emails', {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/json',
    },
  })

  const emails = await emailResponse.json()
  const primaryEmail =
    emails.find((email: any) => email.primary)?.email || emails[0]?.email

  // 这里应该创建或更新用户，设置 session
  // 伪代码示例
  // const user = await createOrUpdateUser({
  //   githubId: userData.id,
  //   username: userData.login,
  //   email: primaryEmail,
  //   avatar: userData.avatar_url,
  // })
  // await setSession(user)

  // 重定向到首页或仪表板
  return NextResponse.redirect(new URL('/', request.url))
}
```

### 第五步：获取用户信息并创建会话

拿到 `access_token` 后，就可以调用 GitHub API 获取用户信息了。主要用到两个接口：

1. **获取用户基本信息**：`GET https://api.github.com/user`
2. **获取用户邮箱**：`GET https://api.github.com/user/emails`

用户信息包括：

- `id`：GitHub 用户 ID
- `login`：用户名
- `name`：显示名称
- `email`：邮箱（需要单独请求）
- `avatar_url`：头像地址

拿到这些信息后，就可以在你的系统中创建或更新用户，然后设置登录会话了。

## 完整代码示例

这里给一个 Next.js 的完整实现：

```ts
// app/api/auth/github/route.ts - 发起授权
import { NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function GET() {
  const clientId = process.env.GITHUB_CLIENT_ID
  const redirectUri = `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/callback/github`
  const state = crypto.randomUUID()

  // 把 state 存到 cookie
  cookies().set('github_oauth_state', state, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 600, // 10 分钟
  })

  const params = new URLSearchParams({
    client_id: clientId!,
    redirect_uri: redirectUri,
    scope: 'user:email',
    state: state,
  })

  return NextResponse.redirect(
    `https://github.com/login/oauth/authorize?${params}`
  )
}
```

```ts
// app/api/auth/callback/github/route.ts - 处理回调
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  const code = searchParams.get('code')
  const state = searchParams.get('state')

  // 验证 state
  const savedState = cookies().get('github_oauth_state')?.value
  cookies().delete('github_oauth_state')

  if (!code || state !== savedState) {
    return NextResponse.redirect(
      new URL('/login?error=invalid_state', request.url)
    )
  }

  try {
    // 换取 access_token
    const tokenResponse = await fetch(
      'https://github.com/login/oauth/access_token',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: JSON.stringify({
          client_id: process.env.GITHUB_CLIENT_ID,
          client_secret: process.env.GITHUB_CLIENT_SECRET,
          code: code,
        }),
      }
    )

    const tokenData = await tokenResponse.json()

    if (tokenData.error) {
      throw new Error(
        tokenData.error_description || 'Failed to get access token'
      )
    }

    const accessToken = tokenData.access_token

    // 获取用户信息
    const [userResponse, emailResponse] = await Promise.all([
      fetch('https://api.github.com/user', {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: 'application/json',
        },
      }),
      fetch('https://api.github.com/user/emails', {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: 'application/json',
        },
      }),
    ])

    const userData = await userResponse.json()
    const emails = await emailResponse.json()
    const primaryEmail =
      emails.find((email: any) => email.primary)?.email || emails[0]?.email

    // 创建或更新用户（这里需要根据你的数据库实现）
    // const user = await upsertUser({
    //   githubId: userData.id.toString(),
    //   username: userData.login,
    //   email: primaryEmail,
    //   name: userData.name || userData.login,
    //   avatar: userData.avatar_url,
    // })

    // 设置 session（这里需要根据你的认证方案实现）
    // await setSession(user)

    // 重定向到首页
    return NextResponse.redirect(new URL('/', request.url))
  } catch (error) {
    console.error('GitHub OAuth error:', error)
    return NextResponse.redirect(
      new URL('/login?error=oauth_failed', request.url)
    )
  }
}
```

前端调用：

```tsx
// components/github-login-button.tsx
'use client'

export function GitHubLoginButton() {
  const handleClick = () => {
    window.location.href = '/api/auth/github'
  }

  return (
    <button
      onClick={handleClick}
      className="flex items-center gap-2 px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800"
    >
      <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
      </svg>
      用 GitHub 登录
    </button>
  )
}
```

## 环境变量配置

记得在 `.env.local` 里配置这些变量：

```bash
GITHUB_CLIENT_ID=your_client_id
GITHUB_CLIENT_SECRET=your_client_secret
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

生产环境记得把 `NEXT_PUBLIC_APP_URL` 改成你的域名。

## 常见问题和踩坑

**State 验证失败**：最常见的问题。记得把 `state` 存到 cookie 或 session 里，回调时验证。我们一开始用 localStorage，结果服务端读不到，改成 cookie 就好了。

**Callback URL 不匹配**：GitHub 要求回调地址必须和注册时填的一模一样，包括协议（http/https）、域名、端口。本地开发用 `http://localhost:3000`，生产环境用 `https://example.com`，记得分别注册两个 OAuth App。

**Scope 权限不足**：如果只需要邮箱，用 `user:email` 就够了。如果需要访问仓库，用 `repo`。权限越少越好，减少用户顾虑。

**Access Token 过期**：GitHub 的 access_token 默认不过期，但如果用户撤销了授权，token 就失效了。如果要做长期登录，建议存到数据库，失效时重新授权。

**邮箱可能为空**：GitHub 用户可能没有公开邮箱，或者邮箱是私有的。记得处理这种情况，可以提示用户绑定邮箱，或者用 GitHub ID 作为唯一标识。

**Rate Limit**：GitHub API 有速率限制，未认证请求每小时 60 次，认证后 5000 次。如果用户量大，记得做缓存或者用 webhook。

## 安全建议

1. **永远不要把 Client Secret 暴露到前端**：Secret 只能放在服务端，前端只用 Client ID。
2. **State 参数必须验证**：防止 CSRF 攻击，每次授权都生成新的 state。
3. **HTTPS 必须**：生产环境一定要用 HTTPS，否则 token 可能被中间人攻击。
4. **Token 存储安全**：access_token 存到数据库要加密，或者用 session 管理，不要放到 cookie 里。
5. **定期检查授权**：可以定期调用 GitHub API 验证 token 是否还有效。

## 总结

GitHub OAuth 流程虽然看起来步骤多，但实现起来其实不复杂。核心就是：跳转授权 → 获取 code → 换 token → 拿用户信息 → 创建会话。

第一次对接可能会在 state 验证、callback URL 这些地方卡住，但踩过一次坑就顺了。如果你们也在做第三方登录，GitHub OAuth 算是个不错的起点，文档清晰，社区支持也多。

如果你也在对接 GitHub OAuth，或者有其他第三方登录的踩坑经验，欢迎在评论区分享，大家一起避坑。
