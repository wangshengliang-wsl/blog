---
title: MCP生产实践：安全、性能与可维护性
description: 总结MCP开发的最佳实践，涵盖安全防护、性能优化、日志监控与生产部署策略，构建企业级MCP服务
pubDate: 2025-12-15
toc: true
ogImage: true
category: MCP
---

系列的最后一篇，总结 MCP Server 开发的最佳实践：安全、性能、可维护性、测试和部署。

## 安全最佳实践

MCP Server 可能接收来自大模型的任意输入，安全必须放在首位。

### 输入校验

永远不要信任输入，即使它来自大模型：

```typescript
import { z } from 'zod'

// 定义严格的 Schema
const FilePathSchema = z
  .string()
  .max(500)
  .refine((path) => !path.includes('..'), { message: '路径不能包含 ..' })
  .refine((path) => !path.startsWith('/'), { message: '必须使用相对路径' })

server.tool(
  'read_file',
  '读取文件',
  { path: FilePathSchema.describe('文件路径') },
  async ({ path }) => {
    // path 已经通过校验
  }
)
```

### 路径遍历防护

文件操作是重灾区：

```typescript
import path from 'path'

const ALLOWED_DIR = process.env.ALLOWED_DIR || process.cwd()

function safePath(userPath: string): string {
  // 规范化路径
  const normalized = path.normalize(userPath)

  // 解析为绝对路径
  const resolved = path.resolve(ALLOWED_DIR, normalized)

  // 检查是否在允许目录内
  if (!resolved.startsWith(path.resolve(ALLOWED_DIR) + path.sep)) {
    throw new Error('Access denied: path outside allowed directory')
  }

  return resolved
}

// 使用
server.tool(
  'read_file',
  '读取文件',
  { path: z.string() },
  async ({ path: userPath }) => {
    const safeFsPath = safePath(userPath)
    const content = await fs.readFile(safeFsPath, 'utf-8')
    // ...
  }
)
```

### 命令注入防护

如果需要执行命令，避免拼接字符串：

```typescript
import { execFile } from 'child_process'
import { promisify } from 'util'

const execFileAsync = promisify(execFile)

// ❌ 危险：命令注入
async function dangerous(filename: string) {
  await exec(`cat ${filename}`) // filename 可能是 "; rm -rf /"
}

// ✅ 安全：使用 execFile
async function safe(filename: string) {
  const { stdout } = await execFileAsync('cat', [filename])
  return stdout
}
```

### 敏感信息处理

API Key、密码等敏感信息：

```typescript
// 从环境变量读取，不要硬编码
const API_KEY = process.env.API_KEY

if (!API_KEY) {
  console.error('错误: 缺少 API_KEY 环境变量')
  process.exit(1)
}

// 日志中脱敏
function maskSecret(value: string): string {
  if (value.length <= 8) return '****'
  return value.slice(0, 4) + '****' + value.slice(-4)
}

console.error(`使用 API Key: ${maskSecret(API_KEY)}`)

// 错误信息不要暴露敏感细节
server.tool('api_call', '调用 API', {}, async () => {
  try {
    const result = await callExternalAPI(API_KEY)
    return { content: [{ type: 'text', text: result }] }
  } catch (error) {
    // ❌ 不要这样
    // return { content: [{ type: 'text', text: error.message }], isError: true }

    // ✅ 脱敏处理
    console.error('API 调用失败:', error)
    return {
      content: [{ type: 'text', text: 'API 调用失败，请稍后重试' }],
      isError: true,
    }
  }
})
```

### 权限控制

按需限制操作范围：

```typescript
interface Permission {
  canRead: boolean
  canWrite: boolean
  canDelete: boolean
  allowedDirs: string[]
}

const permissions: Permission = {
  canRead: true,
  canWrite: process.env.ALLOW_WRITE === 'true',
  canDelete: false, // 禁止删除
  allowedDirs: (process.env.ALLOWED_DIRS || '.').split(','),
}

server.tool(
  'write_file',
  '写入文件',
  { path: z.string(), content: z.string() },
  async ({ path, content }) => {
    if (!permissions.canWrite) {
      return {
        content: [{ type: 'text', text: '写入操作已禁用' }],
        isError: true,
      }
    }

    // 检查目录权限
    const safeFsPath = safePath(path)
    const allowed = permissions.allowedDirs.some((dir) =>
      safeFsPath.startsWith(path.resolve(dir))
    )

    if (!allowed) {
      return {
        content: [{ type: 'text', text: '不允许写入该目录' }],
        isError: true,
      }
    }

    await fs.writeFile(safeFsPath, content)
    return { content: [{ type: 'text', text: '写入成功' }] }
  }
)
```

## 错误处理与日志

### 结构化日志

使用结构化日志便于分析和监控：

```typescript
type LogLevel = 'debug' | 'info' | 'warn' | 'error'

interface LogEntry {
  level: LogLevel
  message: string
  timestamp: string
  context?: Record<string, unknown>
}

function log(
  level: LogLevel,
  message: string,
  context?: Record<string, unknown>
) {
  const entry: LogEntry = {
    level,
    message,
    timestamp: new Date().toISOString(),
    context,
  }

  // 输出到 stderr（不污染 MCP 协议通信）
  console.error(JSON.stringify(entry))
}

// 使用
log('info', 'Server started', { port: 3000 })
log('error', 'Tool execution failed', {
  tool: 'read_file',
  error: 'File not found',
})
```

### 请求追踪

为每个请求分配 ID，便于追踪：

```typescript
import { randomUUID } from 'crypto'

// 包装工具处理器
function withRequestId<T>(
  handler: (args: T, requestId: string) => Promise<any>
) {
  return async (args: T) => {
    const requestId = randomUUID().slice(0, 8)
    log('info', 'Tool called', { requestId, args })

    try {
      const result = await handler(args, requestId)
      log('info', 'Tool completed', { requestId })
      return result
    } catch (error) {
      log('error', 'Tool failed', {
        requestId,
        error: (error as Error).message,
      })
      throw error
    }
  }
}

server.tool(
  'my_tool',
  '工具描述',
  { param: z.string() },
  withRequestId(async ({ param }, requestId) => {
    log('debug', 'Processing', { requestId, param })
    // ...
  })
)
```

### 错误分类

区分不同类型的错误：

```typescript
// 业务错误：返回 isError
function businessError(message: string) {
  return {
    content: [{ type: 'text' as const, text: message }],
    isError: true,
  }
}

// 系统错误：抛出 McpError
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js'

function systemError(message: string): never {
  throw new McpError(ErrorCode.InternalError, message)
}

server.tool('example', '示例', { id: z.string() }, async ({ id }) => {
  // 业务逻辑错误
  if (!isValidId(id)) {
    return businessError('无效的 ID 格式')
  }

  try {
    const data = await fetchData(id)
    if (!data) {
      return businessError('数据不存在')
    }
    return { content: [{ type: 'text', text: JSON.stringify(data) }] }
  } catch (error) {
    // 系统错误
    log('error', 'Database error', { error })
    systemError('服务暂时不可用')
  }
})
```

## 性能优化

### 连接池

复用数据库、HTTP 连接：

```typescript
import { Pool } from 'pg'

// 创建连接池（Server 启动时）
const pool = new Pool({
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  max: 10, // 最大连接数
  idleTimeoutMillis: 30000,
})

server.tool('query', '查询数据库', { sql: z.string() }, async ({ sql }) => {
  // 使用连接池
  const result = await pool.query(sql)
  return { content: [{ type: 'text', text: JSON.stringify(result.rows) }] }
})

// 优雅关闭
process.on('SIGTERM', async () => {
  await pool.end()
  process.exit(0)
})
```

### 缓存

对频繁访问的数据做缓存：

```typescript
interface CacheEntry<T> {
  value: T
  expiresAt: number
}

class SimpleCache<T> {
  private cache = new Map<string, CacheEntry<T>>()
  private ttl: number

  constructor(ttlMs: number = 60000) {
    this.ttl = ttlMs
  }

  get(key: string): T | undefined {
    const entry = this.cache.get(key)
    if (!entry) return undefined
    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key)
      return undefined
    }
    return entry.value
  }

  set(key: string, value: T): void {
    this.cache.set(key, {
      value,
      expiresAt: Date.now() + this.ttl,
    })
  }
}

const configCache = new SimpleCache<string>(5 * 60 * 1000) // 5分钟

server.tool('get_config', '获取配置', { key: z.string() }, async ({ key }) => {
  let value = configCache.get(key)

  if (!value) {
    value = await fetchConfigFromRemote(key)
    configCache.set(key, value)
  }

  return { content: [{ type: 'text', text: value }] }
})
```

### 并发控制

避免同时执行太多操作：

```typescript
class Semaphore {
  private permits: number
  private queue: (() => void)[] = []

  constructor(permits: number) {
    this.permits = permits
  }

  async acquire(): Promise<void> {
    if (this.permits > 0) {
      this.permits--
      return
    }

    return new Promise((resolve) => {
      this.queue.push(resolve)
    })
  }

  release(): void {
    const next = this.queue.shift()
    if (next) {
      next()
    } else {
      this.permits++
    }
  }
}

const apiSemaphore = new Semaphore(5) // 最多 5 个并发 API 调用

server.tool(
  'api_call',
  '调用 API',
  { endpoint: z.string() },
  async ({ endpoint }) => {
    await apiSemaphore.acquire()
    try {
      const result = await fetch(endpoint)
      return { content: [{ type: 'text', text: await result.text() }] }
    } finally {
      apiSemaphore.release()
    }
  }
)
```

## 可维护性设计

### 模块化结构

按功能拆分模块：

```
src/
├── index.ts           # 入口，Server 启动
├── tools/
│   ├── index.ts       # 导出所有 tools
│   ├── file.ts        # 文件操作工具
│   ├── database.ts    # 数据库工具
│   └── api.ts         # API 调用工具
├── resources/
│   └── config.ts      # 配置资源
├── utils/
│   ├── logger.ts      # 日志工具
│   ├── security.ts    # 安全工具
│   └── cache.ts       # 缓存工具
└── config.ts          # 配置管理
```

工具注册：

```typescript
// src/tools/file.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { z } from 'zod'

export function registerFileTools(server: McpServer) {
  server.tool(
    'read_file',
    '读取文件',
    { path: z.string() },
    async ({ path }) => {
      // ...
    }
  )

  server.tool(
    'write_file',
    '写入文件',
    { path: z.string(), content: z.string() },
    async (args) => {
      // ...
    }
  )
}

// src/index.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { registerFileTools } from './tools/file.js'
import { registerDatabaseTools } from './tools/database.js'

const server = new McpServer({ name: 'my-server', version: '1.0.0' })

registerFileTools(server)
registerDatabaseTools(server)
```

### 配置外部化

所有配置通过环境变量：

```typescript
// src/config.ts
import { z } from 'zod'

const ConfigSchema = z.object({
  port: z.coerce.number().default(3000),
  logLevel: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
  allowedDir: z.string().default(process.cwd()),
  dbHost: z.string().optional(),
  dbName: z.string().optional(),
  apiKey: z.string().optional(),
  maxConcurrency: z.coerce.number().default(10),
})

export type Config = z.infer<typeof ConfigSchema>

export function loadConfig(): Config {
  const raw = {
    port: process.env.PORT,
    logLevel: process.env.LOG_LEVEL,
    allowedDir: process.env.ALLOWED_DIR,
    dbHost: process.env.DB_HOST,
    dbName: process.env.DB_NAME,
    apiKey: process.env.API_KEY,
    maxConcurrency: process.env.MAX_CONCURRENCY,
  }

  const result = ConfigSchema.safeParse(raw)

  if (!result.success) {
    console.error('配置错误:', result.error.format())
    process.exit(1)
  }

  return result.data
}
```

## 测试策略

### 单元测试工具处理器

```typescript
// src/tools/file.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import fs from 'fs/promises'
import path from 'path'
import os from 'os'

describe('readFile tool', () => {
  let tempDir: string

  beforeEach(async () => {
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'mcp-test-'))
  })

  afterEach(async () => {
    await fs.rm(tempDir, { recursive: true })
  })

  it('should read file content', async () => {
    const testFile = path.join(tempDir, 'test.txt')
    await fs.writeFile(testFile, 'Hello, MCP!')

    const result = await readFileHandler({ path: 'test.txt' }, tempDir)

    expect(result.content[0].text).toBe('Hello, MCP!')
  })

  it('should return error for non-existent file', async () => {
    const result = await readFileHandler({ path: 'notexist.txt' }, tempDir)

    expect(result.isError).toBe(true)
    expect(result.content[0].text).toContain('不存在')
  })

  it('should prevent path traversal', async () => {
    const result = await readFileHandler(
      { path: '../../../etc/passwd' },
      tempDir
    )

    expect(result.isError).toBe(true)
  })
})
```

### 集成测试

使用 MCP Inspector 或编写端到端测试：

```typescript
// tests/integration.test.ts
import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'
import { describe, it, expect, beforeAll, afterAll } from 'vitest'

describe('MCP Server Integration', () => {
  let client: Client

  beforeAll(async () => {
    client = new Client({ name: 'test', version: '1.0.0' })
    const transport = new StdioClientTransport({
      command: 'node',
      args: ['./dist/index.js'],
      env: { ...process.env, ALLOWED_DIR: './test-fixtures' },
    })
    await client.connect(transport)
  })

  afterAll(async () => {
    await client.close()
  })

  it('should list tools', async () => {
    const result = await client.listTools()
    expect(result.tools.length).toBeGreaterThan(0)
  })

  it('should call read_file tool', async () => {
    const result = await client.callTool({
      name: 'read_file',
      arguments: { path: 'sample.txt' },
    })

    expect(result.content[0].type).toBe('text')
  })
})
```

## 生产部署

### Docker 镜像

```dockerfile
# Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine

WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package.json ./

ENV NODE_ENV=production

# 非 root 用户运行
RUN addgroup -g 1001 -S nodejs && \
    adduser -S mcp -u 1001 -G nodejs
USER mcp

CMD ["node", "dist/index.js"]
```

### 健康检查

HTTP Server 添加健康检查端点：

```typescript
app.get('/health', (req, res) => {
  const health = {
    status: 'ok',
    uptime: process.uptime(),
    timestamp: Date.now(),
    checks: {
      database: checkDatabase(),
      memory: process.memoryUsage().heapUsed < 500 * 1024 * 1024,
    },
  }

  const isHealthy = Object.values(health.checks).every(Boolean)

  res.status(isHealthy ? 200 : 503).json(health)
})
```

### 优雅关闭

```typescript
let isShuttingDown = false

async function gracefulShutdown(signal: string) {
  if (isShuttingDown) return
  isShuttingDown = true

  console.error(`收到 ${signal}，开始优雅关闭...`)

  // 停止接收新请求
  // 等待进行中的请求完成
  // 关闭数据库连接
  // 清理资源

  setTimeout(() => {
    console.error('强制退出')
    process.exit(1)
  }, 30000) // 30秒超时

  try {
    await cleanup()
    console.error('关闭完成')
    process.exit(0)
  } catch (error) {
    console.error('关闭出错:', error)
    process.exit(1)
  }
}

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'))
process.on('SIGINT', () => gracefulShutdown('SIGINT'))
```

### Kubernetes 部署

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-server
spec:
  replicas: 2
  selector:
    matchLabels:
      app: mcp-server
  template:
    metadata:
      labels:
        app: mcp-server
    spec:
      containers:
        - name: mcp-server
          image: your-registry/mcp-server:latest
          ports:
            - containerPort: 3000
          env:
            - name: PORT
              value: '3000'
            - name: API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-secrets
                  key: api-key
          resources:
            requests:
              memory: '128Mi'
              cpu: '100m'
            limits:
              memory: '512Mi'
              cpu: '500m'
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 10
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 10
```

## 总结

MCP 系列到这里就结束了。回顾一下：

| 文章    | 主题               |
| ------- | ------------------ |
| 第 1 篇 | MCP 核心概念与架构 |
| 第 2 篇 | 搭建第一个 Server  |
| 第 3 篇 | Tools 深度解析     |
| 第 4 篇 | Resources 资源管理 |
| 第 5 篇 | Prompts 与资源订阅 |
| 第 6 篇 | HTTP 远程通信      |
| 第 7 篇 | Client 开发与集成  |
| 第 8 篇 | 生产最佳实践       |

MCP 作为 AI 应用与外部世界的桥梁，正在被越来越多的工具和平台采用。掌握 MCP 开发，可以让你的 AI 应用获得无限扩展的能力。

## 参考

- [MCP 官方文档](https://modelcontextprotocol.io/)
- [MCP GitHub](https://github.com/modelcontextprotocol)
- [OWASP Top 10](https://owasp.org/Top10/)
- [Node.js 安全最佳实践](https://nodejs.org/en/docs/guides/security/)
