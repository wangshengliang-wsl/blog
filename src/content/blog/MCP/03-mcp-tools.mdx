---
title: MCP Toolsè¯¦è§£ï¼šè®©AIè°ƒç”¨ä½ çš„ä»£ç 
description: æ·±å…¥ç†è§£MCP Toolsçš„å·¥ä½œæœºåˆ¶ï¼ŒæŒæ¡å‚æ•°æ ¡éªŒã€é”™è¯¯å¤„ç†ã€å¼‚æ­¥æ“ä½œç­‰é«˜çº§ç”¨æ³•ï¼Œæ„å»ºå¥å£®çš„å·¥å…·æœåŠ¡
pubDate: 2025-12-05
toc: true
ogImage: true
category: MCP
---

ä¸Šä¸€ç¯‡ç”¨ `server.tool()` æ³¨å†Œäº†ç®€å•çš„å¤©æ°”æŸ¥è¯¢å·¥å…·ã€‚è¿™ç¯‡æ·±å…¥ Tools çš„å„ç§ç»†èŠ‚ï¼šåè®®è§„èŒƒã€å‚æ•°æ ¡éªŒã€è¿”å›ç±»å‹ã€é”™è¯¯å¤„ç†ï¼Œæœ€åå®ç°ä¸€ä¸ªæ–‡ä»¶æ“ä½œå·¥å…·é›†ã€‚

## Tools åè®®è§„èŒƒ

Client å’Œ Server ä¹‹é—´å…³äº Tools çš„é€šä¿¡æ¶‰åŠä¸¤ä¸ªæ–¹æ³•ï¼š

### tools/list

Client è¯·æ±‚è·å– Server æä¾›çš„æ‰€æœ‰å·¥å…·åˆ—è¡¨ï¼š

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list"
}
```

Server å“åº”ï¼š

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "read_file",
        "description": "è¯»å–æŒ‡å®šè·¯å¾„çš„æ–‡ä»¶å†…å®¹",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "æ–‡ä»¶è·¯å¾„"
            }
          },
          "required": ["path"]
        }
      }
    ]
  }
}
```

`inputSchema` æ˜¯æ ‡å‡†çš„ JSON Schema æ ¼å¼ï¼Œæè¿°å·¥å…·æ¥å—çš„å‚æ•°ç»“æ„ã€‚

### tools/call

Client è¯·æ±‚è°ƒç”¨æŸä¸ªå·¥å…·ï¼š

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "read_file",
    "arguments": {
      "path": "/path/to/file.txt"
    }
  }
}
```

Server å“åº”ï¼š

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "æ–‡ä»¶å†…å®¹..."
      }
    ]
  }
}
```

å¦‚æœæ‰§è¡Œå‡ºé”™ï¼š

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "é”™è¯¯ï¼šæ–‡ä»¶ä¸å­˜åœ¨"
      }
    ],
    "isError": true
  }
}
```

## Zod Schema è¿›é˜¶

MCP SDK ä½¿ç”¨ Zod å®šä¹‰å‚æ•° Schemaï¼ŒSDK ä¼šè‡ªåŠ¨è½¬æ¢æˆ JSON Schemaã€‚Zod çš„å¥½å¤„æ˜¯ç±»å‹å®‰å…¨â€”â€”å®šä¹‰ Schema çš„åŒæ—¶å°±æœ‰äº† TypeScript ç±»å‹æ¨æ–­ã€‚

### åŸºç¡€ç±»å‹

```typescript
import { z } from 'zod'

// å­—ç¬¦ä¸²
z.string()

// æ•°å­—
z.number()

// å¸ƒå°”
z.boolean()

// æšä¸¾
z.enum(['option1', 'option2', 'option3'])

// å­—é¢é‡
z.literal('fixed-value')
```

### æ·»åŠ æè¿°

æ¯ä¸ªå­—æ®µéƒ½åº”è¯¥æœ‰æè¿°ï¼Œè¿™æ˜¯å¤§æ¨¡å‹ç†è§£å‚æ•°ç”¨é€”çš„å…³é”®ï¼š

```typescript
{
  city: z.string().describe('åŸå¸‚åç§°ï¼Œå¦‚"åŒ—äº¬"ã€"ä¸Šæµ·"'),
  unit: z.enum(['celsius', 'fahrenheit']).describe('æ¸©åº¦å•ä½'),
}
```

### å¯é€‰å‚æ•°ä¸é»˜è®¤å€¼

```typescript
{
  // å¯é€‰å‚æ•°
  format: z.string().optional().describe('è¾“å‡ºæ ¼å¼'),

  // å¸¦é»˜è®¤å€¼ï¼ˆæ³¨æ„ï¼šdefault åœ¨ MCP ä¸­ä¸»è¦ç”¨äºç±»å‹æ¨æ–­ï¼Œå®é™…é»˜è®¤å€¼å¤„ç†åœ¨å·¥å…·å‡½æ•°é‡Œï¼‰
  limit: z.number().default(10).describe('è¿”å›æ•°é‡é™åˆ¶'),
}
```

### å¯¹è±¡ä¸åµŒå¥—

```typescript
{
  config: z.object({
    timeout: z.number().describe('è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰'),
    retries: z.number().describe('é‡è¯•æ¬¡æ•°'),
  }).describe('è¯·æ±‚é…ç½®'),
}
```

### æ•°ç»„

```typescript
{
  // å­—ç¬¦ä¸²æ•°ç»„
  tags: z.array(z.string()).describe('æ ‡ç­¾åˆ—è¡¨'),

  // å¯¹è±¡æ•°ç»„
  files: z.array(
    z.object({
      path: z.string(),
      content: z.string(),
    })
  ).describe('æ–‡ä»¶åˆ—è¡¨'),
}
```

### è”åˆç±»å‹

```typescript
{
  // å­—ç¬¦ä¸²æˆ–æ•°å­—
  id: z.union([z.string(), z.number()]).describe('IDï¼Œå¯ä»¥æ˜¯å­—ç¬¦ä¸²æˆ–æ•°å­—'),
}
```

### å®Œæ•´ç¤ºä¾‹

ä¸€ä¸ªå¤æ‚å·¥å…·çš„å‚æ•°å®šä¹‰ï¼š

```typescript
server.tool(
  'search_files',
  'åœ¨æŒ‡å®šç›®å½•ä¸­æœç´¢æ–‡ä»¶',
  {
    directory: z.string().describe('æœç´¢çš„æ ¹ç›®å½•'),
    pattern: z.string().describe('æœç´¢æ¨¡å¼ï¼Œæ”¯æŒé€šé…ç¬¦å¦‚ *.ts'),
    options: z
      .object({
        recursive: z.boolean().default(true).describe('æ˜¯å¦é€’å½’æœç´¢å­ç›®å½•'),
        maxDepth: z.number().optional().describe('æœ€å¤§æœç´¢æ·±åº¦'),
        exclude: z.array(z.string()).optional().describe('æ’é™¤çš„ç›®å½•åˆ—è¡¨'),
      })
      .optional()
      .describe('æœç´¢é€‰é¡¹'),
  },
  async ({ directory, pattern, options }) => {
    // options çš„ç±»å‹è‡ªåŠ¨æ¨æ–­ä¸ºï¼š
    // { recursive: boolean; maxDepth?: number; exclude?: string[] } | undefined
    // ...
  }
)
```

## è¿”å›å€¼ç±»å‹

å·¥å…·è¿”å›å€¼å¿…é¡»æ˜¯ `{ content: ContentItem[] }` æ ¼å¼ã€‚`content` æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ å¯ä»¥æ˜¯ä»¥ä¸‹ç±»å‹ï¼š

### text

æœ€å¸¸ç”¨çš„ç±»å‹ï¼Œè¿”å›æ–‡æœ¬å†…å®¹ï¼š

```typescript
return {
  content: [{ type: 'text', text: 'æ“ä½œæˆåŠŸ' }],
}
```

å¯ä»¥è¿”å›å¤šæ®µæ–‡æœ¬ï¼š

```typescript
return {
  content: [
    { type: 'text', text: '## æœç´¢ç»“æœ' },
    { type: 'text', text: 'æ‰¾åˆ° 3 ä¸ªæ–‡ä»¶ï¼š' },
    { type: 'text', text: '1. /src/index.ts' },
    { type: 'text', text: '2. /src/utils.ts' },
    { type: 'text', text: '3. /src/types.ts' },
  ],
}
```

### image

è¿”å›å›¾ç‰‡ï¼Œä½¿ç”¨ Base64 ç¼–ç ï¼š

```typescript
import fs from 'fs/promises'

server.tool(
  'get_screenshot',
  'è·å–ç½‘é¡µæˆªå›¾',
  { url: z.string().describe('ç½‘é¡µURL') },
  async ({ url }) => {
    // å‡è®¾ captureScreenshot è¿”å›å›¾ç‰‡ Buffer
    const imageBuffer = await captureScreenshot(url)
    const base64 = imageBuffer.toString('base64')

    return {
      content: [
        {
          type: 'image',
          data: base64,
          mimeType: 'image/png',
        },
      ],
    }
  }
)
```

æ”¯æŒçš„å›¾ç‰‡æ ¼å¼ï¼š

- `image/png`
- `image/jpeg`
- `image/gif`
- `image/webp`

### resource

å¼•ç”¨ä¸€ä¸ª MCP Resourceï¼š

```typescript
return {
  content: [
    {
      type: 'resource',
      resource: {
        uri: 'file:///path/to/document.md',
        mimeType: 'text/markdown',
        text: '# æ–‡æ¡£æ ‡é¢˜\n\næ–‡æ¡£å†…å®¹...',
      },
    },
  ],
}
```

è¿™ç§æ–¹å¼å¯ä»¥è®©å·¥å…·è¿”å›ç»“æ„åŒ–çš„èµ„æºæ•°æ®ï¼Œä¾›åç»­å¤„ç†ä½¿ç”¨ã€‚

### æ··åˆè¿”å›

ä¸€ä¸ªè¿”å›å€¼å¯ä»¥åŒ…å«å¤šç§ç±»å‹ï¼š

```typescript
return {
  content: [
    { type: 'text', text: 'æ–‡ä»¶åˆ†æç»“æœï¼š' },
    { type: 'image', data: chartBase64, mimeType: 'image/png' },
    { type: 'text', text: 'è¯¦ç»†æ•°æ®è§ä¸Šå›¾' },
  ],
}
```

## é”™è¯¯å¤„ç†

å·¥å…·æ‰§è¡Œå¤±è´¥æ—¶ï¼Œæœ‰ä¸¤ç§å¤„ç†æ–¹å¼ï¼š

### æ–¹å¼ä¸€ï¼šè¿”å› isError

é€‚ç”¨äºä¸šåŠ¡é€»è¾‘å±‚é¢çš„å¤±è´¥ï¼Œæ¯”å¦‚"æ–‡ä»¶ä¸å­˜åœ¨"ã€"å‚æ•°æ— æ•ˆ"ï¼š

```typescript
server.tool(
  'read_file',
  'è¯»å–æ–‡ä»¶å†…å®¹',
  { path: z.string() },
  async ({ path }) => {
    try {
      const content = await fs.readFile(path, 'utf-8')
      return {
        content: [{ type: 'text', text: content }],
      }
    } catch (error) {
      return {
        content: [
          { type: 'text', text: `æ— æ³•è¯»å–æ–‡ä»¶ï¼š${(error as Error).message}` },
        ],
        isError: true,
      }
    }
  }
)
```

`isError: true` å‘Šè¯‰å¤§æ¨¡å‹è¿™æ¬¡å·¥å…·è°ƒç”¨å¤±è´¥äº†ï¼Œå¤§æ¨¡å‹ä¼šæŠŠé”™è¯¯ä¿¡æ¯è€ƒè™‘è¿›å›å¤ä¸­ã€‚

### æ–¹å¼äºŒï¼šæŠ›å‡ºå¼‚å¸¸

é€‚ç”¨äºä¸å¯æ¢å¤çš„ç³»ç»Ÿé”™è¯¯ï¼š

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js'

server.tool(
  'dangerous_operation',
  'æ‰§è¡Œå±é™©æ“ä½œ',
  { confirm: z.boolean() },
  async ({ confirm }) => {
    if (!confirm) {
      throw new McpError(ErrorCode.InvalidParams, 'å¿…é¡»ç¡®è®¤æ‰èƒ½æ‰§è¡Œæ­¤æ“ä½œ')
    }
    // ...
  }
)
```

MCP å®šä¹‰çš„é”™è¯¯ç ï¼š

| é”™è¯¯ç            | å«ä¹‰         |
| ---------------- | ------------ |
| `InvalidRequest` | è¯·æ±‚æ ¼å¼æ— æ•ˆ |
| `MethodNotFound` | æ–¹æ³•ä¸å­˜åœ¨   |
| `InvalidParams`  | å‚æ•°æ— æ•ˆ     |
| `InternalError`  | å†…éƒ¨é”™è¯¯     |

### é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

1. **ç”¨ `isError` å¤„ç†å¯é¢„æœŸçš„å¤±è´¥**ï¼šæ–‡ä»¶ä¸å­˜åœ¨ã€æƒé™ä¸è¶³ã€æ•°æ®æ ¼å¼é”™è¯¯ç­‰
2. **æŠ›å‡º `McpError` å¤„ç†ä¸å¯æ¢å¤çš„é”™è¯¯**ï¼šé…ç½®é”™è¯¯ã€ç³»ç»Ÿæ•…éšœç­‰
3. **é”™è¯¯ä¿¡æ¯è¦æ¸…æ™°**ï¼šå‘Šè¯‰ç”¨æˆ·å‘ç”Ÿäº†ä»€ä¹ˆã€å¯èƒ½çš„åŸå› ã€å¦‚ä½•è§£å†³
4. **ä¸è¦æš´éœ²æ•æ„Ÿä¿¡æ¯**ï¼šè·¯å¾„ã€å¯†é’¥ã€å†…éƒ¨å®ç°ç»†èŠ‚

```typescript
// âŒ ä¸å¥½çš„é”™è¯¯ä¿¡æ¯
return {
  content: [{ type: 'text', text: 'Error: ENOENT' }],
  isError: true,
}

// âœ… å¥½çš„é”™è¯¯ä¿¡æ¯
return {
  content: [
    {
      type: 'text',
      text: `æ–‡ä»¶ä¸å­˜åœ¨ï¼š${path}\nè¯·æ£€æŸ¥è·¯å¾„æ˜¯å¦æ­£ç¡®ï¼Œæˆ–è€…æ–‡ä»¶æ˜¯å¦å·²è¢«åˆ é™¤ã€‚`,
    },
  ],
  isError: true,
}
```

## å¼‚æ­¥æ“ä½œä¸é•¿æ—¶é—´ä»»åŠ¡

MCP å·¥å…·å¤©ç„¶æ”¯æŒå¼‚æ­¥æ“ä½œã€‚å·¥å…·å‡½æ•°è¿”å› Promiseï¼ŒSDK ä¼šç­‰å¾… Promise å®Œæˆåå†å‘é€å“åº”ã€‚

### åŸºç¡€å¼‚æ­¥

```typescript
server.tool(
  'fetch_data',
  'ä»è¿œç¨‹APIè·å–æ•°æ®',
  { endpoint: z.string() },
  async ({ endpoint }) => {
    const response = await fetch(endpoint)
    const data = await response.json()

    return {
      content: [{ type: 'text', text: JSON.stringify(data, null, 2) }],
    }
  }
)
```

### è¶…æ—¶å¤„ç†

å¯¹äºå¯èƒ½è€—æ—¶è¾ƒé•¿çš„æ“ä½œï¼Œåº”è¯¥è®¾ç½®è¶…æ—¶ï¼š

```typescript
function withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {
  const timeout = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error(`æ“ä½œè¶…æ—¶ï¼ˆ${ms}msï¼‰`)), ms)
  })
  return Promise.race([promise, timeout])
}

server.tool(
  'slow_operation',
  'æ‰§è¡Œè€—æ—¶æ“ä½œ',
  { input: z.string() },
  async ({ input }) => {
    try {
      const result = await withTimeout(
        performSlowOperation(input),
        30000 // 30ç§’è¶…æ—¶
      )
      return {
        content: [{ type: 'text', text: result }],
      }
    } catch (error) {
      return {
        content: [{ type: 'text', text: (error as Error).message }],
        isError: true,
      }
    }
  }
)
```

### å¹¶å‘æ§åˆ¶

å¦‚æœå·¥å…·æ¶‰åŠæ‰¹é‡æ“ä½œï¼Œæ³¨æ„æ§åˆ¶å¹¶å‘ï¼š

```typescript
server.tool(
  'batch_process',
  'æ‰¹é‡å¤„ç†æ–‡ä»¶',
  { files: z.array(z.string()) },
  async ({ files }) => {
    const CONCURRENCY = 5
    const results: string[] = []

    for (let i = 0; i < files.length; i += CONCURRENCY) {
      const batch = files.slice(i, i + CONCURRENCY)
      const batchResults = await Promise.all(
        batch.map((file) => processFile(file))
      )
      results.push(...batchResults)
    }

    return {
      content: [{ type: 'text', text: results.join('\n') }],
    }
  }
)
```

## å®æˆ˜ï¼šæ–‡ä»¶æ“ä½œå·¥å…·é›†

æŠŠå‰é¢çš„çŸ¥è¯†æ•´åˆèµ·æ¥ï¼Œå®ç°ä¸€ä¸ªå®ç”¨çš„æ–‡ä»¶æ“ä½œ MCP Serverï¼š

```typescript
// src/index.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'
import { z } from 'zod'
import fs from 'fs/promises'
import path from 'path'

const server = new McpServer({
  name: 'file-tools',
  version: '1.0.0',
})

// å®‰å…¨çš„è·¯å¾„å¤„ç†
const ALLOWED_DIR = process.env.ALLOWED_DIR || process.cwd()

function safePath(userPath: string): string {
  const resolved = path.resolve(ALLOWED_DIR, userPath)
  if (!resolved.startsWith(path.resolve(ALLOWED_DIR))) {
    throw new Error('è·¯å¾„è¶Šç•Œï¼šä¸å…è®¸è®¿é—®æŒ‡å®šç›®å½•ä¹‹å¤–çš„æ–‡ä»¶')
  }
  return resolved
}

// å·¥å…·ï¼šè¯»å–æ–‡ä»¶
server.tool(
  'read_file',
  'è¯»å–æŒ‡å®šè·¯å¾„çš„æ–‡ä»¶å†…å®¹',
  {
    path: z.string().describe('æ–‡ä»¶è·¯å¾„ï¼ˆç›¸å¯¹äºå·¥ä½œç›®å½•ï¼‰'),
    encoding: z.enum(['utf-8', 'base64']).default('utf-8').describe('æ–‡ä»¶ç¼–ç '),
  },
  async ({ path: filePath, encoding }) => {
    try {
      const fullPath = safePath(filePath)
      const content = await fs.readFile(fullPath, encoding as BufferEncoding)

      return {
        content: [{ type: 'text', text: content }],
      }
    } catch (error) {
      const err = error as NodeJS.ErrnoException
      let message = `è¯»å–æ–‡ä»¶å¤±è´¥ï¼š${err.message}`

      if (err.code === 'ENOENT') {
        message = `æ–‡ä»¶ä¸å­˜åœ¨ï¼š${filePath}`
      } else if (err.code === 'EACCES') {
        message = `æ²¡æœ‰è¯»å–æƒé™ï¼š${filePath}`
      }

      return {
        content: [{ type: 'text', text: message }],
        isError: true,
      }
    }
  }
)

// å·¥å…·ï¼šå†™å…¥æ–‡ä»¶
server.tool(
  'write_file',
  'å°†å†…å®¹å†™å…¥æŒ‡å®šæ–‡ä»¶ï¼ˆå¦‚æœæ–‡ä»¶å­˜åœ¨ä¼šè¦†ç›–ï¼‰',
  {
    path: z.string().describe('æ–‡ä»¶è·¯å¾„'),
    content: z.string().describe('è¦å†™å…¥çš„å†…å®¹'),
    createDir: z.boolean().default(false).describe('å¦‚æœç›®å½•ä¸å­˜åœ¨æ˜¯å¦åˆ›å»º'),
  },
  async ({ path: filePath, content, createDir }) => {
    try {
      const fullPath = safePath(filePath)

      if (createDir) {
        await fs.mkdir(path.dirname(fullPath), { recursive: true })
      }

      await fs.writeFile(fullPath, content, 'utf-8')

      return {
        content: [{ type: 'text', text: `æ–‡ä»¶å·²å†™å…¥ï¼š${filePath}` }],
      }
    } catch (error) {
      return {
        content: [
          { type: 'text', text: `å†™å…¥å¤±è´¥ï¼š${(error as Error).message}` },
        ],
        isError: true,
      }
    }
  }
)

// å·¥å…·ï¼šåˆ—å‡ºç›®å½•å†…å®¹
server.tool(
  'list_directory',
  'åˆ—å‡ºæŒ‡å®šç›®å½•ä¸‹çš„æ–‡ä»¶å’Œå­ç›®å½•',
  {
    path: z.string().default('.').describe('ç›®å½•è·¯å¾„'),
    recursive: z.boolean().default(false).describe('æ˜¯å¦é€’å½’åˆ—å‡ºå­ç›®å½•'),
  },
  async ({ path: dirPath, recursive }) => {
    try {
      const fullPath = safePath(dirPath)

      async function listDir(dir: string, prefix = ''): Promise<string[]> {
        const entries = await fs.readdir(dir, { withFileTypes: true })
        const lines: string[] = []

        for (const entry of entries) {
          const isDir = entry.isDirectory()
          const icon = isDir ? 'ğŸ“' : 'ğŸ“„'
          lines.push(`${prefix}${icon} ${entry.name}`)

          if (recursive && isDir) {
            const subLines = await listDir(
              path.join(dir, entry.name),
              prefix + '  '
            )
            lines.push(...subLines)
          }
        }

        return lines
      }

      const listing = await listDir(fullPath)

      return {
        content: [{ type: 'text', text: listing.join('\n') || 'ç›®å½•ä¸ºç©º' }],
      }
    } catch (error) {
      return {
        content: [
          { type: 'text', text: `åˆ—å‡ºç›®å½•å¤±è´¥ï¼š${(error as Error).message}` },
        ],
        isError: true,
      }
    }
  }
)

// å·¥å…·ï¼šè·å–æ–‡ä»¶ä¿¡æ¯
server.tool(
  'file_info',
  'è·å–æ–‡ä»¶æˆ–ç›®å½•çš„è¯¦ç»†ä¿¡æ¯',
  {
    path: z.string().describe('æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„'),
  },
  async ({ path: filePath }) => {
    try {
      const fullPath = safePath(filePath)
      const stat = await fs.stat(fullPath)

      const info = {
        ç±»å‹: stat.isDirectory() ? 'ç›®å½•' : 'æ–‡ä»¶',
        å¤§å°: stat.isDirectory() ? '-' : `${stat.size} å­—èŠ‚`,
        åˆ›å»ºæ—¶é—´: stat.birthtime.toLocaleString('zh-CN'),
        ä¿®æ”¹æ—¶é—´: stat.mtime.toLocaleString('zh-CN'),
        æƒé™: stat.mode.toString(8).slice(-3),
      }

      const text = Object.entries(info)
        .map(([key, value]) => `${key}: ${value}`)
        .join('\n')

      return {
        content: [{ type: 'text', text }],
      }
    } catch (error) {
      return {
        content: [
          { type: 'text', text: `è·å–ä¿¡æ¯å¤±è´¥ï¼š${(error as Error).message}` },
        ],
        isError: true,
      }
    }
  }
)

// å·¥å…·ï¼šæœç´¢æ–‡ä»¶
server.tool(
  'search_files',
  'åœ¨ç›®å½•ä¸­æœç´¢åŒ¹é…çš„æ–‡ä»¶',
  {
    directory: z.string().default('.').describe('æœç´¢ç›®å½•'),
    pattern: z.string().describe('æ–‡ä»¶åæ¨¡å¼ï¼Œæ”¯æŒ * é€šé…ç¬¦'),
    maxResults: z.number().default(20).describe('æœ€å¤§è¿”å›æ•°é‡'),
  },
  async ({ directory, pattern, maxResults }) => {
    try {
      const fullPath = safePath(directory)
      const regex = new RegExp(
        '^' + pattern.replace(/\*/g, '.*').replace(/\?/g, '.') + '$'
      )

      const results: string[] = []

      async function search(dir: string): Promise<void> {
        if (results.length >= maxResults) return

        const entries = await fs.readdir(dir, { withFileTypes: true })

        for (const entry of entries) {
          if (results.length >= maxResults) break

          const entryPath = path.join(dir, entry.name)
          const relativePath = path.relative(fullPath, entryPath)

          if (regex.test(entry.name)) {
            results.push(relativePath)
          }

          if (entry.isDirectory()) {
            await search(entryPath)
          }
        }
      }

      await search(fullPath)

      if (results.length === 0) {
        return {
          content: [{ type: 'text', text: `æ²¡æœ‰æ‰¾åˆ°åŒ¹é… "${pattern}" çš„æ–‡ä»¶` }],
        }
      }

      return {
        content: [
          {
            type: 'text',
            text: `æ‰¾åˆ° ${results.length} ä¸ªæ–‡ä»¶ï¼š\n${results.join('\n')}`,
          },
        ],
      }
    } catch (error) {
      return {
        content: [
          { type: 'text', text: `æœç´¢å¤±è´¥ï¼š${(error as Error).message}` },
        ],
        isError: true,
      }
    }
  }
)

async function main() {
  const transport = new StdioServerTransport()
  await server.connect(transport)
  console.error(`File Tools MCP Server å·²å¯åŠ¨ï¼Œå·¥ä½œç›®å½•: ${ALLOWED_DIR}`)
}

main().catch(console.error)
```

è¿™ä¸ª Server åŒ…å«äº”ä¸ªå·¥å…·ï¼š

| å·¥å…·             | åŠŸèƒ½                       |
| ---------------- | -------------------------- |
| `read_file`      | è¯»å–æ–‡ä»¶å†…å®¹ï¼Œæ”¯æŒä¸åŒç¼–ç  |
| `write_file`     | å†™å…¥æ–‡ä»¶ï¼Œå¯è‡ªåŠ¨åˆ›å»ºç›®å½•   |
| `list_directory` | åˆ—å‡ºç›®å½•å†…å®¹ï¼Œæ”¯æŒé€’å½’     |
| `file_info`      | è·å–æ–‡ä»¶/ç›®å½•è¯¦ç»†ä¿¡æ¯      |
| `search_files`   | æŒ‰æ¨¡å¼æœç´¢æ–‡ä»¶             |

å®‰å…¨æªæ–½ï¼š

- `safePath` å‡½æ•°é˜²æ­¢è·¯å¾„éå†æ”»å‡»
- é€šè¿‡ `ALLOWED_DIR` ç¯å¢ƒå˜é‡é™åˆ¶å¯è®¿é—®çš„ç›®å½•

## åœ¨ Claude Desktop ä¸­ä½¿ç”¨

é…ç½®æ–‡ä»¶ç¤ºä¾‹ï¼š

```json
{
  "mcpServers": {
    "file-tools": {
      "command": "node",
      "args": ["/path/to/file-tools/dist/index.js"],
      "env": {
        "ALLOWED_DIR": "/Users/ä½ çš„ç”¨æˆ·å/projects"
      }
    }
  }
}
```

ç„¶åå¯ä»¥è¿™æ ·å¯¹è¯ï¼š

- "åˆ—å‡º src ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶"
- "è¯»å– package.json çš„å†…å®¹"
- "æœç´¢æ‰€æœ‰ .ts æ–‡ä»¶"
- "åˆ›å»ºä¸€ä¸ª notes.md æ–‡ä»¶ï¼Œå†…å®¹æ˜¯ä»Šå¤©çš„ä¼šè®®è®°å½•"

## ä¸‹ä¸€æ­¥

è¿™ç¯‡è¦†ç›–äº† Tools çš„æ–¹æ–¹é¢é¢ã€‚ä¸‹ä¸€ç¯‡è¿›å…¥ Resourcesâ€”â€”MCP çš„å¦ä¸€ä¸ªæ ¸å¿ƒèƒ½åŠ›ï¼Œå­¦ä¹ å¦‚ä½•å‘ AI æš´éœ²é™æ€æ•°æ®èµ„æºã€‚

## å‚è€ƒ

- [MCP Tools è§„èŒƒ](https://modelcontextprotocol.io/docs/concepts/tools)
- [Zod æ–‡æ¡£](https://zod.dev/)
- [JSON Schema è§„èŒƒ](https://json-schema.org/)
