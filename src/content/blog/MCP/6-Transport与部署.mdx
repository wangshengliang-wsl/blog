---
title: 'MCP Transport ä¸éƒ¨ç½²'
description: 'æ·±å…¥ç†è§£ MCP ä¼ è¾“å±‚æœºåˆ¶ï¼ŒæŒæ¡ stdio å’Œ HTTP Transport çš„å®ç°ï¼Œå­¦ä¹ ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æ–¹æ¡ˆ'
pubDate: 2025-12-03
toc: true
ogImage: true
category: 'MCP'
tags:
  ['MCP', 'Model Context Protocol', 'TypeScript', 'Transport', 'HTTP', 'éƒ¨ç½²']
---

å‰é¢æˆ‘ä»¬å­¦ä¹ äº† MCP çš„ä¸‰å¤§åŸè¯­ï¼Œè¿™ç¯‡æ–‡ç« å°†æ·±å…¥ä¼ è¾“å±‚ï¼Œäº†è§£ MCP æ¶ˆæ¯æ˜¯å¦‚ä½•åœ¨ Client å’Œ Server ä¹‹é—´ä¼ é€’çš„ï¼Œä»¥åŠå¦‚ä½•å°† MCP Server éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒã€‚

## ğŸ¯ Transport æ¦‚è¿°

MCP åè®®ä¸ä¼ è¾“å±‚è§£è€¦ï¼Œæ”¯æŒå¤šç§ä¼ è¾“æ–¹å¼ï¼š

| Transport           | é€‚ç”¨åœºæ™¯      | ç‰¹ç‚¹                   |
| ------------------- | ------------- | ---------------------- |
| **stdio**           | æœ¬åœ°å·¥å…·ã€CLI | ç®€å•å¯é ï¼Œæ¯è¿æ¥ä¸€è¿›ç¨‹ |
| **Streamable HTTP** | è¿œç¨‹æœåŠ¡ã€Web | æ”¯æŒå¤šå®¢æˆ·ç«¯ï¼Œå¯æ‰©å±•   |
| **è‡ªå®šä¹‰**          | ç‰¹æ®Šéœ€æ±‚      | éœ€å®ç°åè®®çº¦å®š         |

## stdio Transport

è¿™æ˜¯æœ€ç®€å•çš„ä¼ è¾“æ–¹å¼ï¼ŒClient å¯åŠ¨ Server ä½œä¸ºå­è¿›ç¨‹ï¼Œé€šè¿‡æ ‡å‡†è¾“å…¥è¾“å‡ºé€šä¿¡ã€‚

### å·¥ä½œåŸç†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  stdin (JSON-RPC)  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Server  â”‚
â”‚         â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  stdout (JSON-RPC) â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼ stderr (logs)
```

### Server å®ç°

```typescript
// server.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'
import { z } from 'zod'

const server = new McpServer({
  name: 'stdio-example',
  version: '1.0.0',
})

server.registerTool(
  'greet',
  {
    title: 'é—®å€™',
    description: 'å‘ç”¨æˆ·é—®å€™',
    inputSchema: { name: z.string() },
  },
  async ({ name }) => ({
    content: [{ type: 'text', text: `ä½ å¥½ï¼Œ${name}ï¼` }],
  })
)

// stdio ä¼ è¾“
const transport = new StdioServerTransport()
await server.connect(transport)

// æ—¥å¿—ä½¿ç”¨ stderrï¼ˆstdout è¢«åè®®å ç”¨ï¼‰
console.error('Server started on stdio')
```

### æ¶ˆæ¯æ ¼å¼

æ¯æ¡æ¶ˆæ¯æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ JSON è¡Œï¼Œæ¢è¡Œç¬¦åˆ†éš”ï¼š

```json
{"jsonrpc":"2.0","id":1,"method":"initialize","params":{...}}
{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{...}}
```

ğŸ”¶ **æ³¨æ„**ï¼šæ¶ˆæ¯å†…å®¹ä¸èƒ½åŒ…å«æ¢è¡Œç¬¦ã€‚

### é…ç½®ç¤ºä¾‹ï¼ˆClaude Desktopï¼‰

```json
{
  "mcpServers": {
    "my-server": {
      "command": "node",
      "args": ["/path/to/server.js"],
      "env": {
        "API_KEY": "your-api-key"
      }
    }
  }
}
```

## Streamable HTTP Transport

é€‚ç”¨äºè¿œç¨‹éƒ¨ç½²ã€å¤šå®¢æˆ·ç«¯è¿æ¥çš„åœºæ™¯ã€‚

### å·¥ä½œåŸç†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   POST /mcp   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Server  â”‚
â”‚         â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ (HTTP)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  SSE / JSON    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- å®¢æˆ·ç«¯é€šè¿‡ **HTTP POST** å‘é€è¯·æ±‚
- æœåŠ¡ç«¯è¿”å› **JSON** æˆ– **SSE æµ**

### åŸºç¡€ HTTP Server

```typescript
// http-server.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js'
import express from 'express'
import { z } from 'zod'

const server = new McpServer({
  name: 'http-example',
  version: '1.0.0',
})

server.registerTool(
  'add',
  {
    title: 'åŠ æ³•',
    description: 'è®¡ç®—ä¸¤æ•°ä¹‹å’Œ',
    inputSchema: { a: z.number(), b: z.number() },
    outputSchema: { result: z.number() },
  },
  async ({ a, b }) => {
    const result = a + b
    return {
      content: [{ type: 'text', text: `${a} + ${b} = ${result}` }],
      structuredContent: { result },
    }
  }
)

// Express æœåŠ¡å™¨
const app = express()
app.use(express.json())

app.post('/mcp', async (req, res) => {
  const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: undefined,
    enableJsonResponse: true,
  })

  res.on('close', () => transport.close())

  await server.connect(transport)
  await transport.handleRequest(req, res, req.body)
})

const PORT = process.env.PORT || 3000
app.listen(PORT, () => {
  console.log(`MCP Server running on http://localhost:${PORT}/mcp`)
})
```

### æ”¯æŒ SSE æµå¼å“åº”

```typescript
app.post('/mcp', async (req, res) => {
  const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: undefined,
    enableJsonResponse: false, // ä½¿ç”¨ SSE
  })

  res.on('close', () => transport.close())

  await server.connect(transport)
  await transport.handleRequest(req, res, req.body)
})
```

### ä¼šè¯ç®¡ç†

å¯¹äºéœ€è¦çŠ¶æ€çš„åœºæ™¯ï¼Œå¯ä»¥å¯ç”¨ä¼šè¯ï¼š

```typescript
import { randomUUID } from 'crypto'

const sessions = new Map<string, McpServer>()

app.post('/mcp', async (req, res) => {
  const sessionId = (req.headers['x-session-id'] as string) || randomUUID()

  // å¤ç”¨æˆ–åˆ›å»º Server å®ä¾‹
  let mcpServer = sessions.get(sessionId)
  if (!mcpServer) {
    mcpServer = createNewServer()
    sessions.set(sessionId, mcpServer)
  }

  const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: () => sessionId,
    enableJsonResponse: true,
  })

  res.setHeader('x-session-id', sessionId)
  res.on('close', () => transport.close())

  await mcpServer.connect(transport)
  await transport.handleRequest(req, res, req.body)
})

// å®šæœŸæ¸…ç†è¿‡æœŸä¼šè¯
setInterval(() => {
  // å®ç°ä¼šè¯æ¸…ç†é€»è¾‘
}, 60000)
```

## å®‰å…¨æ€§è€ƒè™‘

### 1. Origin éªŒè¯

é˜²æ­¢ DNS é‡ç»‘å®šæ”»å‡»ï¼š

```typescript
const ALLOWED_ORIGINS = ['https://example.com', 'http://localhost:3000']

app.use('/mcp', (req, res, next) => {
  const origin = req.headers.origin

  if (origin && !ALLOWED_ORIGINS.includes(origin)) {
    res.status(403).json({ error: 'Origin not allowed' })
    return
  }

  // è®¾ç½® CORS å¤´
  if (origin) {
    res.setHeader('Access-Control-Allow-Origin', origin)
  }
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS')
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization')

  if (req.method === 'OPTIONS') {
    res.status(204).end()
    return
  }

  next()
})
```

### 2. è®¤è¯

```typescript
import jwt from 'jsonwebtoken'

const JWT_SECRET = process.env.JWT_SECRET!

function authMiddleware(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  const authHeader = req.headers.authorization

  if (!authHeader?.startsWith('Bearer ')) {
    res.status(401).json({ error: 'Missing authorization token' })
    return
  }

  const token = authHeader.slice(7)

  try {
    const decoded = jwt.verify(token, JWT_SECRET)
    req.user = decoded
    next()
  } catch {
    res.status(401).json({ error: 'Invalid token' })
  }
}

app.post('/mcp', authMiddleware, async (req, res) => {
  // å·²è®¤è¯çš„è¯·æ±‚å¤„ç†
})
```

### 3. æœ¬åœ°ç»‘å®š

æœ¬åœ°æœåŠ¡åº”åªç›‘å¬ localhostï¼š

```typescript
// âœ… å®‰å…¨ï¼šåªç›‘å¬æœ¬åœ°
app.listen(3000, '127.0.0.1', () => {
  console.log('Server listening on 127.0.0.1:3000')
})

// âŒ å±é™©ï¼šç›‘å¬æ‰€æœ‰æ¥å£
app.listen(3000, '0.0.0.0') // ä¸è¦è¿™æ ·åšï¼ˆé™¤éæœ‰å¿…è¦ï¼‰
```

## ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²

### Docker éƒ¨ç½²

```dockerfile
# Dockerfile
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY dist ./dist

ENV NODE_ENV=production
ENV PORT=3000

EXPOSE 3000

USER node

CMD ["node", "dist/server.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  mcp-server:
    build: .
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
      - API_KEY=${API_KEY}
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:3000/health']
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped
```

### å¥åº·æ£€æŸ¥ç«¯ç‚¹

```typescript
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    version: '1.0.0',
    uptime: process.uptime(),
  })
})
```

### Nginx åå‘ä»£ç†

```nginx
# /etc/nginx/conf.d/mcp.conf
upstream mcp_backend {
    server 127.0.0.1:3000;
    keepalive 32;
}

server {
    listen 443 ssl http2;
    server_name mcp.example.com;

    ssl_certificate /etc/ssl/certs/mcp.crt;
    ssl_certificate_key /etc/ssl/private/mcp.key;

    location /mcp {
        proxy_pass http://mcp_backend;
        proxy_http_version 1.1;

        # SSE æ”¯æŒ
        proxy_set_header Connection '';
        proxy_buffering off;
        proxy_cache off;

        # è¶…æ—¶è®¾ç½®
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;

        # å®‰å…¨å¤´
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

### PM2 è¿›ç¨‹ç®¡ç†

```javascript
// ecosystem.config.js
module.exports = {
  apps: [
    {
      name: 'mcp-server',
      script: './dist/server.js',
      instances: 'max',
      exec_mode: 'cluster',
      env_production: {
        NODE_ENV: 'production',
        PORT: 3000,
      },
      max_memory_restart: '500M',
      error_file: './logs/error.log',
      out_file: './logs/out.log',
      merge_logs: true,
    },
  ],
}
```

```bash
# å¯åŠ¨
pm2 start ecosystem.config.js --env production

# æŸ¥çœ‹çŠ¶æ€
pm2 status

# æŸ¥çœ‹æ—¥å¿—
pm2 logs mcp-server
```

## å®Œæ•´ HTTP Server ç¤ºä¾‹

```typescript
// src/server.ts
import {
  McpServer,
  ResourceTemplate,
} from '@modelcontextprotocol/sdk/server/mcp.js'
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js'
import express from 'express'
import cors from 'cors'
import helmet from 'helmet'
import { z } from 'zod'

// åˆ›å»º MCP Server
function createMcpServer() {
  const server = new McpServer({
    name: 'production-server',
    version: '1.0.0',
  })

  // æ³¨å†Œ Tools
  server.registerTool(
    'echo',
    {
      title: 'Echo',
      description: 'è¿”å›è¾“å…¥çš„æ¶ˆæ¯',
      inputSchema: { message: z.string() },
    },
    async ({ message }) => ({
      content: [{ type: 'text', text: `Echo: ${message}` }],
    })
  )

  // æ³¨å†Œ Resources
  server.registerResource(
    'status',
    'status://server',
    { title: 'æœåŠ¡çŠ¶æ€', description: 'æœåŠ¡å™¨è¿è¡ŒçŠ¶æ€' },
    async (uri) => ({
      contents: [
        {
          uri: uri.href,
          mimeType: 'application/json',
          text: JSON.stringify(
            {
              status: 'running',
              uptime: process.uptime(),
              memory: process.memoryUsage(),
            },
            null,
            2
          ),
        },
      ],
    })
  )

  return server
}

// Express åº”ç”¨
const app = express()

// å®‰å…¨ä¸­é—´ä»¶
app.use(helmet())
app.use(
  cors({
    origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
    methods: ['POST', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
  })
)
app.use(express.json({ limit: '10mb' }))

// å¥åº·æ£€æŸ¥
app.get('/health', (req, res) => {
  res.json({ status: 'healthy' })
})

// MCP ç«¯ç‚¹
app.post('/mcp', async (req, res) => {
  const mcpServer = createMcpServer()

  const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: undefined,
    enableJsonResponse: true,
  })

  res.on('close', () => {
    transport.close()
  })

  try {
    await mcpServer.connect(transport)
    await transport.handleRequest(req, res, req.body)
  } catch (error) {
    console.error('MCP request error:', error)
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
})

// å¯åŠ¨æœåŠ¡å™¨
const PORT = parseInt(process.env.PORT || '3000')
const HOST = process.env.HOST || '127.0.0.1'

app.listen(PORT, HOST, () => {
  console.log(`MCP Server running on http://${HOST}:${PORT}`)
  console.log(`MCP endpoint: http://${HOST}:${PORT}/mcp`)
  console.log(`Health check: http://${HOST}:${PORT}/health`)
})
```

### package.json é…ç½®

```json
{
  "name": "mcp-http-server",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "start": "node dist/server.js",
    "dev": "tsx watch src/server.ts"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "helmet": "^7.1.0",
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^20.10.0",
    "tsx": "^4.6.0",
    "typescript": "^5.3.0"
  }
}
```

## å°ç»“

è¿™ç¯‡æ–‡ç« æˆ‘ä»¬æ·±å…¥å­¦ä¹ äº† MCP Transportï¼š

âœ… stdio Transport å·¥ä½œåŸç†ä¸å®ç°
âœ… Streamable HTTP Transport é…ç½®
âœ… SSE æµå¼å“åº”
âœ… å®‰å…¨æ€§è€ƒè™‘ï¼šOrigin éªŒè¯ã€è®¤è¯ã€æœ¬åœ°ç»‘å®š
âœ… ç”Ÿäº§éƒ¨ç½²ï¼šDockerã€Nginxã€PM2

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•æ„å»º MCP Clientï¼Œå°† MCP Server é›†æˆåˆ°ä½ è‡ªå·±çš„åº”ç”¨ä¸­ã€‚

## å‚è€ƒèµ„æ–™

- [MCP Transport è§„èŒƒ](https://modelcontextprotocol.io/docs/concepts/transports)
- [Express.js æ–‡æ¡£](https://expressjs.com/)
- [Docker æ–‡æ¡£](https://docs.docker.com/)
