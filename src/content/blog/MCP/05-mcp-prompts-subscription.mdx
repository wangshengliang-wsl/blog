---
title: MCP Prompts与资源订阅机制
description: 掌握MCP提示词模板的注册与使用，理解资源变更通知机制，实现AI应用与数据源的实时同步
pubDate: 2025-12-09
toc: true
ogImage: true
category: MCP
---

这篇讲 MCP 的两个进阶主题：**Prompts**（提示词模板）和**资源订阅**（实时通知）。

## Prompts：可复用的提示词

Prompts 是 MCP 的第三大能力，用于提供预定义的提示词模板。

### 为什么需要 Prompts

假设你经常让 AI 做代码审查，每次都要写类似的提示词：

```
请审查以下代码，关注：
1. 潜在的 bug
2. 性能问题
3. 代码风格
4. 安全隐患

代码：
...
```

Prompts 可以把这个模板封装起来，用户直接选择"代码审查"模板，填入代码即可。

### 协议规范

#### prompts/list

获取可用的提示词模板列表：

```json
// 请求
{ "jsonrpc": "2.0", "id": 1, "method": "prompts/list" }

// 响应
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "prompts": [
      {
        "name": "code-review",
        "description": "审查代码并提供改进建议",
        "arguments": [
          {
            "name": "language",
            "description": "编程语言",
            "required": true
          },
          {
            "name": "code",
            "description": "要审查的代码",
            "required": true
          }
        ]
      }
    ]
  }
}
```

#### prompts/get

获取具体提示词内容（带参数填充）：

```json
// 请求
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "prompts/get",
  "params": {
    "name": "code-review",
    "arguments": {
      "language": "TypeScript",
      "code": "function add(a, b) { return a + b }"
    }
  }
}

// 响应
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "description": "审查 TypeScript 代码",
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "请审查以下 TypeScript 代码...\n\nfunction add(a, b) { return a + b }"
        }
      }
    ]
  }
}
```

### 使用 SDK 注册 Prompts

```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { z } from 'zod'

const server = new McpServer({
  name: 'prompt-server',
  version: '1.0.0',
})

// 注册代码审查提示词
server.prompt(
  'code-review',
  '审查代码并提供改进建议',
  {
    language: z.string().describe('编程语言'),
    code: z.string().describe('要审查的代码'),
  },
  async ({ language, code }) => ({
    messages: [
      {
        role: 'user',
        content: {
          type: 'text',
          text: `请审查以下 ${language} 代码，关注：
1. 潜在的 bug 和逻辑错误
2. 性能优化机会
3. 代码可读性和命名规范
4. 安全隐患

代码：
\`\`\`${language}
${code}
\`\`\`

请逐项分析并给出具体的改进建议。`,
        },
      },
    ],
  })
)
```

`server.prompt()` 四个参数：

1. 名称：提示词的唯一标识
2. 描述：向用户说明这个提示词的用途
3. 参数 Schema：使用 Zod 定义
4. 生成函数：返回填充后的消息

### 多消息 Prompts

提示词可以包含多条消息，模拟对话上下文：

```typescript
server.prompt(
  'debug-assistant',
  '帮助调试代码问题',
  {
    error: z.string().describe('错误信息'),
    code: z.string().describe('出错的代码'),
  },
  async ({ error, code }) => ({
    messages: [
      {
        role: 'user',
        content: {
          type: 'text',
          text: `我遇到了一个错误：\n${error}`,
        },
      },
      {
        role: 'assistant',
        content: {
          type: 'text',
          text: '好的，请提供出错的代码，我来帮你分析。',
        },
      },
      {
        role: 'user',
        content: {
          type: 'text',
          text: `代码如下：\n\`\`\`\n${code}\n\`\`\``,
        },
      },
    ],
  })
)
```

### 包含资源的 Prompts

提示词内容可以引用 Resources：

```typescript
server.prompt(
  'analyze-config',
  '分析项目配置',
  {
    configFile: z.string().describe('配置文件名'),
  },
  async ({ configFile }) => {
    const config = await readConfigFile(configFile)

    return {
      messages: [
        {
          role: 'user',
          content: {
            type: 'resource',
            resource: {
              uri: `config://files/${configFile}`,
              mimeType: 'application/json',
              text: config,
            },
          },
        },
        {
          role: 'user',
          content: {
            type: 'text',
            text: '请分析这个配置文件，指出潜在的问题和优化建议。',
          },
        },
      ],
    }
  }
)
```

## 资源订阅：实时更新

Resources 的内容可能会变化（比如日志文件不断追加）。MCP 提供了订阅机制，让 Client 能够接收资源变更通知。

### 通知类型

MCP 定义了两种资源相关的通知：

#### resources/list_changed

资源列表发生变化时发送：

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/list_changed"
}
```

触发场景：

- 新增了资源
- 删除了资源
- 资源元信息变化

#### resources/updated

特定资源内容变化时发送：

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "log://app/current"
  }
}
```

### 订阅协议

Client 可以订阅特定资源的更新：

```json
// 订阅
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "resources/subscribe",
  "params": { "uri": "log://app/current" }
}

// 取消订阅
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/unsubscribe",
  "params": { "uri": "log://app/current" }
}
```

### 实现资源列表变更通知

当资源列表变化时，Server 主动发送通知：

```typescript
import { ListResourcesRequestSchema } from '@modelcontextprotocol/sdk/types.js'
import chokidar from 'chokidar'

const CONFIG_DIR = './config'

// 监听配置目录变化
const watcher = chokidar.watch(CONFIG_DIR, {
  persistent: true,
  ignoreInitial: true,
})

watcher.on('add', (path) => {
  console.error(`新增配置文件: ${path}`)
  // 发送资源列表变更通知
  server.notification({
    method: 'notifications/resources/list_changed',
  })
})

watcher.on('unlink', (path) => {
  console.error(`删除配置文件: ${path}`)
  server.notification({
    method: 'notifications/resources/list_changed',
  })
})
```

### 实现资源内容订阅

更复杂的场景是订阅特定资源的内容变化：

```typescript
import {
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
} from '@modelcontextprotocol/sdk/types.js'

// 记录订阅关系
const subscriptions = new Map<string, Set<string>>() // uri -> Set<sessionId>

// 处理订阅请求
server.setRequestHandler(SubscribeRequestSchema, async (request) => {
  const uri = request.params.uri
  console.error(`收到订阅请求: ${uri}`)

  if (!subscriptions.has(uri)) {
    subscriptions.set(uri, new Set())
    // 开始监听这个资源
    startWatching(uri)
  }

  // 实际项目中需要跟踪具体的 session
  subscriptions.get(uri)!.add('default')

  return {}
})

// 处理取消订阅请求
server.setRequestHandler(UnsubscribeRequestSchema, async (request) => {
  const uri = request.params.uri
  const subs = subscriptions.get(uri)

  if (subs) {
    subs.delete('default')
    if (subs.size === 0) {
      subscriptions.delete(uri)
      stopWatching(uri)
    }
  }

  return {}
})

// 当资源内容变化时发送通知
function notifyResourceUpdated(uri: string) {
  if (subscriptions.has(uri)) {
    server.notification({
      method: 'notifications/resources/updated',
      params: { uri },
    })
  }
}
```

## 实战：实时日志监控 Server

整合 Prompts 和资源订阅，实现一个日志监控 Server：

```typescript
// src/index.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'
import {
  ListResourcesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
} from '@modelcontextprotocol/sdk/types.js'
import { z } from 'zod'
import fs from 'fs/promises'
import path from 'path'
import chokidar from 'chokidar'

const server = new McpServer({
  name: 'log-monitor',
  version: '1.0.0',
})

const LOG_DIR = process.env.LOG_DIR || './logs'
const subscriptions = new Map<string, NodeJS.Timeout>()

// === Resources ===

// 获取日志文件列表
async function getLogFiles(): Promise<string[]> {
  try {
    const files = await fs.readdir(LOG_DIR)
    return files.filter((f) => f.endsWith('.log'))
  } catch {
    return []
  }
}

// 读取日志文件（最后 N 行）
async function readLogTail(filename: string, lines = 100): Promise<string> {
  const fullPath = path.join(LOG_DIR, filename)
  const content = await fs.readFile(fullPath, 'utf-8')
  const allLines = content.split('\n')
  return allLines.slice(-lines).join('\n')
}

// 资源列表
server.setRequestHandler(ListResourcesRequestSchema, async () => {
  const files = await getLogFiles()

  return {
    resources: files.map((file) => ({
      uri: `log://files/${file}`,
      name: file,
      description: `日志文件: ${file}`,
      mimeType: 'text/plain',
    })),
  }
})

// 读取资源
server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  const uri = request.params.uri
  const match = uri.match(/^log:\/\/files\/(.+\.log)$/)

  if (!match) {
    throw new Error(`未知资源: ${uri}`)
  }

  const filename = match[1]

  // 安全检查
  if (filename.includes('..')) {
    throw new Error('无效的文件名')
  }

  const content = await readLogTail(filename, 200)

  return {
    contents: [
      {
        uri,
        mimeType: 'text/plain',
        text: content,
      },
    ],
  }
})

// 订阅资源更新
server.setRequestHandler(SubscribeRequestSchema, async (request) => {
  const uri = request.params.uri
  const match = uri.match(/^log:\/\/files\/(.+\.log)$/)

  if (!match) {
    throw new Error(`无法订阅: ${uri}`)
  }

  const filename = match[1]
  const fullPath = path.join(LOG_DIR, filename)

  // 如果已经在监听，不重复监听
  if (subscriptions.has(uri)) {
    return {}
  }

  // 监听文件变化
  const watcher = chokidar.watch(fullPath, { persistent: true })

  watcher.on('change', () => {
    server.notification({
      method: 'notifications/resources/updated',
      params: { uri },
    })
  })

  // 存储 watcher 引用（这里简化处理）
  subscriptions.set(uri, watcher as any)

  console.error(`开始监听: ${filename}`)
  return {}
})

// 取消订阅
server.setRequestHandler(UnsubscribeRequestSchema, async (request) => {
  const uri = request.params.uri
  const watcher = subscriptions.get(uri)

  if (watcher) {
    ;(watcher as any).close()
    subscriptions.delete(uri)
    console.error(`停止监听: ${uri}`)
  }

  return {}
})

// 监听目录变化（新增/删除日志文件）
const dirWatcher = chokidar.watch(LOG_DIR, {
  persistent: true,
  ignoreInitial: true,
})

dirWatcher.on('add', (filepath) => {
  if (filepath.endsWith('.log')) {
    console.error(`新日志文件: ${filepath}`)
    server.notification({
      method: 'notifications/resources/list_changed',
    })
  }
})

dirWatcher.on('unlink', (filepath) => {
  if (filepath.endsWith('.log')) {
    console.error(`删除日志文件: ${filepath}`)
    server.notification({
      method: 'notifications/resources/list_changed',
    })
  }
})

// === Prompts ===

// 日志分析提示词
server.prompt(
  'analyze-logs',
  '分析日志内容，找出错误和异常',
  {
    logFile: z.string().describe('日志文件名'),
    focus: z
      .enum(['errors', 'performance', 'security', 'all'])
      .default('all')
      .describe('分析重点'),
  },
  async ({ logFile, focus }) => {
    const content = await readLogTail(logFile, 500)

    const focusInstructions: Record<string, string> = {
      errors: '重点关注 ERROR、WARN 级别的日志，分析错误原因和影响',
      performance: '关注响应时间、超时、资源使用等性能相关日志',
      security: '关注登录失败、权限拒绝、异常访问等安全相关日志',
      all: '全面分析日志，包括错误、性能和安全问题',
    }

    return {
      messages: [
        {
          role: 'user',
          content: {
            type: 'text',
            text: `请分析以下日志文件内容。

**分析重点**: ${focusInstructions[focus]}

**日志内容**:
\`\`\`
${content}
\`\`\`

请提供：
1. 发现的问题汇总
2. 每个问题的详细分析
3. 建议的解决方案`,
          },
        },
      ],
    }
  }
)

// 日志搜索提示词
server.prompt(
  'search-logs',
  '在日志中搜索特定内容',
  {
    logFile: z.string().describe('日志文件名'),
    keyword: z.string().describe('搜索关键词'),
  },
  async ({ logFile, keyword }) => {
    const content = await readLogTail(logFile, 1000)
    const lines = content.split('\n')
    const matches = lines.filter((line) =>
      line.toLowerCase().includes(keyword.toLowerCase())
    )

    return {
      messages: [
        {
          role: 'user',
          content: {
            type: 'text',
            text: `在日志文件 ${logFile} 中搜索 "${keyword}"，找到 ${matches.length} 条匹配记录：

\`\`\`
${matches.slice(0, 50).join('\n')}
\`\`\`
${matches.length > 50 ? `\n(仅显示前 50 条，共 ${matches.length} 条)` : ''}

请分析这些日志记录，说明它们的含义和可能的问题。`,
          },
        },
      ],
    }
  }
)

// === Tools ===

// 工具：清理旧日志
server.tool(
  'clean_old_logs',
  '清理指定天数之前的日志文件',
  {
    daysOld: z.number().min(1).describe('清理多少天之前的日志'),
    dryRun: z.boolean().default(true).describe('是否仅预览（不实际删除）'),
  },
  async ({ daysOld, dryRun }) => {
    const files = await getLogFiles()
    const now = Date.now()
    const threshold = daysOld * 24 * 60 * 60 * 1000
    const toDelete: string[] = []

    for (const file of files) {
      const fullPath = path.join(LOG_DIR, file)
      const stat = await fs.stat(fullPath)
      const age = now - stat.mtime.getTime()

      if (age > threshold) {
        toDelete.push(file)
        if (!dryRun) {
          await fs.unlink(fullPath)
        }
      }
    }

    if (toDelete.length === 0) {
      return {
        content: [{ type: 'text', text: `没有 ${daysOld} 天之前的日志文件` }],
      }
    }

    const action = dryRun ? '将被删除' : '已删除'
    return {
      content: [
        {
          type: 'text',
          text: `${toDelete.length} 个文件${action}：\n${toDelete.join('\n')}`,
        },
      ],
    }
  }
)

// 启动
async function main() {
  // 确保日志目录存在
  await fs.mkdir(LOG_DIR, { recursive: true })

  const transport = new StdioServerTransport()
  await server.connect(transport)
  console.error(`Log Monitor 已启动，日志目录: ${LOG_DIR}`)
}

main().catch(console.error)
```

### 功能说明

这个 Server 提供：

**Resources**:

- `log://files/{filename}` - 访问日志文件内容
- 自动监听目录，新增/删除日志文件时通知 Client
- 支持订阅单个日志文件的内容变化

**Prompts**:

- `analyze-logs` - 分析日志中的问题
- `search-logs` - 搜索日志中的关键词

**Tools**:

- `clean_old_logs` - 清理旧日志文件

### 配置和测试

```json
{
  "mcpServers": {
    "log-monitor": {
      "command": "node",
      "args": ["/path/to/log-monitor/dist/index.js"],
      "env": {
        "LOG_DIR": "/var/log/myapp"
      }
    }
  }
}
```

生成测试日志：

```bash
mkdir -p logs
echo "[2024-01-15 10:00:00] INFO: Server started" >> logs/app.log
echo "[2024-01-15 10:05:00] ERROR: Database connection failed" >> logs/app.log
echo "[2024-01-15 10:06:00] WARN: Retrying connection..." >> logs/app.log
```

然后可以这样使用：

- "显示所有日志文件"
- "分析 app.log 中的错误"
- "搜索日志中包含 ERROR 的记录"
- "清理 30 天之前的旧日志"

## Server 能力声明

MCP Server 在初始化时会声明自己支持哪些能力。如果你的 Server 支持资源订阅，需要在能力中声明：

```typescript
const server = new McpServer({
  name: 'log-monitor',
  version: '1.0.0',
  capabilities: {
    resources: {
      subscribe: true, // 支持资源订阅
      listChanged: true, // 支持列表变更通知
    },
  },
})
```

SDK 通常会自动处理这些声明，但了解它们有助于调试和理解协议。

## 下一步

这篇覆盖了 Prompts 和资源订阅。下一篇进入远程通信——如何通过 HTTP 部署可公网访问的 MCP Server。

## 参考

- [MCP Prompts 规范](https://modelcontextprotocol.io/docs/concepts/prompts)
- [MCP Resources 订阅](https://modelcontextprotocol.io/docs/concepts/resources#subscribing-to-resources)
- [chokidar 文件监听库](https://github.com/paulmillr/chokidar)
