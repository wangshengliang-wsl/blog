---
title: 'å®æˆ˜ï¼šæ„å»ºæ–‡æ¡£åŠ©æ‰‹ MCP Server'
description: 'ç»¼åˆè¿ç”¨ MCP çŸ¥è¯†ï¼Œä»é›¶æ„å»ºä¸€ä¸ªå®Œæ•´çš„ Markdown æ–‡æ¡£åŠ©æ‰‹ï¼ŒåŒ…å«æ–‡ä»¶ç´¢å¼•ã€å…¨æ–‡æœç´¢ã€æ™ºèƒ½é—®ç­”ç­‰åŠŸèƒ½'
pubDate: 2025-12-03
toc: true
ogImage: true
category: 'MCP'
tags: ['MCP', 'Model Context Protocol', 'TypeScript', 'å®æˆ˜', 'æ–‡æ¡£åŠ©æ‰‹']
---

ç»è¿‡å‰é¢ 7 ç¯‡æ–‡ç« çš„å­¦ä¹ ï¼Œæˆ‘ä»¬å·²ç»æŒæ¡äº† MCP çš„æ ¸å¿ƒæ¦‚å¿µå’Œ APIã€‚è¿™ç¯‡æ–‡ç« å°†ç»¼åˆè¿ç”¨æ‰€å­¦çŸ¥è¯†ï¼Œä»é›¶æ„å»ºä¸€ä¸ªå®Œæ•´çš„ **Markdown æ–‡æ¡£åŠ©æ‰‹ MCP Server**ã€‚

## ğŸ¯ é¡¹ç›®ç›®æ ‡

åˆ›å»ºä¸€ä¸ª MCP Serverï¼Œè®© AI èƒ½å¤Ÿï¼š

- æµè§ˆå’Œè¯»å–æŒ‡å®šç›®å½•ä¸‹çš„ Markdown æ–‡æ¡£
- å…¨æ–‡æœç´¢æ–‡æ¡£å†…å®¹
- åŸºäºæ–‡æ¡£å†…å®¹å›ç­”é—®é¢˜
- ç”Ÿæˆæ–‡æ¡£æ‘˜è¦

## åŠŸèƒ½è®¾è®¡

### Toolsï¼ˆAI å¯è°ƒç”¨çš„æ“ä½œï¼‰

| Tool                | åŠŸèƒ½             |
| ------------------- | ---------------- |
| `search_docs`       | æœç´¢æ–‡æ¡£å†…å®¹     |
| `get_doc_structure` | è·å–æ–‡æ¡£ç›®å½•ç»“æ„ |

### Resourcesï¼ˆæš´éœ²ç»™ AI çš„æ•°æ®ï¼‰

| Resource        | åŠŸèƒ½             |
| --------------- | ---------------- |
| `docs://{path}` | è®¿é—®å…·ä½“æ–‡æ¡£å†…å®¹ |
| `docs://index`  | æ–‡æ¡£ç´¢å¼•å’Œç»Ÿè®¡   |

### Promptsï¼ˆé¢„è®¾äº¤äº’æ¨¡æ¿ï¼‰

| Prompt      | åŠŸèƒ½             |
| ----------- | ---------------- |
| `summarize` | ç”Ÿæˆæ–‡æ¡£æ‘˜è¦     |
| `explain`   | è§£é‡Šæ–‡æ¡£ä¸­çš„æ¦‚å¿µ |
| `qa`        | åŸºäºæ–‡æ¡£é—®ç­”     |

## é¡¹ç›®åˆå§‹åŒ–

### ç›®å½•ç»“æ„

```
mcp-docs-assistant/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts          # å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ server.ts         # MCP Server å®šä¹‰
â”‚   â”œâ”€â”€ tools.ts          # Tools å®ç°
â”‚   â”œâ”€â”€ resources.ts      # Resources å®ç°
â”‚   â”œâ”€â”€ prompts.ts        # Prompts å®ç°
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ markdown.ts   # Markdown å¤„ç†
â”‚       â””â”€â”€ search.ts     # æœç´¢åŠŸèƒ½
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

### package.json

```json
{
  "name": "mcp-docs-assistant",
  "version": "1.0.0",
  "type": "module",
  "main": "dist/index.js",
  "bin": {
    "mcp-docs-assistant": "dist/index.js"
  },
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "tsx src/index.ts"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "glob": "^10.3.10",
    "gray-matter": "^4.0.3",
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "tsx": "^4.6.0",
    "typescript": "^5.3.0"
  }
}
```

### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true
  },
  "include": ["src/**/*"]
}
```

## æ ¸å¿ƒå®ç°

### å·¥å…·å‡½æ•°ï¼šMarkdown å¤„ç†

```typescript
// src/utils/markdown.ts
import { readFile } from 'fs/promises'
import matter from 'gray-matter'

export interface DocMeta {
  title: string
  description?: string
  tags?: string[]
  date?: string
}

export interface ParsedDoc {
  path: string
  meta: DocMeta
  content: string
  headings: string[]
}

export async function parseMarkdown(filePath: string): Promise<ParsedDoc> {
  const raw = await readFile(filePath, 'utf-8')
  const { data, content } = matter(raw)

  // æå–æ ‡é¢˜
  const headings = content
    .split('\n')
    .filter((line) => line.startsWith('#'))
    .map((line) => line.replace(/^#+\s*/, ''))

  // æå– meta
  const meta: DocMeta = {
    title: data.title || headings[0] || filePath.split('/').pop() || 'Untitled',
    description: data.description,
    tags: data.tags,
    date: data.date?.toString(),
  }

  return { path: filePath, meta, content, headings }
}

export function extractSummary(content: string, maxLength = 200): string {
  // ç§»é™¤ Markdown è¯­æ³•
  const plain = content
    .replace(/^#+\s+/gm, '') // æ ‡é¢˜
    .replace(/\*\*|__/g, '') // ç²—ä½“
    .replace(/\*|_/g, '') // æ–œä½“
    .replace(/`{1,3}[^`]*`{1,3}/g, '') // ä»£ç 
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // é“¾æ¥
    .replace(/\n+/g, ' ') // æ¢è¡Œ
    .trim()

  if (plain.length <= maxLength) return plain
  return plain.slice(0, maxLength).trim() + '...'
}
```

### å·¥å…·å‡½æ•°ï¼šæœç´¢åŠŸèƒ½

```typescript
// src/utils/search.ts
import { glob } from 'glob'
import { parseMarkdown, type ParsedDoc } from './markdown.js'

export interface SearchResult {
  path: string
  title: string
  matches: string[]
  score: number
}

export class DocIndex {
  private docs: ParsedDoc[] = []
  private baseDir: string

  constructor(baseDir: string) {
    this.baseDir = baseDir
  }

  async build(): Promise<void> {
    const files = await glob('**/*.md', { cwd: this.baseDir, absolute: true })

    this.docs = await Promise.all(files.map((file) => parseMarkdown(file)))

    console.error(`Indexed ${this.docs.length} documents`)
  }

  search(query: string, limit = 10): SearchResult[] {
    const queryLower = query.toLowerCase()
    const queryTerms = queryLower.split(/\s+/).filter((t) => t.length > 1)

    const results: SearchResult[] = []

    for (const doc of this.docs) {
      const contentLower = doc.content.toLowerCase()
      const titleLower = doc.meta.title.toLowerCase()

      let score = 0
      const matches: string[] = []

      // æ ‡é¢˜åŒ¹é…ï¼ˆé«˜æƒé‡ï¼‰
      for (const term of queryTerms) {
        if (titleLower.includes(term)) {
          score += 10
        }
      }

      // å†…å®¹åŒ¹é…
      for (const term of queryTerms) {
        const regex = new RegExp(term, 'gi')
        const contentMatches = contentLower.match(regex)
        if (contentMatches) {
          score += contentMatches.length

          // æå–ä¸Šä¸‹æ–‡
          const lines = doc.content.split('\n')
          for (const line of lines) {
            if (line.toLowerCase().includes(term) && matches.length < 3) {
              matches.push(line.trim().slice(0, 100))
            }
          }
        }
      }

      if (score > 0) {
        results.push({
          path: doc.path.replace(this.baseDir, '').replace(/^\//, ''),
          title: doc.meta.title,
          matches: [...new Set(matches)], // å»é‡
          score,
        })
      }
    }

    return results.sort((a, b) => b.score - a.score).slice(0, limit)
  }

  getDoc(relativePath: string): ParsedDoc | undefined {
    const fullPath = `${this.baseDir}/${relativePath}`
    return this.docs.find((d) => d.path === fullPath)
  }

  getAllDocs(): ParsedDoc[] {
    return this.docs
  }

  getStats() {
    return {
      totalDocs: this.docs.length,
      totalWords: this.docs.reduce(
        (sum, doc) => sum + doc.content.split(/\s+/).length,
        0
      ),
      tags: [...new Set(this.docs.flatMap((d) => d.meta.tags || []))],
    }
  }
}
```

### Tools å®ç°

```typescript
// src/tools.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { z } from 'zod'
import { DocIndex } from './utils/search.js'

export function registerTools(server: McpServer, index: DocIndex) {
  // æœç´¢æ–‡æ¡£
  server.registerTool(
    'search_docs',
    {
      title: 'æœç´¢æ–‡æ¡£',
      description: 'åœ¨æ–‡æ¡£åº“ä¸­æœç´¢åŒ…å«æŒ‡å®šå…³é”®è¯çš„å†…å®¹',
      inputSchema: {
        query: z.string().min(1).describe('æœç´¢å…³é”®è¯'),
        limit: z
          .number()
          .int()
          .min(1)
          .max(20)
          .default(5)
          .describe('è¿”å›ç»“æœæ•°é‡'),
      },
      outputSchema: {
        results: z.array(
          z.object({
            path: z.string(),
            title: z.string(),
            matches: z.array(z.string()),
            score: z.number(),
          })
        ),
      },
    },
    async ({ query, limit }) => {
      const results = index.search(query, limit)

      if (results.length === 0) {
        return {
          content: [{ type: 'text', text: `æœªæ‰¾åˆ°ä¸ "${query}" ç›¸å…³çš„æ–‡æ¡£` }],
          structuredContent: { results: [] },
        }
      }

      const text = results
        .map(
          (r, i) =>
            `${i + 1}. **${r.title}** (${r.path})\n   ${r.matches[0] || ''}`
        )
        .join('\n\n')

      return {
        content: [
          {
            type: 'text',
            text: `æ‰¾åˆ° ${results.length} ä¸ªç›¸å…³æ–‡æ¡£ï¼š\n\n${text}`,
          },
        ],
        structuredContent: { results },
      }
    }
  )

  // è·å–æ–‡æ¡£ç»“æ„
  server.registerTool(
    'get_doc_structure',
    {
      title: 'è·å–æ–‡æ¡£ç»“æ„',
      description: 'è·å–æŒ‡å®šæ–‡æ¡£çš„æ ‡é¢˜ç»“æ„ï¼ˆç›®å½•ï¼‰',
      inputSchema: {
        path: z.string().describe('æ–‡æ¡£è·¯å¾„ï¼ˆç›¸å¯¹è·¯å¾„ï¼‰'),
      },
    },
    async ({ path }) => {
      const doc = index.getDoc(path)

      if (!doc) {
        return {
          content: [{ type: 'text', text: `æ–‡æ¡£ä¸å­˜åœ¨ï¼š${path}` }],
          isError: true,
        }
      }

      const structure = doc.headings.map((h, i) => `${i + 1}. ${h}`).join('\n')

      return {
        content: [
          {
            type: 'text',
            text: `## ${doc.meta.title}\n\n**ç›®å½•ç»“æ„ï¼š**\n${structure}`,
          },
        ],
      }
    }
  )
}
```

### Resources å®ç°

```typescript
// src/resources.ts
import {
  McpServer,
  ResourceTemplate,
} from '@modelcontextprotocol/sdk/server/mcp.js'
import { DocIndex } from './utils/search.js'
import { extractSummary } from './utils/markdown.js'

export function registerResources(server: McpServer, index: DocIndex) {
  // æ–‡æ¡£ç´¢å¼•
  server.registerResource(
    'docs-index',
    'docs://index',
    {
      title: 'æ–‡æ¡£ç´¢å¼•',
      description: 'æ–‡æ¡£åº“çš„ç´¢å¼•å’Œç»Ÿè®¡ä¿¡æ¯',
      mimeType: 'application/json',
    },
    async (uri) => {
      const stats = index.getStats()
      const docs = index.getAllDocs().map((d) => ({
        path: d.path,
        title: d.meta.title,
        summary: extractSummary(d.content),
      }))

      return {
        contents: [
          {
            uri: uri.href,
            mimeType: 'application/json',
            text: JSON.stringify({ stats, docs }, null, 2),
          },
        ],
      }
    }
  )

  // å•ä¸ªæ–‡æ¡£
  server.registerResource(
    'doc-content',
    new ResourceTemplate('docs://{path*}', {
      list: async () => {
        const docs = index.getAllDocs()
        return {
          resources: docs.map((d) => ({
            uri: `docs://${d.path.split('/').slice(-1)[0]}`,
            name: d.meta.title,
            description: d.meta.description || extractSummary(d.content, 100),
            mimeType: 'text/markdown',
          })),
        }
      },
    }),
    {
      title: 'æ–‡æ¡£å†…å®¹',
      description: 'è®¿é—®å…·ä½“çš„æ–‡æ¡£å†…å®¹',
    },
    async (uri, { path }) => {
      // å°è¯•å¤šç§è·¯å¾„åŒ¹é…
      let doc = index.getDoc(path)
      if (!doc) {
        doc = index.getDoc(`${path}.md`)
      }
      if (!doc) {
        // å°è¯•æ–‡ä»¶ååŒ¹é…
        const docs = index.getAllDocs()
        doc = docs.find(
          (d) => d.path.endsWith(`/${path}`) || d.path.endsWith(`/${path}.md`)
        )
      }

      if (!doc) {
        return {
          contents: [
            {
              uri: uri.href,
              mimeType: 'text/plain',
              text: `æ–‡æ¡£ä¸å­˜åœ¨ï¼š${path}`,
            },
          ],
        }
      }

      const header = [
        `# ${doc.meta.title}`,
        doc.meta.description ? `\n> ${doc.meta.description}` : '',
        doc.meta.tags?.length ? `\n**æ ‡ç­¾ï¼š** ${doc.meta.tags.join(', ')}` : '',
        '\n---\n',
      ]
        .filter(Boolean)
        .join('')

      return {
        contents: [
          {
            uri: uri.href,
            mimeType: 'text/markdown',
            text: header + doc.content,
          },
        ],
      }
    }
  )
}
```

### Prompts å®ç°

```typescript
// src/prompts.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { z } from 'zod'
import { DocIndex } from './utils/search.js'
import { extractSummary } from './utils/markdown.js'

export function registerPrompts(server: McpServer, index: DocIndex) {
  // æ–‡æ¡£æ‘˜è¦
  server.registerPrompt(
    'summarize',
    {
      title: 'æ–‡æ¡£æ‘˜è¦',
      description: 'ç”ŸæˆæŒ‡å®šæ–‡æ¡£çš„æ‘˜è¦',
      argsSchema: {
        path: z.string().describe('æ–‡æ¡£è·¯å¾„'),
      },
    },
    ({ path }) => {
      const doc = index.getDoc(path)

      if (!doc) {
        return {
          messages: [
            {
              role: 'user',
              content: { type: 'text', text: `æ–‡æ¡£ä¸å­˜åœ¨ï¼š${path}` },
            },
          ],
        }
      }

      return {
        messages: [
          {
            role: 'user',
            content: {
              type: 'text',
              text: `è¯·ä¸ºä»¥ä¸‹æ–‡æ¡£ç”Ÿæˆä¸€ä¸ªç®€æ´çš„æ‘˜è¦ï¼ˆä¸è¶…è¿‡ 200 å­—ï¼‰ï¼š

# ${doc.meta.title}

${doc.content}

è¦æ±‚ï¼š
1. æ¦‚æ‹¬æ–‡æ¡£çš„ä¸»è¦å†…å®¹
2. åˆ—å‡ºå…³é”®è¦ç‚¹ï¼ˆ3-5 ä¸ªï¼‰
3. è¯´æ˜ç›®æ ‡è¯»è€…`,
            },
          },
        ],
      }
    }
  )

  // æ¦‚å¿µè§£é‡Š
  server.registerPrompt(
    'explain',
    {
      title: 'æ¦‚å¿µè§£é‡Š',
      description: 'è§£é‡Šæ–‡æ¡£ä¸­çš„ç‰¹å®šæ¦‚å¿µ',
      argsSchema: {
        concept: z.string().describe('è¦è§£é‡Šçš„æ¦‚å¿µ'),
        context: z.string().optional().describe('ä¸Šä¸‹æ–‡ï¼ˆå¯é€‰ï¼‰'),
      },
    },
    ({ concept, context }) => {
      // æœç´¢ç›¸å…³æ–‡æ¡£
      const results = index.search(concept, 3)

      let docContext = ''
      if (results.length > 0) {
        docContext = results
          .map((r) => {
            const doc = index.getDoc(r.path)
            return doc
              ? `## ${doc.meta.title}\n${extractSummary(doc.content, 500)}`
              : ''
          })
          .filter(Boolean)
          .join('\n\n')
      }

      return {
        messages: [
          {
            role: 'user',
            content: {
              type: 'text',
              text: `è¯·è§£é‡Šã€Œ${concept}ã€è¿™ä¸ªæ¦‚å¿µã€‚

${docContext ? `ä»¥ä¸‹æ˜¯ç›¸å…³æ–‡æ¡£å†…å®¹ä¾›å‚è€ƒï¼š\n\n${docContext}\n\n` : ''}
${context ? `é¢å¤–ä¸Šä¸‹æ–‡ï¼š${context}\n\n` : ''}
è¯·æä¾›ï¼š
1. ç®€æ˜å®šä¹‰
2. æ ¸å¿ƒè¦ç‚¹
3. å®é™…åº”ç”¨ç¤ºä¾‹
4. å¸¸è§è¯¯åŒºï¼ˆå¦‚æœ‰ï¼‰`,
            },
          },
        ],
      }
    }
  )

  // æ–‡æ¡£é—®ç­”
  server.registerPrompt(
    'qa',
    {
      title: 'æ–‡æ¡£é—®ç­”',
      description: 'åŸºäºæ–‡æ¡£å†…å®¹å›ç­”é—®é¢˜',
      argsSchema: {
        question: z.string().describe('ä½ çš„é—®é¢˜'),
      },
    },
    ({ question }) => {
      // æœç´¢ç›¸å…³å†…å®¹
      const results = index.search(question, 5)

      let context = ''
      if (results.length > 0) {
        context = results
          .map((r) => {
            const doc = index.getDoc(r.path)
            if (!doc) return ''
            return `### ${doc.meta.title}\n${doc.content.slice(0, 1000)}${doc.content.length > 1000 ? '...' : ''}`
          })
          .filter(Boolean)
          .join('\n\n---\n\n')
      }

      return {
        messages: [
          {
            role: 'user',
            content: {
              type: 'text',
              text: `è¯·æ ¹æ®ä»¥ä¸‹æ–‡æ¡£å†…å®¹å›ç­”æˆ‘çš„é—®é¢˜ã€‚

**é—®é¢˜ï¼š** ${question}

${context ? `**ç›¸å…³æ–‡æ¡£ï¼š**\n\n${context}` : '**æ³¨æ„ï¼š** æœªæ‰¾åˆ°ç›¸å…³æ–‡æ¡£ï¼Œè¯·åŸºäºä½ çš„çŸ¥è¯†å›ç­”ã€‚'}

è¯·æ³¨æ„ï¼š
1. å¦‚æœæ–‡æ¡£ä¸­æœ‰ç­”æ¡ˆï¼Œè¯·å¼•ç”¨å…·ä½“å†…å®¹
2. å¦‚æœæ–‡æ¡£ä¸­æ²¡æœ‰ç›´æ¥ç­”æ¡ˆï¼Œè¯·è¯´æ˜
3. å¯ä»¥è¡¥å……æ–‡æ¡£ä¹‹å¤–çš„ç›¸å…³çŸ¥è¯†`,
            },
          },
        ],
      }
    }
  )
}
```

### ä¸» Server æ–‡ä»¶

```typescript
// src/server.ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { DocIndex } from './utils/search.js'
import { registerTools } from './tools.js'
import { registerResources } from './resources.js'
import { registerPrompts } from './prompts.js'

export async function createServer(docsDir: string): Promise<McpServer> {
  // åˆ›å»ºæ–‡æ¡£ç´¢å¼•
  const index = new DocIndex(docsDir)
  await index.build()

  // åˆ›å»º MCP Server
  const server = new McpServer({
    name: 'docs-assistant',
    version: '1.0.0',
  })

  // æ³¨å†ŒåŠŸèƒ½
  registerTools(server, index)
  registerResources(server, index)
  registerPrompts(server, index)

  return server
}
```

### å…¥å£æ–‡ä»¶

```typescript
#!/usr/bin/env node
// src/index.ts
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'
import { createServer } from './server.js'
import { resolve } from 'path'

async function main() {
  // ä»å‘½ä»¤è¡Œå‚æ•°æˆ–ç¯å¢ƒå˜é‡è·å–æ–‡æ¡£ç›®å½•
  const docsDir = resolve(process.argv[2] || process.env.DOCS_DIR || './docs')

  console.error(`Docs directory: ${docsDir}`)

  try {
    const server = await createServer(docsDir)
    const transport = new StdioServerTransport()

    await server.connect(transport)
    console.error('MCP Docs Assistant is running')
  } catch (error) {
    console.error('Failed to start server:', error)
    process.exit(1)
  }
}

main()
```

## é…ç½®ä¸æµ‹è¯•

### ç¼–è¯‘é¡¹ç›®

```bash
pnpm install
pnpm build
```

### é…ç½® Claude Desktop

ç¼–è¾‘é…ç½®æ–‡ä»¶ï¼š

```json
{
  "mcpServers": {
    "docs-assistant": {
      "command": "node",
      "args": [
        "/path/to/mcp-docs-assistant/dist/index.js",
        "/path/to/your/docs"
      ]
    }
  }
}
```

### æµ‹è¯•ç”¨ä¾‹

é‡å¯ Claude Desktop åï¼Œå°è¯•ä»¥ä¸‹å¯¹è¯ï¼š

1. **æœç´¢æµ‹è¯•**

   > "æœç´¢å…³äº TypeScript çš„æ–‡æ¡£"

2. **é˜…è¯»æ–‡æ¡£**

   > "è¯·è¯»å– README.md çš„å†…å®¹"

3. **é—®ç­”æµ‹è¯•**

   > "æ ¹æ®æ–‡æ¡£ï¼Œå¦‚ä½•é…ç½® ESLintï¼Ÿ"

4. **æ‘˜è¦ç”Ÿæˆ**
   > "å¸®æˆ‘æ€»ç»“ä¸€ä¸‹ API æ–‡æ¡£çš„ä¸»è¦å†…å®¹"

## æ‰©å±•æ€è·¯

è¿™ä¸ªåŸºç¡€ç‰ˆæœ¬å¯ä»¥ç»§ç»­æ‰©å±•ï¼š

### 1. å¢é‡ç´¢å¼•

```typescript
// ç›‘å¬æ–‡ä»¶å˜åŒ–ï¼Œå¢é‡æ›´æ–°ç´¢å¼•
import { watch } from 'fs'

watch(docsDir, { recursive: true }, async (event, filename) => {
  if (filename?.endsWith('.md')) {
    await index.updateDoc(filename)
    // å‘é€èµ„æºå˜æ›´é€šçŸ¥
    await server.notification({
      method: 'notifications/resources/list_changed',
    })
  }
})
```

### 2. è¯­ä¹‰æœç´¢

é›†æˆå‘é‡æ•°æ®åº“å®ç°è¯­ä¹‰æœç´¢ï¼š

```typescript
import { embed } from './utils/embeddings.js'
import { vectorStore } from './utils/vector-store.js'

async function semanticSearch(query: string) {
  const queryVector = await embed(query)
  return vectorStore.search(queryVector, 10)
}
```

### 3. æ”¯æŒæ›´å¤šæ ¼å¼

```typescript
// æ”¯æŒ MDXã€RSTã€AsciiDoc ç­‰
const SUPPORTED_EXTENSIONS = ['.md', '.mdx', '.rst', '.adoc']
```

### 4. æ–‡æ¡£å†™å…¥

æ·»åŠ  Tool æ”¯æŒåˆ›å»º/ç¼–è¾‘æ–‡æ¡£ï¼š

```typescript
server.registerTool(
  'create_doc',
  {
    // ...
  },
  async ({ path, content }) => {
    await writeFile(path, content)
    await index.updateDoc(path)
    return { content: [{ type: 'text', text: `å·²åˆ›å»ºæ–‡æ¡£ï¼š${path}` }] }
  }
)
```

## å°ç»“

é€šè¿‡è¿™ä¸ªå®æˆ˜é¡¹ç›®ï¼Œæˆ‘ä»¬ç»¼åˆè¿ç”¨äº†ï¼š

âœ… **Tools** - æœç´¢æ–‡æ¡£ã€è·å–ç»“æ„
âœ… **Resources** - æš´éœ²æ–‡æ¡£ç´¢å¼•å’Œå†…å®¹
âœ… **Prompts** - é¢„è®¾æ‘˜è¦ã€è§£é‡Šã€é—®ç­”æ¨¡æ¿
âœ… **Transport** - stdio ä¼ è¾“
âœ… **å®ç”¨å·¥å…·** - Markdown è§£æã€å…¨æ–‡æœç´¢

è¿™ä¸ªæ–‡æ¡£åŠ©æ‰‹å¯ä»¥ä½œä¸ºä½ è‡ªå·±é¡¹ç›®çš„èµ·ç‚¹ï¼Œæ ¹æ®å®é™…éœ€æ±‚è¿›è¡Œæ‰©å±•ã€‚

## ç³»åˆ—æ€»ç»“

è‡³æ­¤ï¼ŒMCP ç³»åˆ—æ•™ç¨‹å…¨éƒ¨å®Œæˆã€‚æˆ‘ä»¬ä»å…¥é—¨åˆ°å®æˆ˜ï¼Œè¦†ç›–äº†ï¼š

1. MCP åŸºç¡€æ¦‚å¿µä¸æ¶æ„
2. Server å¼€å‘ä¸ Tools å®ç°
3. Resources æ•°æ®æš´éœ²
4. Prompts äº¤äº’æ¨¡æ¿
5. Transport ä¸éƒ¨ç½²
6. Client é›†æˆä¸ LLM åä½œ
7. å®Œæ•´å®æˆ˜é¡¹ç›®

å¸Œæœ›è¿™ä¸ªç³»åˆ—èƒ½å¸®åŠ©ä½ å¿«é€Ÿä¸Šæ‰‹ MCPï¼Œæ„å»ºæ›´å¼ºå¤§çš„ AI åº”ç”¨ï¼

## å‚è€ƒèµ„æ–™

- [MCP å®˜æ–¹æ–‡æ¡£](https://modelcontextprotocol.io)
- [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- [å®˜æ–¹ Server ç¤ºä¾‹](https://github.com/modelcontextprotocol/servers)
- [gray-matter](https://github.com/jonschlinkert/gray-matter) - Frontmatter è§£æ
