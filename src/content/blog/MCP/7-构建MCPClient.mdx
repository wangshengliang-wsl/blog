---
title: 'æ„å»º MCP Clientï¼šé›†æˆåˆ°ä½ çš„åº”ç”¨'
description: 'å­¦ä¹ å¦‚ä½•ä½¿ç”¨ MCP TypeScript SDK æ„å»º Clientï¼Œè¿æ¥ MCP Serverï¼Œè°ƒç”¨ Toolsã€è¯»å– Resourcesï¼Œå¹¶ä¸ LLM é›†æˆ'
pubDate: 2025-12-03
toc: true
ogImage: true
category: 'MCP'
tags: ['MCP', 'Model Context Protocol', 'TypeScript', 'Client', 'LLM']
---

å‰é¢çš„æ–‡ç« æˆ‘ä»¬éƒ½åœ¨æ„å»º MCP Serverã€‚ç°åœ¨è®©æˆ‘ä»¬æ¢ä¸ªè§†è§’â€”â€”å­¦ä¹ å¦‚ä½•æ„å»º MCP Clientï¼Œå°† MCP Server çš„èƒ½åŠ›é›†æˆåˆ°ä½ è‡ªå·±çš„åº”ç”¨ä¸­ã€‚

## ğŸ¯ Client çš„è§’è‰²

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ä½ çš„åº”ç”¨ï¼ˆHostï¼‰               â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Client Aâ”‚  â”‚ Client Bâ”‚  â”‚ Client Câ”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚            â”‚            â”‚
        â–¼            â–¼            â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Server  â”‚  â”‚ Server  â”‚  â”‚ Server  â”‚
   â”‚ (æ–‡ä»¶)   â”‚  â”‚ (æ•°æ®åº“) â”‚  â”‚ (API)   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Client è´Ÿè´£ï¼š

- è¿æ¥å¹¶ç®¡ç† MCP Server
- è°ƒç”¨ Server æä¾›çš„ Tools
- è¯»å– Server æš´éœ²çš„ Resources
- è·å– Server å®šä¹‰çš„ Prompts
- ä¸º Server æä¾› LLM é‡‡æ ·èƒ½åŠ›

## è¿æ¥æœ¬åœ° Serverï¼ˆstdioï¼‰

### åŸºç¡€è¿æ¥

```typescript
// client.ts
import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'

async function main() {
  // åˆ›å»º Client
  const client = new Client({
    name: 'my-app',
    version: '1.0.0',
  })

  // é…ç½® stdio ä¼ è¾“ï¼ˆå¯åŠ¨ Server è¿›ç¨‹ï¼‰
  const transport = new StdioClientTransport({
    command: 'node',
    args: ['path/to/server.js'],
  })

  // è¿æ¥
  await client.connect(transport)
  console.log('Connected to MCP Server')

  // ä½¿ç”¨å®Œæ¯•åå…³é—­
  await client.close()
}

main()
```

### è·å– Server ä¿¡æ¯

```typescript
// è¿æ¥åå¯ä»¥è·å– Server çš„èƒ½åŠ›ä¿¡æ¯
const serverInfo = client.getServerVersion()
console.log(`Server: ${serverInfo?.name} v${serverInfo?.version}`)

// è·å– Server æ”¯æŒçš„èƒ½åŠ›
const capabilities = client.getServerCapabilities()
console.log('Capabilities:', capabilities)
```

## è¿æ¥è¿œç¨‹ Serverï¼ˆHTTPï¼‰

```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js'

const client = new Client({
  name: 'my-app',
  version: '1.0.0',
})

const transport = new StreamableHTTPClientTransport(
  new URL('http://localhost:3000/mcp')
)

await client.connect(transport)
```

### å¸¦è®¤è¯çš„è¿æ¥

```typescript
const transport = new StreamableHTTPClientTransport(
  new URL('https://api.example.com/mcp'),
  {
    requestInit: {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    },
  }
)
```

## è°ƒç”¨ Tools

### åˆ—å‡ºå¯ç”¨ Tools

```typescript
const toolsResult = await client.listTools()

console.log('Available tools:')
for (const tool of toolsResult.tools) {
  console.log(`  - ${tool.name}: ${tool.description}`)
}
```

### è°ƒç”¨ Tool

```typescript
// è°ƒç”¨ Tool
const result = await client.callTool({
  name: 'add',
  arguments: { a: 5, b: 3 },
})

// å¤„ç†ç»“æœ
for (const content of result.content) {
  if (content.type === 'text') {
    console.log('Result:', content.text)
  }
}

// è·å–ç»“æ„åŒ–è¾“å‡ºï¼ˆå¦‚æœæœ‰ï¼‰
if (result.structuredContent) {
  console.log('Structured:', result.structuredContent)
}

// æ£€æŸ¥æ˜¯å¦å‡ºé”™
if (result.isError) {
  console.error('Tool returned an error')
}
```

### å¸¦è¿›åº¦çš„ Tool è°ƒç”¨

```typescript
// ç›‘å¬è¿›åº¦é€šçŸ¥
client.setNotificationHandler('notifications/progress', (notification) => {
  const { progress, total, message } = notification.params
  console.log(`Progress: ${progress}/${total} - ${message}`)
})

// è°ƒç”¨å¯èƒ½è€—æ—¶çš„ Tool
const result = await client.callTool({
  name: 'process_files',
  arguments: { files: ['a.txt', 'b.txt', 'c.txt'] },
})
```

## è¯»å– Resources

### åˆ—å‡ºå¯ç”¨ Resources

```typescript
const resourcesResult = await client.listResources()

console.log('Available resources:')
for (const resource of resourcesResult.resources) {
  console.log(`  - ${resource.uri}: ${resource.name}`)
}
```

### è¯»å– Resource å†…å®¹

```typescript
const resourceData = await client.readResource({
  uri: 'config://app/settings',
})

for (const content of resourceData.contents) {
  console.log(`URI: ${content.uri}`)
  console.log(`Content: ${content.text}`)
}
```

### è®¢é˜… Resource å˜æ›´

```typescript
// è®¢é˜…èµ„æºå˜æ›´é€šçŸ¥
await client.subscribeResource({ uri: 'metrics://system/current' })

// å¤„ç†å˜æ›´é€šçŸ¥
client.setNotificationHandler(
  'notifications/resources/updated',
  async (notification) => {
    const { uri } = notification.params
    console.log(`Resource updated: ${uri}`)

    // é‡æ–°è¯»å–æ›´æ–°åçš„èµ„æº
    const data = await client.readResource({ uri })
    console.log('New content:', data.contents[0].text)
  }
)
```

## è·å– Prompts

### åˆ—å‡ºå¯ç”¨ Prompts

```typescript
const promptsResult = await client.listPrompts()

console.log('Available prompts:')
for (const prompt of promptsResult.prompts) {
  console.log(`  - ${prompt.name}: ${prompt.description}`)
  if (prompt.arguments) {
    console.log(
      `    Arguments: ${prompt.arguments.map((a) => a.name).join(', ')}`
    )
  }
}
```

### è·å– Prompt å†…å®¹

```typescript
const promptResult = await client.getPrompt({
  name: 'code-review',
  arguments: {
    code: 'function add(a, b) { return a + b; }',
    focus: 'performance',
  },
})

// promptResult.messages åŒ…å«ç”Ÿæˆçš„æ¶ˆæ¯
for (const message of promptResult.messages) {
  console.log(`[${message.role}]: ${message.content.text}`)
}
```

### å‚æ•°è‡ªåŠ¨è¡¥å…¨

```typescript
const completions = await client.complete({
  ref: { type: 'ref/prompt', name: 'team-greeting' },
  argument: { name: 'department', value: 'eng' },
  context: { arguments: {} },
})

console.log('Suggestions:', completions.completion.values)
```

## ä¸ LLM é›†æˆ

å°† MCP Client ä¸ LLMï¼ˆå¦‚ OpenAIã€Anthropicï¼‰é›†æˆï¼Œå®ç° AI Agentã€‚

### æ¶æ„ç¤ºæ„

```
ç”¨æˆ·è¾“å…¥
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LLM    â”‚ â†â”€â†’ â”‚  ä½ çš„   â”‚ â†â”€â†’ MCP Server
â”‚(Claude) â”‚     â”‚  åº”ç”¨   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å®Œæ•´ç¤ºä¾‹ï¼šOpenAI + MCP

```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'
import OpenAI from 'openai'

const openai = new OpenAI()

// 1. è¿æ¥ MCP Server
const mcpClient = new Client({ name: 'agent', version: '1.0.0' })
const transport = new StdioClientTransport({
  command: 'node',
  args: ['server.js'],
})
await mcpClient.connect(transport)

// 2. è·å– Tools å¹¶è½¬æ¢ä¸º OpenAI æ ¼å¼
const { tools } = await mcpClient.listTools()

const openaiTools = tools.map((tool) => ({
  type: 'function' as const,
  function: {
    name: tool.name,
    description: tool.description,
    parameters: tool.inputSchema,
  },
}))

// 3. å¯¹è¯å¾ªç¯
async function chat(userMessage: string) {
  const messages: OpenAI.ChatCompletionMessageParam[] = [
    { role: 'user', content: userMessage },
  ]

  while (true) {
    const response = await openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages,
      tools: openaiTools,
    })

    const choice = response.choices[0]
    messages.push(choice.message)

    // å¦‚æœæ²¡æœ‰ tool_callsï¼Œè¿”å›æœ€ç»ˆå“åº”
    if (!choice.message.tool_calls || choice.finish_reason === 'stop') {
      return choice.message.content
    }

    // å¤„ç† tool calls
    for (const toolCall of choice.message.tool_calls) {
      const { name, arguments: args } = toolCall.function

      console.log(`Calling tool: ${name}`)
      const result = await mcpClient.callTool({
        name,
        arguments: JSON.parse(args),
      })

      // å°†ç»“æœæ·»åŠ åˆ°æ¶ˆæ¯ä¸­
      messages.push({
        role: 'tool',
        tool_call_id: toolCall.id,
        content: result.content
          .map((c) => (c.type === 'text' ? c.text : JSON.stringify(c)))
          .join('\n'),
      })
    }
  }
}

// ä½¿ç”¨
const response = await chat('å¸®æˆ‘è®¡ç®— 123 + 456')
console.log('AI:', response)

await mcpClient.close()
```

### Anthropic Claude é›†æˆ

```typescript
import Anthropic from '@anthropic-ai/sdk'
import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'

const anthropic = new Anthropic()

// è¿æ¥ MCP Server
const mcpClient = new Client({ name: 'claude-agent', version: '1.0.0' })
await mcpClient.connect(
  new StdioClientTransport({
    command: 'node',
    args: ['server.js'],
  })
)

// è·å–å¹¶è½¬æ¢ Tools
const { tools } = await mcpClient.listTools()

const claudeTools = tools.map((tool) => ({
  name: tool.name,
  description: tool.description || '',
  input_schema: tool.inputSchema,
}))

async function chat(userMessage: string) {
  const messages: Anthropic.MessageParam[] = [
    { role: 'user', content: userMessage },
  ]

  while (true) {
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4096,
      tools: claudeTools,
      messages,
    })

    // å¤„ç†å“åº”å†…å®¹
    let hasToolUse = false
    const assistantContent: Anthropic.ContentBlock[] = []
    const toolResults: Anthropic.ToolResultBlockParam[] = []

    for (const block of response.content) {
      assistantContent.push(block)

      if (block.type === 'tool_use') {
        hasToolUse = true

        console.log(`Calling tool: ${block.name}`)
        const result = await mcpClient.callTool({
          name: block.name,
          arguments: block.input as Record<string, unknown>,
        })

        toolResults.push({
          type: 'tool_result',
          tool_use_id: block.id,
          content: result.content
            .map((c) => (c.type === 'text' ? c.text : JSON.stringify(c)))
            .join('\n'),
        })
      }
    }

    messages.push({ role: 'assistant', content: assistantContent })

    if (!hasToolUse || response.stop_reason === 'end_turn') {
      // æå–æ–‡æœ¬å“åº”
      return response.content
        .filter((b) => b.type === 'text')
        .map((b) => (b as Anthropic.TextBlock).text)
        .join('\n')
    }

    // æ·»åŠ  tool results
    messages.push({ role: 'user', content: toolResults })
  }
}
```

## LLM Samplingï¼šè®© Server è°ƒç”¨ Client çš„ LLM

MCP çš„é«˜çº§ç‰¹æ€§â€”â€”Server å¯ä»¥è¯·æ±‚ Client è¿›è¡Œ LLM é‡‡æ ·ï¼š

```typescript
// Client ç«¯ï¼šæä¾› sampling èƒ½åŠ›
const client = new Client(
  { name: 'sampling-client', version: '1.0.0' },
  {
    capabilities: {
      sampling: {}, // å£°æ˜æ”¯æŒ sampling
    },
  }
)

// å¤„ç† Server çš„ sampling è¯·æ±‚
client.setRequestHandler('sampling/createMessage', async (request) => {
  const { messages, maxTokens } = request.params

  // ä½¿ç”¨ä½ çš„ LLM ç”Ÿæˆå“åº”
  const response = await openai.chat.completions.create({
    model: 'gpt-4-turbo-preview',
    messages: messages.map((m) => ({
      role: m.role as 'user' | 'assistant',
      content: m.content.type === 'text' ? m.content.text : '',
    })),
    max_tokens: maxTokens,
  })

  return {
    role: 'assistant',
    content: {
      type: 'text',
      text: response.choices[0].message.content || '',
    },
    model: 'gpt-4-turbo-preview',
    stopReason: 'endTurn',
  }
})
```

ç°åœ¨ Server ç«¯çš„ Tool å¯ä»¥è°ƒç”¨ LLMï¼š

```typescript
// Server ç«¯
server.registerTool(
  'summarize',
  {
    title: 'æ–‡æœ¬æ‘˜è¦',
    description: 'ä½¿ç”¨ AI ç”Ÿæˆæ–‡æœ¬æ‘˜è¦',
    inputSchema: { text: z.string() },
  },
  async ({ text }) => {
    // è¯·æ±‚ Client çš„ LLM èƒ½åŠ›
    const response = await server.server.createMessage({
      messages: [
        {
          role: 'user',
          content: { type: 'text', text: `è¯·ç”¨ä¸€å¥è¯æ€»ç»“ï¼š\n\n${text}` },
        },
      ],
      maxTokens: 100,
    })

    return {
      content: [{ type: 'text', text: response.content.text }],
    }
  }
)
```

## å¤š Server ç®¡ç†

```typescript
class McpManager {
  private clients = new Map<string, Client>()

  async connect(name: string, config: ServerConfig) {
    const client = new Client({ name: 'manager', version: '1.0.0' })

    const transport =
      config.type === 'stdio'
        ? new StdioClientTransport(config)
        : new StreamableHTTPClientTransport(new URL(config.url))

    await client.connect(transport)
    this.clients.set(name, client)

    return client
  }

  getClient(name: string) {
    return this.clients.get(name)
  }

  async callTool(
    serverName: string,
    toolName: string,
    args: Record<string, unknown>
  ) {
    const client = this.clients.get(serverName)
    if (!client) throw new Error(`Server ${serverName} not found`)

    return client.callTool({ name: toolName, arguments: args })
  }

  async disconnectAll() {
    for (const [name, client] of this.clients) {
      await client.close()
      console.log(`Disconnected from ${name}`)
    }
    this.clients.clear()
  }
}

// ä½¿ç”¨
const manager = new McpManager()

await manager.connect('files', {
  type: 'stdio',
  command: 'node',
  args: ['file-server.js'],
})

await manager.connect('db', {
  type: 'http',
  url: 'http://localhost:3000/mcp',
})

const result = await manager.callTool('files', 'read_file', {
  path: 'config.json',
})
```

## é”™è¯¯å¤„ç†

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js'

try {
  await client.callTool({ name: 'unknown', arguments: {} })
} catch (error) {
  if (error instanceof McpError) {
    switch (error.code) {
      case ErrorCode.MethodNotFound:
        console.error('Tool not found')
        break
      case ErrorCode.InvalidParams:
        console.error('Invalid parameters')
        break
      default:
        console.error(`MCP Error: ${error.message}`)
    }
  } else {
    console.error('Unexpected error:', error)
  }
}
```

## å°ç»“

è¿™ç¯‡æ–‡ç« æˆ‘ä»¬å­¦ä¹ äº† MCP Client çš„æ„å»ºï¼š

âœ… ä½¿ç”¨ stdio å’Œ HTTP Transport è¿æ¥ Server
âœ… è°ƒç”¨ Toolsã€è¯»å– Resourcesã€è·å– Prompts
âœ… è®¢é˜… Resource å˜æ›´é€šçŸ¥
âœ… ä¸ OpenAI/Anthropic LLM é›†æˆ
âœ… LLM Sampling æœºåˆ¶
âœ… å¤š Server ç®¡ç†
âœ… é”™è¯¯å¤„ç†

ä¸‹ä¸€ç¯‡æ˜¯æœ¬ç³»åˆ—çš„æœ€åä¸€ç¯‡â€”â€”å®æˆ˜é¡¹ç›®ï¼Œæˆ‘ä»¬å°†ç»¼åˆè¿ç”¨æ‰€å­¦çŸ¥è¯†æ„å»ºä¸€ä¸ªå®Œæ•´çš„æ–‡æ¡£åŠ©æ‰‹ MCP Serverã€‚

## å‚è€ƒèµ„æ–™

- [MCP Client æ–‡æ¡£](https://modelcontextprotocol.io/docs/concepts/clients)
- [OpenAI Function Calling](https://platform.openai.com/docs/guides/function-calling)
- [Anthropic Tool Use](https://docs.anthropic.com/claude/docs/tool-use)
