---
title: æ„å»ºMCP Clientï¼šæ‰“é€ ä½ çš„AIåº”ç”¨
description: å­¦ä¹ å¦‚ä½•å¼€å‘MCP Clientï¼Œå®ç°ä¸å¤šä¸ªMCP Serverçš„è¿æ¥ç®¡ç†ï¼Œå°†MCPèƒ½åŠ›é›†æˆåˆ°è‡ªå·±çš„AIåº”ç”¨ä¸­
pubDate: 2025-12-13
toc: true
ogImage: true
category: MCP
---

å‰å‡ ç¯‡éƒ½åœ¨è®² Server ç«¯å¼€å‘ã€‚è¿™ç¯‡æ¢ä¸ªè§†è§’â€”â€”å¦‚ä½•å¼€å‘ MCP Clientï¼ŒæŠŠ MCP çš„èƒ½åŠ›é›†æˆåˆ°è‡ªå·±çš„ AI åº”ç”¨ä¸­ã€‚

## Host ä¸ Client çš„å…³ç³»

å…ˆå›é¡¾ä¸€ä¸‹ MCP æ¶æ„ä¸­çš„è§’è‰²ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Host                       â”‚
â”‚              (ä½ çš„ AI åº”ç”¨)                   â”‚
â”‚                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚ Client 1 â”‚  â”‚ Client 2 â”‚  â”‚ Client 3 â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚             â”‚             â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ Server  â”‚   â”‚ Server  â”‚   â”‚ Server  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- **Host**ï¼šä½ çš„ AI åº”ç”¨ï¼Œè´Ÿè´£ç”¨æˆ·äº¤äº’ã€è°ƒç”¨å¤§æ¨¡å‹ã€åè°ƒå„ä¸ª Client
- **Client**ï¼šè¿æ¥ç®¡ç†å™¨ï¼Œæ¯ä¸ª Client è´Ÿè´£ä¸ä¸€ä¸ª Server é€šä¿¡
- **Server**ï¼šæä¾› Toolsã€Resourcesã€Prompts çš„æœåŠ¡

å¼€å‘ MCP Client å°±æ˜¯è®©ä½ çš„åº”ç”¨èƒ½å¤Ÿï¼š

1. è¿æ¥ MCP Server
2. å‘ç° Server æä¾›çš„èƒ½åŠ›
3. è°ƒç”¨ Toolsã€è¯»å– Resourcesã€ä½¿ç”¨ Prompts
4. æŠŠè¿™äº›èƒ½åŠ›æ•´åˆåˆ°å¤§æ¨¡å‹å¯¹è¯ä¸­

## Client SDK åŸºç¡€

MCP TypeScript SDK æä¾›äº† `Client` ç±»ï¼š

```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'

// åˆ›å»º Client
const client = new Client({
  name: 'my-ai-app',
  version: '1.0.0',
})

// åˆ›å»º Transportï¼ˆå¯åŠ¨ Server è¿›ç¨‹ï¼‰
const transport = new StdioClientTransport({
  command: 'node',
  args: ['./path/to/server.js'],
})

// è¿æ¥
await client.connect(transport)

// ç°åœ¨å¯ä»¥è°ƒç”¨ Server çš„èƒ½åŠ›äº†
```

### è¿æ¥æœ¬åœ° Serverï¼ˆstdioï¼‰

stdio æ–¹å¼ä¼šå¯åŠ¨ Server ä½œä¸ºå­è¿›ç¨‹ï¼š

```typescript
import { spawn } from 'child_process'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'

const transport = new StdioClientTransport({
  command: 'node',
  args: ['./server/dist/index.js'],
  env: {
    ...process.env,
    CONFIG_DIR: '/path/to/config',
  },
})
```

### è¿æ¥è¿œç¨‹ Serverï¼ˆHTTPï¼‰

HTTP æ–¹å¼è¿æ¥è¿œç¨‹ Serverï¼š

```typescript
import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js'

const transport = new StreamableHTTPClientTransport(
  new URL('https://mcp-server.example.com/mcp')
)
```

## å‘ç°ä¸è°ƒç”¨èƒ½åŠ›

è¿æ¥å»ºç«‹åï¼Œå¯ä»¥å‘ç°å’Œä½¿ç”¨ Server çš„èƒ½åŠ›ã€‚

### åˆ—å‡ºå·¥å…·

```typescript
const toolsResult = await client.listTools()

console.log('å¯ç”¨å·¥å…·:')
for (const tool of toolsResult.tools) {
  console.log(`- ${tool.name}: ${tool.description}`)
}
```

### è°ƒç”¨å·¥å…·

```typescript
const result = await client.callTool({
  name: 'get_weather',
  arguments: { city: 'åŒ—äº¬' },
})

// result.content æ˜¯è¿”å›å†…å®¹æ•°ç»„
for (const item of result.content) {
  if (item.type === 'text') {
    console.log(item.text)
  }
}
```

### åˆ—å‡ºèµ„æº

```typescript
const resourcesResult = await client.listResources()

for (const resource of resourcesResult.resources) {
  console.log(`- ${resource.uri}: ${resource.name}`)
}
```

### è¯»å–èµ„æº

```typescript
const resource = await client.readResource({
  uri: 'config://app/settings',
})

for (const content of resource.contents) {
  if (content.text) {
    console.log(content.text)
  }
}
```

### åˆ—å‡ºæç¤ºè¯

```typescript
const promptsResult = await client.listPrompts()

for (const prompt of promptsResult.prompts) {
  console.log(`- ${prompt.name}: ${prompt.description}`)
}
```

### è·å–æç¤ºè¯å†…å®¹

```typescript
const prompt = await client.getPrompt({
  name: 'code-review',
  arguments: {
    language: 'TypeScript',
    code: 'function add(a, b) { return a + b }',
  },
})

// prompt.messages æ˜¯å¡«å……åçš„æ¶ˆæ¯æ•°ç»„
```

## ä¸å¤§æ¨¡å‹é›†æˆ

å…³é”®é—®é¢˜ï¼š**å¦‚ä½•è®©å¤§æ¨¡å‹ä½¿ç”¨ MCP Toolsï¼Ÿ**

æ€è·¯æ˜¯æŠŠ MCP Tools è½¬æ¢æˆå¤§æ¨¡å‹çš„ Function Calling æ ¼å¼ã€‚

### è½¬æ¢ Tools æ ¼å¼

ä»¥ OpenAI ä¸ºä¾‹ï¼š

```typescript
import OpenAI from 'openai'

// MCP Tool è½¬ OpenAI Function
function mcpToolToOpenAIFunction(tool: Tool): OpenAI.ChatCompletionTool {
  return {
    type: 'function',
    function: {
      name: tool.name,
      description: tool.description || '',
      parameters: tool.inputSchema as any,
    },
  }
}

// è·å–æ‰€æœ‰å·¥å…·å¹¶è½¬æ¢
const toolsResult = await client.listTools()
const openaiTools = toolsResult.tools.map(mcpToolToOpenAIFunction)
```

### å¤„ç†å¤§æ¨¡å‹çš„å·¥å…·è°ƒç”¨

```typescript
const openai = new OpenAI()

async function chat(messages: OpenAI.ChatCompletionMessageParam[]) {
  const response = await openai.chat.completions.create({
    model: 'gpt-4',
    messages,
    tools: openaiTools,
  })

  const choice = response.choices[0]

  // æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒç”¨å·¥å…·
  if (choice.finish_reason === 'tool_calls' && choice.message.tool_calls) {
    const toolResults: OpenAI.ChatCompletionMessageParam[] = []

    for (const toolCall of choice.message.tool_calls) {
      const { name, arguments: argsStr } = toolCall.function
      const args = JSON.parse(argsStr)

      // è°ƒç”¨ MCP Tool
      const result = await client.callTool({ name, arguments: args })

      // æå–æ–‡æœ¬ç»“æœ
      const text = result.content
        .filter((c): c is { type: 'text'; text: string } => c.type === 'text')
        .map((c) => c.text)
        .join('\n')

      toolResults.push({
        role: 'tool',
        tool_call_id: toolCall.id,
        content: text,
      })
    }

    // æŠŠå·¥å…·ç»“æœå‘å›ç»™å¤§æ¨¡å‹
    return chat([...messages, choice.message, ...toolResults])
  }

  return choice.message.content
}
```

## å¤š Server ç®¡ç†

å®é™…åº”ç”¨é€šå¸¸éœ€è¦è¿æ¥å¤šä¸ª MCP Serverã€‚éœ€è¦è§£å†³å‡ ä¸ªé—®é¢˜ï¼š

### ç»Ÿä¸€ç®¡ç†è¿æ¥

```typescript
interface ServerConfig {
  name: string
  command: string
  args: string[]
  env?: Record<string, string>
}

class McpManager {
  private clients = new Map<string, Client>()

  async connect(config: ServerConfig): Promise<void> {
    const client = new Client({
      name: 'my-app',
      version: '1.0.0',
    })

    const transport = new StdioClientTransport({
      command: config.command,
      args: config.args,
      env: config.env,
    })

    await client.connect(transport)
    this.clients.set(config.name, client)

    console.log(`å·²è¿æ¥: ${config.name}`)
  }

  async connectAll(configs: ServerConfig[]): Promise<void> {
    await Promise.all(configs.map((c) => this.connect(c)))
  }

  getClient(name: string): Client | undefined {
    return this.clients.get(name)
  }

  async disconnectAll(): Promise<void> {
    for (const [name, client] of this.clients) {
      await client.close()
      console.log(`å·²æ–­å¼€: ${name}`)
    }
    this.clients.clear()
  }
}
```

### èšåˆæ‰€æœ‰å·¥å…·

```typescript
interface ToolWithSource {
  tool: Tool
  serverName: string
}

class McpManager {
  // ... å‰é¢çš„ä»£ç 

  async getAllTools(): Promise<ToolWithSource[]> {
    const allTools: ToolWithSource[] = []

    for (const [serverName, client] of this.clients) {
      const result = await client.listTools()
      for (const tool of result.tools) {
        allTools.push({ tool, serverName })
      }
    }

    return allTools
  }

  async callTool(
    serverName: string,
    toolName: string,
    args: Record<string, unknown>
  ) {
    const client = this.clients.get(serverName)
    if (!client) {
      throw new Error(`Server not found: ${serverName}`)
    }

    return client.callTool({ name: toolName, arguments: args })
  }
}
```

### å¤„ç†å·¥å…·åå†²çª

ä¸åŒ Server å¯èƒ½æœ‰åŒåå·¥å…·ï¼Œéœ€è¦æ·»åŠ å‰ç¼€æˆ–å‘½åç©ºé—´ï¼š

```typescript
async getAllToolsWithPrefix(): Promise<Map<string, { client: Client; originalName: string }>> {
  const toolMap = new Map()

  for (const [serverName, client] of this.clients) {
    const result = await client.listTools()
    for (const tool of result.tools) {
      // æ·»åŠ  server åä½œä¸ºå‰ç¼€
      const prefixedName = `${serverName}__${tool.name}`
      toolMap.set(prefixedName, {
        client,
        originalName: tool.name,
      })
    }
  }

  return toolMap
}
```

## å®æˆ˜ï¼šå‘½ä»¤è¡Œ AI åŠ©æ‰‹

æ•´åˆå‰é¢çš„çŸ¥è¯†ï¼Œæ„å»ºä¸€ä¸ªå¯ä»¥ä½¿ç”¨ MCP å·¥å…·çš„å‘½ä»¤è¡Œ AI åŠ©æ‰‹ï¼š

```typescript
// src/index.ts
import { Client } from '@modelcontextprotocol/sdk/client/index.js'
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'
import OpenAI from 'openai'
import * as readline from 'readline'

// é…ç½®
const MCP_SERVERS = [
  {
    name: 'file-tools',
    command: 'node',
    args: ['./servers/file-tools/dist/index.js'],
    env: { ALLOWED_DIR: process.cwd() },
  },
  {
    name: 'weather',
    command: 'node',
    args: ['./servers/weather/dist/index.js'],
  },
]

// MCP ç®¡ç†å™¨
class McpManager {
  private clients = new Map<string, Client>()
  private toolMap = new Map<
    string,
    { client: Client; originalName: string; serverName: string }
  >()

  async initialize(): Promise<void> {
    for (const config of MCP_SERVERS) {
      try {
        const client = new Client({ name: 'cli-assistant', version: '1.0.0' })
        const transport = new StdioClientTransport({
          command: config.command,
          args: config.args,
          env: { ...process.env, ...config.env },
        })

        await client.connect(transport)
        this.clients.set(config.name, client)
        console.log(`âœ“ å·²è¿æ¥ ${config.name}`)

        // æ”¶é›†å·¥å…·
        const tools = await client.listTools()
        for (const tool of tools.tools) {
          const key = `${config.name}__${tool.name}`
          this.toolMap.set(key, {
            client,
            originalName: tool.name,
            serverName: config.name,
          })
        }
      } catch (error) {
        console.error(`âœ— è¿æ¥ ${config.name} å¤±è´¥:`, error)
      }
    }
  }

  getOpenAITools(): OpenAI.ChatCompletionTool[] {
    const tools: OpenAI.ChatCompletionTool[] = []

    for (const [serverName, client] of this.clients) {
      // åŒæ­¥è·å–å·¥å…·ï¼ˆå‡è®¾å·²ç¼“å­˜ï¼‰
    }

    // ç®€åŒ–ï¼šç›´æ¥ä» toolMap æ„å»º
    for (const [prefixedName, info] of this.toolMap) {
      tools.push({
        type: 'function',
        function: {
          name: prefixedName,
          description: `[${info.serverName}] Tool`, // å®é™…åº”ç”¨ä¸­åº”è¯¥ç¼“å­˜æè¿°
          parameters: { type: 'object', properties: {} },
        },
      })
    }

    return tools
  }

  async callTool(
    prefixedName: string,
    args: Record<string, unknown>
  ): Promise<string> {
    const info = this.toolMap.get(prefixedName)
    if (!info) {
      return `é”™è¯¯: å·¥å…· ${prefixedName} ä¸å­˜åœ¨`
    }

    try {
      const result = await info.client.callTool({
        name: info.originalName,
        arguments: args,
      })

      return result.content
        .filter((c): c is { type: 'text'; text: string } => c.type === 'text')
        .map((c) => c.text)
        .join('\n')
    } catch (error) {
      return `è°ƒç”¨å¤±è´¥: ${(error as Error).message}`
    }
  }

  async close(): Promise<void> {
    for (const client of this.clients.values()) {
      await client.close()
    }
  }
}

// AI åŠ©æ‰‹
class Assistant {
  private openai: OpenAI
  private mcp: McpManager
  private messages: OpenAI.ChatCompletionMessageParam[] = []
  private tools: OpenAI.ChatCompletionTool[] = []

  constructor(mcp: McpManager) {
    this.openai = new OpenAI()
    this.mcp = mcp
  }

  async initialize(): Promise<void> {
    // è·å–æ‰€æœ‰ MCP å·¥å…·
    await this.refreshTools()

    // ç³»ç»Ÿæç¤º
    this.messages.push({
      role: 'system',
      content: `ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½åŠ©æ‰‹ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å·¥å…·æ¥å¸®åŠ©ç”¨æˆ·ï¼š
${this.tools.map((t) => `- ${t.function.name}: ${t.function.description}`).join('\n')}

è¯·æ ¹æ®ç”¨æˆ·éœ€æ±‚é€‰æ‹©åˆé€‚çš„å·¥å…·ã€‚å¦‚æœä¸éœ€è¦å·¥å…·ï¼Œç›´æ¥å›ç­”å³å¯ã€‚`,
    })
  }

  private async refreshTools(): Promise<void> {
    // ä» MCP è·å–å·¥å…·åˆ—è¡¨
    this.tools = []

    for (const [serverName, client] of (this.mcp as any).clients) {
      try {
        const result = await client.listTools()
        for (const tool of result.tools) {
          this.tools.push({
            type: 'function',
            function: {
              name: `${serverName}__${tool.name}`,
              description: tool.description || '',
              parameters: tool.inputSchema as any,
            },
          })
        }
      } catch (error) {
        console.error(`è·å– ${serverName} å·¥å…·å¤±è´¥`)
      }
    }
  }

  async chat(userMessage: string): Promise<string> {
    this.messages.push({ role: 'user', content: userMessage })

    while (true) {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4',
        messages: this.messages,
        tools: this.tools.length > 0 ? this.tools : undefined,
      })

      const choice = response.choices[0]
      const message = choice.message

      this.messages.push(message)

      // æ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒç”¨å·¥å…·
      if (choice.finish_reason === 'tool_calls' && message.tool_calls) {
        console.log('\nğŸ”§ è°ƒç”¨å·¥å…·ä¸­...')

        for (const toolCall of message.tool_calls) {
          const { name, arguments: argsStr } = toolCall.function
          const args = JSON.parse(argsStr)

          console.log(`   â†’ ${name}(${JSON.stringify(args)})`)

          const result = await this.mcp.callTool(name, args)

          console.log(
            `   â† ${result.slice(0, 100)}${result.length > 100 ? '...' : ''}`
          )

          this.messages.push({
            role: 'tool',
            tool_call_id: toolCall.id,
            content: result,
          })
        }

        // ç»§ç»­è®©å¤§æ¨¡å‹å¤„ç†å·¥å…·ç»“æœ
        continue
      }

      // æ²¡æœ‰å·¥å…·è°ƒç”¨ï¼Œè¿”å›æœ€ç»ˆå›å¤
      return message.content || ''
    }
  }
}

// ä¸»ç¨‹åº
async function main() {
  console.log('ğŸ¤– AI åŠ©æ‰‹å¯åŠ¨ä¸­...\n')

  // åˆå§‹åŒ– MCP
  const mcp = new McpManager()
  await mcp.initialize()

  // åˆå§‹åŒ–åŠ©æ‰‹
  const assistant = new Assistant(mcp)
  await assistant.initialize()

  console.log('\nâœ“ åˆå§‹åŒ–å®Œæˆï¼Œå¼€å§‹å¯¹è¯ï¼ˆè¾“å…¥ exit é€€å‡ºï¼‰\n')

  // å‘½ä»¤è¡Œäº¤äº’
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  })

  const prompt = () => {
    rl.question('ä½ : ', async (input) => {
      const trimmed = input.trim()

      if (trimmed.toLowerCase() === 'exit') {
        console.log('\nå†è§ï¼')
        await mcp.close()
        rl.close()
        return
      }

      if (!trimmed) {
        prompt()
        return
      }

      try {
        const response = await assistant.chat(trimmed)
        console.log(`\nåŠ©æ‰‹: ${response}\n`)
      } catch (error) {
        console.error(`\né”™è¯¯: ${(error as Error).message}\n`)
      }

      prompt()
    })
  }

  prompt()
}

main().catch(console.error)
```

### ä¾èµ–

```json
{
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "openai": "^4.0.0"
  }
}
```

### ä½¿ç”¨ç¤ºä¾‹

```bash
$ node dist/index.js

ğŸ¤– AI åŠ©æ‰‹å¯åŠ¨ä¸­...

âœ“ å·²è¿æ¥ file-tools
âœ“ å·²è¿æ¥ weather

âœ“ åˆå§‹åŒ–å®Œæˆï¼Œå¼€å§‹å¯¹è¯ï¼ˆè¾“å…¥ exit é€€å‡ºï¼‰

ä½ : å¸®æˆ‘çœ‹çœ‹å½“å‰ç›®å½•æœ‰å“ªäº›æ–‡ä»¶

ğŸ”§ è°ƒç”¨å·¥å…·ä¸­...
   â†’ file-tools__list_directory({"path":"."})
   â† ğŸ“ src
      ğŸ“ dist
      ğŸ“„ package.json
      ğŸ“„ tsconfig.json

åŠ©æ‰‹: å½“å‰ç›®å½•åŒ…å«ä»¥ä¸‹å†…å®¹ï¼š
- src/ - æºä»£ç ç›®å½•
- dist/ - ç¼–è¯‘è¾“å‡ºç›®å½•
- package.json - é¡¹ç›®é…ç½®
- tsconfig.json - TypeScript é…ç½®

ä½ : åŒ—äº¬å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ

ğŸ”§ è°ƒç”¨å·¥å…·ä¸­...
   â†’ weather__get_weather({"city":"åŒ—äº¬"})
   â† åŒ—äº¬å¤©æ°”ï¼šæ™´ï¼Œ25Â°Cï¼Œä¸œåŒ—é£3çº§

åŠ©æ‰‹: åŒ—äº¬ç°åœ¨å¤©æ°”ä¸é”™ï¼Œæ™´å¤©ï¼Œæ°”æ¸©25Â°Cï¼Œæœ‰ä¸œåŒ—é£3çº§ï¼Œå¾ˆé€‚åˆå¤–å‡ºæ´»åŠ¨ã€‚

ä½ : exit

å†è§ï¼
```

## é”™è¯¯å¤„ç†

Client å¼€å‘éœ€è¦å¤„ç†å„ç§é”™è¯¯æƒ…å†µï¼š

```typescript
async function safeCallTool(
  client: Client,
  name: string,
  args: Record<string, unknown>
): Promise<{ success: boolean; result?: string; error?: string }> {
  try {
    const result = await client.callTool({ name, arguments: args })

    // æ£€æŸ¥å·¥å…·æ˜¯å¦è¿”å›é”™è¯¯
    if (result.isError) {
      const errorText = result.content
        .filter((c): c is { type: 'text'; text: string } => c.type === 'text')
        .map((c) => c.text)
        .join('\n')

      return { success: false, error: errorText }
    }

    const text = result.content
      .filter((c): c is { type: 'text'; text: string } => c.type === 'text')
      .map((c) => c.text)
      .join('\n')

    return { success: true, result: text }
  } catch (error) {
    // è¿æ¥é”™è¯¯ã€è¶…æ—¶ç­‰
    return { success: false, error: (error as Error).message }
  }
}
```

## ä¸‹ä¸€æ­¥

è¿™ç¯‡è®²äº† Client å¼€å‘çš„æ ¸å¿ƒå†…å®¹ã€‚æœ€åä¸€ç¯‡ä¼šæ€»ç»“ MCP çš„æœ€ä½³å®è·µï¼ŒåŒ…æ‹¬å®‰å…¨ã€æ€§èƒ½å’Œç”Ÿäº§éƒ¨ç½²ã€‚

## å‚è€ƒ

- [MCP Client SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- [OpenAI Function Calling](https://platform.openai.com/docs/guides/function-calling)
- [Anthropic Tool Use](https://docs.anthropic.com/en/docs/build-with-claude/tool-use)
