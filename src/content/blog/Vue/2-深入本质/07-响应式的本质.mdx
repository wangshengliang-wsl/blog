---
title: '依赖收集与派发更新的本质'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '原理', '响应式']
description: '深入理解什么是依赖关系、如何建立依赖、以及何时触发更新'
---

🙋 响应式的核心是什么？

就是**数据变化时，相关函数自动重新执行**。这需要两步：

1. **依赖收集**：记录哪些函数用了哪些数据
2. **派发更新**：数据变化时，执行对应的函数

## 什么是依赖关系

**函数在运行时，读取了响应式数据（触发了 get 拦截），就建立了依赖关系**。

### 练习判断

```ts
// 示例 1
const a = ref(1)
function foo() {
  console.log(a) // ❌ 没有依赖，没有访问 .value
}

// 示例 2
const a = ref(1)
function foo() {
  console.log(a.value) // ✅ 有依赖，访问了 .value
}

// 示例 3
const a = ref({ b: 1 })
const k = a.value // 这里访问了 .value
function foo() {
  console.log(k.b) // ✅ 有依赖，访问了 k 的 b（k 是 Proxy）
}
```

### 异步代码不算

**依赖收集只发生在同步代码执行期间**：

```ts
const a = ref(1)

watchEffect(async () => {
  console.log(a.value) // ✅ 收集依赖
  await something()
  console.log(a.value) // ❌ 不收集，异步之后的代码
})
```

## 哪些函数会被监控

不是所有函数都会参与依赖收集，只有**被监控的函数**：

| 函数类型      | 说明                  |
| ------------- | --------------------- |
| `watchEffect` | 自动收集依赖          |
| `watch`       | 监听指定数据          |
| 组件渲染函数  | 模板编译生成的 render |
| `effect`      | 底层 API              |

普通函数即使用了响应式数据，也不会建立依赖。

## 练习题

### 题目 1

```ts
const state = ref({ a: 1 })
const k = state.value

watchEffect(() => {
  console.log('运行')
  state.value // 依赖 value
  state.value.a // 依赖 value 和 a
})

setTimeout(() => {
  state.value = { a: 3 } // 修改 value → 重新运行
}, 500)
```

### 题目 2

```ts
const state = ref({ a: 1 })

watchEffect(() => {
  console.log('运行')
  state.value.a // 依赖 value 和 a
})

setTimeout(() => {
  state.value.a = 1 // 值没变 → 不重新运行
}, 500)
```

### 题目 3

```ts
const state = ref({ a: 1 })
const k = state.value // k 是 Proxy

watchEffect(() => {
  console.log('运行')
  state.value.a // 依赖 value 和 a
})

setTimeout(() => {
  k.a = 2 // k 就是 state.value，修改 a → 重新运行
}, 500)
```

### 题目 4（易错）

```ts
const state = ref({ a: 1 })
const k = state.value

watchEffect(() => {
  console.log('运行')
  state.value.a // 依赖 value 和 a
})

setTimeout(() => {
  state.value = { a: 1 } // 新对象 → 重新运行
}, 500)

setTimeout(() => {
  k.a = 3 // ❌ k 是旧的 Proxy，已经和 state 断开了
}, 1000)
```

### 题目 5（赋值 vs 读取）

```ts
watchEffect(() => {
  console.log('运行')
  state.value.a = 2 // 只有 value 的 get，a 的 set 不收集依赖！
})

setTimeout(() => {
  state.value.a = 100 // ❌ 不重新运行（a 没被读取）
  state.value = {} // ✅ 重新运行（value 被读取过）
}, 500)
```

## 依赖收集的数据结构

Vue 内部用 WeakMap + Map + Set 存储依赖关系：

```
WeakMap {
  target → Map {
    key → Set [ effect1, effect2, ... ]
  }
}
```

```ts
// 伪代码
const targetMap = new WeakMap()

function track(target, key) {
  // 获取当前正在运行的 effect
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  let deps = depsMap.get(key)
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  deps.add(activeEffect) // 收集当前 effect
}

function trigger(target, key) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return
  const effects = depsMap.get(key)
  effects?.forEach((effect) => effect()) // 执行所有依赖的函数
}
```

## 小结

| 概念     | 说明                       |
| -------- | -------------------------- |
| 依赖     | 函数运行时读取响应式数据   |
| 收集     | 读取时记录函数和数据的关系 |
| 派发     | 数据变化时执行相关函数     |
| 监控函数 | watchEffect、watch、render |
| 异步     | await 之后的代码不收集依赖 |

🎯 **核心公式**：`被监控函数 + 同步运行 + 读取拦截 = 建立依赖`

下一篇我们来看响应式如何驱动组件渲染。
