---
title: '完整的依赖收集数据结构'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '原理', '响应式']
description: '深入理解 Vue3 依赖收集的数据结构设计，以及 track 和 trigger 的完整实现'
---

## 数据结构设计

Vue3 使用三层结构存储依赖关系：

```
targetMap (WeakMap)
└── target (对象)
    └── depsMap (Map)
        └── key (属性名 / ITERATE_KEY)
            └── deps (Map)
                └── trackType (GET / HAS / ITERATE)
                    └── effects (Set)
                        └── [effectFn1, effectFn2, ...]
```

```ts
const targetMap = new WeakMap()

// target → depsMap → key → trackTypeMap → effects
```

为什么需要区分 trackType？

因为不同的读取方式，在触发更新时需要不同的处理：

| 读取方式     | trackType | 触发条件            |
| ------------ | --------- | ------------------- |
| `obj.key`    | GET       | SET/DELETE key      |
| `key in obj` | HAS       | ADD/DELETE key      |
| `for...in`   | ITERATE   | ADD/DELETE 任意 key |

## track 实现

```ts
export let activeEffect = undefined
export const targetMap = new WeakMap()

export function track(target, trackType, key) {
  if (!activeEffect) return

  // 获取或创建 depsMap
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }

  // 获取或创建 trackTypeMap
  let trackTypeMap = depsMap.get(key)
  if (!trackTypeMap) {
    depsMap.set(key, (trackTypeMap = new Map()))
  }

  // 获取或创建 effects
  let effects = trackTypeMap.get(trackType)
  if (!effects) {
    trackTypeMap.set(trackType, (effects = new Set()))
  }

  // 收集 effect
  if (!effects.has(activeEffect)) {
    effects.add(activeEffect)
    activeEffect.deps.push(effects)
  }
}
```

## trigger 实现

```ts
// 操作类型映射
const triggerTypeMap = {
  SET: ['GET'],
  ADD: ['GET', 'ITERATE', 'HAS'],
  DELETE: ['GET', 'ITERATE', 'HAS'],
}

export function trigger(target, triggerType, key) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return

  const effectsToRun = new Set()

  // 收集需要执行的 effects
  const trackTypes = triggerTypeMap[triggerType]

  trackTypes.forEach((trackType) => {
    // 普通属性
    const trackTypeMap = depsMap.get(key)
    if (trackTypeMap) {
      const effects = trackTypeMap.get(trackType)
      effects?.forEach((effect) => {
        if (effect !== activeEffect) {
          effectsToRun.add(effect)
        }
      })
    }

    // ITERATE 类型需要特殊处理
    if (trackType === 'ITERATE') {
      const iterateMap = depsMap.get(ITERATE_KEY)
      if (iterateMap) {
        const effects = iterateMap.get('ITERATE')
        effects?.forEach((effect) => {
          if (effect !== activeEffect) {
            effectsToRun.add(effect)
          }
        })
      }
    }
  })

  // 执行所有收集到的 effects
  effectsToRun.forEach((effect) => {
    if (effect.scheduler) {
      effect.scheduler(effect)
    } else {
      effect()
    }
  })
}
```

## effect 完整实现

```ts
const effectStack = []

export function effect(fn, options = {}) {
  const effectFn = () => {
    try {
      activeEffect = effectFn
      effectStack.push(effectFn)
      cleanup(effectFn)
      return fn()
    } finally {
      effectStack.pop()
      activeEffect = effectStack[effectStack.length - 1]
    }
  }

  effectFn.deps = []
  effectFn.scheduler = options.scheduler

  if (!options.lazy) {
    effectFn()
  }

  return effectFn
}

function cleanup(effectFn) {
  effectFn.deps.forEach((dep) => dep.delete(effectFn))
  effectFn.deps.length = 0
}
```

## 配置选项

### lazy：懒执行

```ts
const runner = effect(
  () => {
    console.log(state.count)
  },
  { lazy: true }
)

// 不会立即执行，需要手动调用
runner()
```

### scheduler：调度器

```ts
effect(
  () => {
    console.log(state.count)
  },
  {
    scheduler(effectFn) {
      // 自定义执行时机
      setTimeout(effectFn, 100)
      // 或放入队列
      queueJob(effectFn)
    },
  }
)
```

Vue 用 scheduler 实现批量更新：

```ts
const queue = new Set()
let isFlushing = false

function queueJob(job) {
  queue.add(job)
  if (!isFlushing) {
    isFlushing = true
    Promise.resolve().then(() => {
      queue.forEach((job) => job())
      queue.clear()
      isFlushing = false
    })
  }
}
```

## 图示

```
state.count = 1

         ┌──────────────────────────────────────┐
         │           targetMap (WeakMap)        │
         └──────────────────────────────────────┘
                          │
                          ▼
         ┌──────────────────────────────────────┐
         │    state → depsMap (Map)             │
         └──────────────────────────────────────┘
                          │
                          ▼
         ┌──────────────────────────────────────┐
         │   'count' → trackTypeMap (Map)       │
         └──────────────────────────────────────┘
                          │
                          ▼
         ┌──────────────────────────────────────┐
         │    'GET' → effects (Set)             │
         │           [effectFn1, effectFn2]     │
         └──────────────────────────────────────┘
```

## 小结

| 组件         | 类型    | 作用                     |
| ------------ | ------- | ------------------------ |
| targetMap    | WeakMap | 存储所有响应式对象的依赖 |
| depsMap      | Map     | 存储单个对象各属性的依赖 |
| trackTypeMap | Map     | 区分不同读取方式的依赖   |
| effects      | Set     | 存储具体的 effect 函数   |
| scheduler    | 函数    | 自定义 effect 执行时机   |

下一篇我们来实现 computed。
