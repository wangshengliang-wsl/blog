---
title: '手写 watch 实现'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '原理', 'watch']
description: '从零实现 watch，理解侦听器的工作原理'
---

## watch 的特点

1. 侦听响应式数据的变化
2. 变化时执行回调，传入新旧值
3. 支持 immediate、flush 等选项

## 核心思路

```ts
watch(source, callback, options)
```

1. 把 source 转换为 getter 函数
2. 用 effect 包装 getter，建立依赖
3. 依赖变化时，在 scheduler 中执行 callback

## 辅助函数：traverse

递归遍历对象，触发所有属性的依赖收集：

```ts
function traverse(value, seen = new Set()) {
  if (typeof value !== 'object' || value === null || seen.has(value)) {
    return value
  }
  seen.add(value)
  for (const key in value) {
    traverse(value[key], seen)
  }
  return value
}
```

为什么需要 traverse？

当 source 是一个对象时，需要递归访问所有属性，才能收集到所有属性的依赖。

## 基础实现

```ts
function watch(source, cb, options = {}) {
  // 1. 参数归一化
  let getter
  if (typeof source === 'function') {
    getter = source
  } else {
    getter = () => traverse(source) // 递归访问，收集所有依赖
  }

  let oldValue, newValue

  // 2. 定义执行回调的函数
  const job = () => {
    newValue = effectFn()
    cb(newValue, oldValue)
    oldValue = newValue
  }

  // 3. 创建 effect
  const effectFn = effect(getter, {
    lazy: true,
    scheduler: job,
  })

  // 4. 首次执行
  oldValue = effectFn()
}
```

## 支持 immediate

```ts
if (options.immediate) {
  job() // 立即执行一次回调
} else {
  oldValue = effectFn() // 只计算旧值，不执行回调
}
```

## 支持 flush: 'post'

```ts
const effectFn = effect(getter, {
  lazy: true,
  scheduler: () => {
    if (options.flush === 'post') {
      // 放到微任务队列，DOM 更新后执行
      Promise.resolve().then(job)
    } else {
      job()
    }
  },
})
```

## 返回停止函数

```ts
return () => {
  cleanup(effectFn) // 清除依赖
}
```

## 完整实现

```ts
import { effect, cleanup } from './effect'

export function watch(source, cb, options = {}) {
  let getter
  if (typeof source === 'function') {
    getter = source
  } else {
    getter = () => traverse(source)
  }

  let oldValue, newValue

  const job = () => {
    newValue = effectFn()
    cb(newValue, oldValue)
    oldValue = newValue
  }

  const effectFn = effect(getter, {
    lazy: true,
    scheduler: () => {
      if (options.flush === 'post') {
        Promise.resolve().then(job)
      } else {
        job()
      }
    },
  })

  if (options.immediate) {
    job()
  } else {
    oldValue = effectFn()
  }

  return () => {
    cleanup(effectFn)
  }
}

function traverse(value, seen = new Set()) {
  if (typeof value !== 'object' || value === null || seen.has(value)) {
    return value
  }
  seen.add(value)
  for (const key in value) {
    traverse(value[key], seen)
  }
  return value
}
```

## 执行流程

```ts
const state = reactive({ count: 0 })
watch(
  () => state.count,
  (newVal, oldVal) => {
    console.log(newVal, oldVal)
  }
)
```

```
1. watch 初始化
   └── getter = () => state.count
   └── effect(getter, { lazy: true, scheduler })
   └── oldValue = effectFn() = 0
       └── 读取 state.count，收集依赖

2. state.count = 1
   └── trigger(state, 'count')
       └── 执行 scheduler
           └── job()
               └── newValue = effectFn() = 1
               └── cb(1, 0)
               └── oldValue = 1
```

## 小结

| 功能        | 实现方式               |
| ----------- | ---------------------- |
| 侦听对象    | traverse 递归访问      |
| 新旧值      | oldValue/newValue 变量 |
| immediate   | 初始化时执行 job       |
| flush: post | scheduler 中放入微任务 |
| 停止侦听    | cleanup 清除依赖       |

下一篇我们来看指令的本质。
