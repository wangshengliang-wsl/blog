---
title: '模板编译：从模板到渲染函数'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '原理', '编译器']
description: '理解 Vue 模板是如何被编译成渲染函数的，以及编译发生的时机'
---

🙋 Vue 的模板最终变成了什么？

## 模板的真相

Vue 运行时根本不需要模板，它只需要**渲染函数**。

```vue
<template>
  <div>
    <h1 :id="titleId">Hello</h1>
  </div>
</template>
```

编译后变成：

```js
function render() {
  return h('div', [h('h1', { id: titleId }, 'Hello')])
}
```

模板只是"语法糖"，让开发者写起来更方便。

## 直接写渲染函数

你完全可以跳过模板，直接写渲染函数：

```js
// UserCard.js（不是 .vue 文件）
import { defineComponent, h } from 'vue'

export default defineComponent({
  name: 'UserCard',
  props: ['name', 'email'],
  setup(props) {
    return () =>
      h('div', { class: 'card' }, [h('h2', props.name), h('p', props.email)])
  },
})
```

这就是 Vue 组件的本质——返回虚拟 DOM 的函数。

## 编译过程

模板编译器把模板字符串转换成渲染函数，分三步：

```
模板字符串 → 模板 AST → JS AST → 渲染函数
           解析器      转换器    生成器
```

### 1. 解析器（Parser）

把模板字符串解析成模板 AST：

```html
<div><p>Vue</p></div>
```

↓ 解析

```js
{
  type: 'Element',
  tag: 'div',
  children: [
    {
      type: 'Element',
      tag: 'p',
      children: [{ type: 'Text', content: 'Vue' }]
    }
  ]
}
```

### 2. 转换器（Transformer）

把模板 AST 转换成 JS AST：

```js
{
  type: 'FunctionDecl',
  id: { name: 'render' },
  body: [
    {
      type: 'ReturnStatement',
      return: {
        type: 'CallExpression',
        callee: { name: 'h' },
        arguments: ['div', [/* children */]]
      }
    }
  ]
}
```

### 3. 生成器（Generator）

把 JS AST 生成代码字符串：

```js
function render() {
  return h('div', [h('p', 'Vue')])
}
```

## 编译时机

### 预编译（推荐）

使用构建工具（Vite/Webpack）时，模板在**打包阶段**就编译好了：

```
.vue 文件 → 构建工具 → 纯 JS 代码（包含渲染函数）
```

浏览器拿到的是已编译的代码，不包含模板。

🎯 **优势**：

- 运行时不需要编译器
- 打包体积更小
- 启动更快

### 运行时编译

通过 CDN 直接使用 Vue 时，模板在**浏览器中**编译：

```html
<script src="https://unpkg.com/vue@3"></script>
<div id="app">
  {{ message }}
  <!-- 运行时编译 -->
</div>
```

需要引入包含编译器的完整版 Vue，体积更大。

## 查看编译结果

使用 `vite-plugin-inspect` 插件可以查看编译后的代码：

```ts
// vite.config.ts
import Inspect from 'vite-plugin-inspect'

export default {
  plugins: [Inspect()],
}
```

启动后访问 `http://localhost:5173/__inspect/` 查看。

或者使用 [Vue SFC Playground](https://play.vuejs.org/) 在线查看编译结果。

## 编译优化

Vue3 编译器会做很多优化：

### 静态提升

```vue
<template>
  <div>
    <p>静态文本</p>
    <!-- 不会变 -->
    <p>{{ dynamic }}</p>
  </div>
</template>
```

编译后：

```js
// 静态节点被提升到外面，只创建一次
const _hoisted = h('p', '静态文本')

function render() {
  return h('div', [
    _hoisted, // 复用
    h('p', dynamic),
  ])
}
```

### PatchFlag

标记动态节点的类型，diff 时跳过静态部分：

```js
h('p', { class: dynamicClass }, text, PatchFlags.CLASS | PatchFlags.TEXT)
// 告诉 diff：只需要检查 class 和 text
```

## 小结

| 概念       | 说明                  |
| ---------- | --------------------- |
| 模板       | 对开发者友好的语法糖  |
| 渲染函数   | Vue 真正需要的东西    |
| 编译过程   | 模板 → AST → 渲染函数 |
| 预编译     | 构建时编译，推荐      |
| 运行时编译 | 浏览器中编译，体积大  |

下一篇我们来看组件树和虚拟 DOM 树的关系。
