---
title: '手写 computed 实现'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '原理', 'computed']
description: '从零实现 computed，理解计算属性的缓存机制和依赖追踪'
---

## computed 的特点

1. **懒计算**：只有访问时才计算
2. **缓存**：依赖不变不重新计算
3. **可被追踪**：渲染函数依赖 computed 时，computed 变化会触发重渲染

## 基础实现

```ts
function computed(getterOrOptions) {
  // 1. 参数归一化
  let getter, setter
  if (typeof getterOrOptions === 'function') {
    getter = getterOrOptions
    setter = () => console.warn('Computed is readonly')
  } else {
    getter = getterOrOptions.get
    setter = getterOrOptions.set
  }

  let value
  let dirty = true // 标记是否需要重新计算

  // 2. 建立 getter 和响应式数据的依赖
  const effectFn = effect(getter, {
    lazy: true,
    scheduler() {
      dirty = true // 依赖变化时标记为脏
    },
  })

  // 3. 返回带有 value 属性的对象
  return {
    get value() {
      if (dirty) {
        value = effectFn() // 重新计算
        dirty = false
      }
      return value
    },
    set value(newValue) {
      setter(newValue)
    },
  }
}
```

## 问题：渲染函数依赖 computed

```ts
const sum = computed(() => state.a + state.b)

effect(() => {
  console.log(sum.value) // 渲染函数依赖 sum
})

state.a++ // sum 变化了，但渲染函数没有重新执行！
```

**原因**：渲染函数和 `sum.value` 之间没有建立依赖关系。

**解决**：在 `get value` 时手动 track，在 scheduler 中手动 trigger。

```ts
const effectFn = effect(getter, {
  lazy: true,
  scheduler() {
    dirty = true
    trigger(obj, 'SET', 'value') // 触发 value 的更新
  },
})

const obj = {
  get value() {
    track(obj, 'GET', 'value') // 收集对 value 的依赖
    if (dirty) {
      value = effectFn()
      dirty = false
    }
    return value
  },
  set value(newValue) {
    setter(newValue)
  },
}
return obj
```

## 完整实现

```ts
import { effect } from './effect'
import { track, trigger } from './reactivity'

function computed(getterOrOptions) {
  // 参数归一化
  let getter, setter
  if (typeof getterOrOptions === 'function') {
    getter = getterOrOptions
    setter = () => {
      console.warn('Computed property is readonly')
    }
  } else {
    getter = getterOrOptions.get
    setter = getterOrOptions.set
  }

  let value
  let dirty = true

  const effectFn = effect(getter, {
    lazy: true,
    scheduler() {
      if (!dirty) {
        dirty = true
        // 通知依赖 value 的函数重新执行
        trigger(obj, 'SET', 'value')
      }
    },
  })

  const obj = {
    get value() {
      // 收集对 value 的依赖
      track(obj, 'GET', 'value')
      if (dirty) {
        value = effectFn()
        dirty = false
      }
      return value
    },
    set value(newValue) {
      setter(newValue)
    },
  }

  return obj
}
```

## 执行流程

```
1. computed(() => state.a + state.b)
   └── effect(getter, { lazy: true, scheduler })
       └── 不执行 getter，返回 effectFn

2. 访问 sum.value
   └── track(sum, 'value')  // 收集当前 activeEffect
   └── dirty = true，执行 effectFn()
       └── getter() 执行，读取 state.a 和 state.b
           └── track(state, 'a') 和 track(state, 'b')
   └── 返回计算结果

3. 再次访问 sum.value
   └── dirty = false，直接返回缓存的 value

4. state.a = 10
   └── trigger(state, 'a')
       └── 执行 scheduler
           └── dirty = true
           └── trigger(sum, 'value')
               └── 执行依赖 sum.value 的渲染函数
```

## 小结

| 机制           | 实现方式                                   |
| -------------- | ------------------------------------------ |
| 懒计算         | `lazy: true`                               |
| 缓存           | `dirty` 标记                               |
| 依赖变化时更新 | `scheduler` 中设置 `dirty = true`          |
| 触发渲染函数   | `get value` 时 track，scheduler 中 trigger |

下一篇我们来实现 watch。
