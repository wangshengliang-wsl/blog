---
title: '虚拟 DOM 的本质与价值'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '原理', '虚拟DOM']
description: '理解虚拟 DOM 是什么、为什么需要它、以及它真正解决的问题'
---

🙋 虚拟 DOM 到底是什么？为什么说它"快"？

## DOM 操作为什么慢

先了解一个背景：JS 代码运行在 JS 引擎（V8），而 DOM 操作由浏览器渲染引擎执行。

```js
document.createElement('div')
```

这行代码实际上会：

1. JS 引擎识别为 DOM API 调用
2. 通过"绑定层"调用渲染引擎的 C++ 代码
3. 渲染引擎创建 DOM 节点
4. 返回结果给 JS

**跨引擎通信 + C++ 对象创建**，这就是 DOM 操作慢的原因。

来看个对比：

```js
// JS 层面创建 1000 万个对象：约 200ms
for (let i = 0; i < 10000000; i++) {
  const obj = { tag: 'div' }
}

// DOM 层面创建 1000 万个元素：约 2000ms
for (let i = 0; i < 10000000; i++) {
  document.createElement('div')
}
```

差了 **10 倍**！

## 虚拟 DOM 的本质

> 虚拟 DOM 就是用 **JS 对象** 来描述真实 DOM 的结构。

```js
// 真实 DOM
<div id="app">
  <h1>Hello</h1>
</div>

// 虚拟 DOM（JS 对象）
{
  tag: 'div',
  props: { id: 'app' },
  children: [
    { tag: 'h1', children: 'Hello' }
  ]
}
```

在 Vue 中，可以用 `h` 函数创建虚拟 DOM：

```ts
import { h } from 'vue'

const vnode = h('div', { id: 'app' }, [h('h1', 'Hello')])

console.log(vnode) // 打印出来就是个 JS 对象
```

## 虚拟 DOM 解决什么问题

### 对比 innerHTML

假设页面上有一个列表，数据更新后需要重新渲染：

**innerHTML 方式**：

```js
container.innerHTML = `
  <div class="list">
    ${items.map((item) => `<div>${item.name}</div>`).join('')}
  </div>
`
```

每次更新的操作：

1. 解析新的 HTML 字符串（JS 层）
2. **销毁所有旧 DOM**（DOM 层）
3. **创建所有新 DOM**（DOM 层）

**虚拟 DOM 方式**：

每次更新的操作：

1. 创建新的虚拟 DOM 树（JS 层）
2. **diff 对比新旧虚拟 DOM**（JS 层）
3. **只更新变化的 DOM**（DOM 层）

🎯 **关键区别**：虚拟 DOM 通过 JS 层的 diff 计算，把 DOM 操作降到最少。

### 性能对比

| 场景     | innerHTML    | 虚拟 DOM              |
| -------- | ------------ | --------------------- |
| 初始渲染 | 差不多       | 差不多                |
| 数据更新 | 全量替换 DOM | 只更新变化的部分      |
| 性能关键 | DOM 操作多   | JS 计算多，DOM 操作少 |

🔶 **重要结论**：虚拟 DOM 的"快"体现在**更新时减少 DOM 操作**，而不是初始渲染。

## 虚拟 DOM vs 原生操作

```js
// 原生：直接操作 DOM，最快
document.getElementById('count').textContent = newValue

// 虚拟 DOM：多了一层计算
// 1. 生成新虚拟 DOM
// 2. diff 对比
// 3. 更新 DOM
```

如果你能精确知道哪个 DOM 需要更新，原生操作永远是最快的。

虚拟 DOM 的价值在于：**框架不知道你要更新什么，通过 diff 自动找出变化**。

## 虚拟 DOM 的其他价值

### 1. 跨平台

虚拟 DOM 是抽象层，可以渲染到不同平台：

```
虚拟 DOM
    ├── Web → 真实 DOM
    ├── Native → 原生组件（React Native、Weex）
    └── SSR → HTML 字符串
```

### 2. 框架解耦

React 从 v15 升级到 v16，底层从 Stack 架构换成 Fiber 架构，但开发者代码几乎不用改。

因为开发者写的是组件（生成虚拟 DOM），框架内部怎么处理虚拟 DOM 是框架的事。

## 没有虚拟 DOM 的框架

新一代框架如 Svelte、Solid.js 采用**编译时优化**，直接生成精确的 DOM 操作代码：

```js
// Svelte 编译结果（伪代码）
if (changed.count) {
  text.data = count // 直接更新，没有 diff
}
```

性能更好，但灵活性较低。Vue 也在开发无虚拟 DOM 的"蒸汽模式"（Vapor Mode）。

## 小结

| 问题            | 答案                         |
| --------------- | ---------------------------- |
| 虚拟 DOM 是什么 | 用 JS 对象描述 DOM 结构      |
| 为什么需要      | 减少更新时的 DOM 操作        |
| 比原生快吗      | 初始渲染差不多，更新时更高效 |
| 其他价值        | 跨平台、框架解耦             |

下一篇我们来看模板是如何编译成虚拟 DOM 的。
