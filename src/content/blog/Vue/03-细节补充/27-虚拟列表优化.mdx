---
title: '虚拟列表优化（一）：动态高度'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '性能优化']
description: '处理列表项高度不固定的虚拟列表实现'
---

## 问题

定高虚拟列表的计算公式依赖固定的 itemHeight：

```js
totalHeight = listData.length * itemHeight
startIndex = Math.floor(scrollTop / itemHeight)
offset = scrollTop - (scrollTop % itemHeight)
```

当列表项高度不固定时，这些公式都失效了。

## 解决思路

1. **预估高度**：先用预估高度渲染
2. **缓存列表**：记录每项的实际位置信息
3. **动态更新**：渲染后更新缓存

## 缓存结构

```js
// 缓存列表
const positions = [
  { index: 0, height: 50, top: 0, bottom: 50 },
  { index: 1, height: 80, top: 50, bottom: 130 },
  // ...
]
```

## 初始化缓存

```js
const estimatedHeight = 50 // 预估高度

const initPositions = () => {
  positions.value = listData.map((_, index) => ({
    index,
    height: estimatedHeight,
    top: index * estimatedHeight,
    bottom: (index + 1) * estimatedHeight,
  }))
}
```

## 渲染后更新

```js
const updatePositions = () => {
  const nodes = contentRef.value.children

  nodes.forEach((node) => {
    const index = +node.dataset.index
    const { height } = node.getBoundingClientRect()
    const oldHeight = positions.value[index].height
    const diff = height - oldHeight

    if (diff) {
      // 更新当前项
      positions.value[index].height = height
      positions.value[index].bottom += diff

      // 更新后续所有项的位置
      for (let i = index + 1; i < positions.value.length; i++) {
        positions.value[i].top = positions.value[i - 1].bottom
        positions.value[i].bottom += diff
      }
    }
  })
}

onUpdated(updatePositions)
```

## 重写计算属性

```js
// 总高度
const totalHeight = computed(() => {
  return positions.value[positions.value.length - 1]?.bottom || 0
})

// 起始索引（二分查找）
const startIndex = computed(() => {
  return binarySearch(positions.value, scrollTop.value)
})

// 偏移量
const offset = computed(() => {
  return startIndex.value > 0 ? positions.value[startIndex.value - 1].bottom : 0
})
```

## 二分查找

```js
const binarySearch = (list, value) => {
  let start = 0
  let end = list.length - 1

  while (start <= end) {
    const mid = Math.floor((start + end) / 2)
    const midValue = list[mid].bottom

    if (midValue === value) {
      return mid + 1
    } else if (midValue < value) {
      start = mid + 1
    } else {
      if (!list[mid - 1] || list[mid - 1].bottom < value) {
        return mid
      }
      end = mid - 1
    }
  }
  return 0
}
```
