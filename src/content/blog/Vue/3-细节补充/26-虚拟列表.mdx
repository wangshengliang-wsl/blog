---
title: '虚拟列表实现'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '性能优化']
description: '使用虚拟列表优化大数据量列表渲染，只渲染可视区域的元素'
---

## 问题场景

渲染 10000+ 条数据时，DOM 数量过多导致性能问题。

## 三种方案对比

| 方案     | 原理               | 缺点                  |
| -------- | ------------------ | --------------------- |
| 懒加载   | 滚动到底部加载更多 | 最终 DOM 数量仍然很大 |
| 时间分片 | 分批次渲染         | 最终 DOM 数量仍然很大 |
| 虚拟列表 | 只渲染可视区域     | 实现复杂              |

## 虚拟列表原理

始终只渲染可视区域的元素，滚动时动态替换内容。

```
+------------------+
|     滚动容器      |  ← 固定高度
+------------------+
|                  |
|   可视区域内容    |  ← 只渲染这部分
|                  |
+------------------+
      ↑
   占位元素        ← 撑起总高度，形成滚动条
```

## 关键计算

```js
// 已知条件
const itemHeight = 50      // 每项高度
const containerHeight = 500 // 容器高度
const listData = [...]     // 数据列表

// 计算
const totalHeight = listData.length * itemHeight  // 总高度
const visibleCount = Math.ceil(containerHeight / itemHeight)  // 可见数量

// 滚动时计算
const startIndex = Math.floor(scrollTop / itemHeight)
const endIndex = startIndex + visibleCount
const visibleData = listData.slice(startIndex, endIndex)

// 偏移量（让可视内容对齐）
const offset = scrollTop - (scrollTop % itemHeight)
```

## 基本实现

```vue
<template>
  <div
    class="container"
    :style="{ height: containerHeight + 'px' }"
    @scroll="onScroll"
  >
    <!-- 占位，撑起滚动高度 -->
    <div :style="{ height: totalHeight + 'px' }"></div>

    <!-- 可视区域内容 -->
    <div class="list" :style="{ transform: `translateY(${offset}px)` }">
      <div
        v-for="item in visibleData"
        :key="item.id"
        :style="{ height: itemHeight + 'px' }"
      >
        {{ item.text }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const props = defineProps({
  listData: Array,
  itemHeight: { type: Number, default: 50 },
  containerHeight: { type: Number, default: 500 },
})

const scrollTop = ref(0)

const totalHeight = computed(() => props.listData.length * props.itemHeight)
const visibleCount = computed(
  () => Math.ceil(props.containerHeight / props.itemHeight) + 1
)
const startIndex = computed(() =>
  Math.floor(scrollTop.value / props.itemHeight)
)
const endIndex = computed(() => startIndex.value + visibleCount.value)
const visibleData = computed(() =>
  props.listData.slice(startIndex.value, endIndex.value)
)
const offset = computed(
  () => scrollTop.value - (scrollTop.value % props.itemHeight)
)

const onScroll = (e) => {
  scrollTop.value = e.target.scrollTop
}
</script>

<style scoped>
.container {
  overflow-y: auto;
  position: relative;
}
.list {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}
</style>
```

## 优化方向

1. **动态高度**：预估高度 + 实际渲染后更新
2. **缓冲区**：上下多渲染几项，减少白屏
3. **节流**：scroll 事件节流处理

## 第三方库

- [vue-virtual-scroller](https://github.com/Akryum/vue-virtual-scroller)
- [vue-virtual-scroll-list](https://github.com/tangbc/vue-virtual-scroll-list)
