---
title: 'Vue3 计算属性 computed 详解'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', 'computed', '计算属性']
description: '理解 Vue3 计算属性的缓存机制、可写计算属性、以及与方法的区别'
---

🙋 什么时候用计算属性？

当你需要根据已有数据**派生**出新数据时。比如：根据姓和名拼出全名，根据商品列表算出总价。

## 为什么需要计算属性

先看一个反面例子：

```vue
<template>
  <p>书籍数量：{{ books.length }}</p>
  <p>是否出版：{{ books.length > 0 ? '是' : '否' }}</p>
  <p>总价：{{ books.reduce((sum, b) => sum + b.price, 0) }}</p>
</template>
```

把计算逻辑写在模板里有几个问题：

- 模板变得臃肿，难以阅读
- 相同逻辑重复出现时，难以维护
- 复杂计算无法用表达式实现

计算属性就是来解决这些问题的。

## 基本用法

```vue
<script setup>
import { ref, computed } from 'vue'

const books = ref([
  { title: 'Vue3 指南', price: 59 },
  { title: 'TypeScript 入门', price: 49 },
])

// 定义计算属性
const totalPrice = computed(() => {
  return books.value.reduce((sum, book) => sum + book.price, 0)
})

const hasBooks = computed(() => books.value.length > 0)
</script>

<template>
  <p>总价：{{ totalPrice }}</p>
  <p>有书：{{ hasBooks ? '是' : '否' }}</p>
</template>
```

`computed()` 接收一个 getter 函数，返回一个**只读的 ref**。

## 计算属性 vs 方法

🙋 用方法不也能实现吗？

```vue
<script setup>
const totalPrice = computed(() => /* 计算逻辑 */)  // 计算属性

function getTotalPrice() { return /* 计算逻辑 */ }  // 方法
</script>

<template>
  <p>{{ totalPrice }}</p>
  <!-- 计算属性 -->
  <p>{{ getTotalPrice() }}</p>
  <!-- 方法调用 -->
</template>
```

表面上效果一样，但有个关键区别：**缓存**。

| 特性 | 计算属性                    | 方法                  |
| ---- | --------------------------- | --------------------- |
| 缓存 | ✅ 有，依赖不变就不重新计算 | ❌ 无，每次渲染都执行 |
| 用法 | `{{ computed }}`            | `{{ method() }}`      |

来看个例子：

```vue
<script setup>
import { ref, computed } from 'vue'

const count = ref(0)
const other = ref(0)

const doubled = computed(() => {
  console.log('computed 执行')
  return count.value * 2
})

function getDoubled() {
  console.log('method 执行')
  return count.value * 2
}
</script>

<template>
  <p>computed: {{ doubled }}</p>
  <p>method: {{ getDoubled() }}</p>
  <button @click="other++">改变无关数据</button>
</template>
```

点击按钮改变 `other`，触发重新渲染：

- `computed` 的 log 不会打印（因为 `count` 没变，用缓存）
- `method` 的 log 会打印（每次渲染都执行）

🎯 **结论**：需要派生数据用计算属性，需要执行操作用方法。

## 可写计算属性

默认计算属性是只读的，但也可以定义 setter：

```vue
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('张')
const lastName = ref('三')

const fullName = computed({
  get() {
    return firstName.value + lastName.value
  },
  set(newName) {
    // 设置时拆分姓名
    firstName.value = newName[0]
    lastName.value = newName.slice(1)
  },
})

// 可以直接设置
fullName.value = '李四'
// firstName 变成 '李'，lastName 变成 '四'
</script>
```

🔶 **不过，绝大多数情况下应该避免修改计算属性**。计算属性是"派生状态"，修改它不如直接修改源数据来得清晰。

## 最佳实践

### 1. getter 不要有副作用

❌ 不要在计算属性里做这些事：

```ts
const bad = computed(() => {
  // ❌ 修改 DOM
  document.title = 'xxx'

  // ❌ 发请求
  fetch('/api')

  // ❌ 修改其他响应式数据
  otherRef.value = 123

  return someValue
})
```

计算属性应该是**纯函数**：只读取数据，返回结果，不改变任何东西。

### 2. 不要直接修改计算属性的值

```ts
const list = ref([1, 2, 3])
const sorted = computed(() => [...list.value].sort())

// ❌ 不要这样
sorted.value.push(4)

// ✅ 应该修改源数据
list.value.push(4)
```

### 3. 复杂计算抽成函数

```ts
// ✅ 复杂逻辑抽成独立函数
function calculateDiscount(items: Item[], vipLevel: number) {
  // 复杂的折扣计算逻辑
}

// 计算属性只负责调用
const finalPrice = computed(() => {
  return calculateDiscount(cart.value, user.value.vipLevel)
})
```

## 小结

| 场景                   | 用什么     |
| ---------------------- | ---------- |
| 根据已有数据派生新数据 | `computed` |
| 响应用户事件           | 方法       |
| 需要缓存的复杂计算     | `computed` |
| 每次都要执行的操作     | 方法       |

记住计算属性的核心特性：

1. **自动缓存**：依赖不变就不重新计算
2. **自动追踪依赖**：依赖变化自动更新
3. **默认只读**：避免直接修改

下一篇我们来看 Vue 的样式绑定。
