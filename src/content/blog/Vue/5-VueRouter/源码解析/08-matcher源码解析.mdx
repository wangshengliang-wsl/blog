---
title: 'Matcher 源码解析'
pubDate: 2024-01-15
category: 'Vue'
tags: ['VueRouter', '源码']
description: 'Vue Router 路由匹配器 createRouterMatcher 源码解析'
---

## createRouterMatcher 入口

```ts
// router.ts 中调用
const matcher = createRouterMatcher(options.routes, options)
```

## 整体结构

```ts
export function createRouterMatcher(
  routes: RouteRecordRaw[],
  globalOptions: PathParserOptions
): RouterMatcher {

  // 1. 初始化
  const matchers: RouteRecordMatcher[] = []  // 数组，用于遍历
  const matcherMap = new Map()               // Map，用于快速查找

  globalOptions = mergeOptions(
    { strict: false, end: true, sensitive: false },
    globalOptions
  )

  // 2. 内部方法
  function addRoute() { ... }
  function removeRoute() { ... }
  function getRoutes() { ... }
  function getRecordMatcher() { ... }
  function insertMatcher() { ... }
  function resolve() { ... }

  // 3. 初始化路由
  routes.forEach(route => addRoute(route))

  // 4. 返回 matcher 对象
  return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher }
}
```

## 类型说明

| 类型                  | 说明                                  |
| --------------------- | ------------------------------------- |
| RouteRecordRaw        | 开发者传入的原始路由配置              |
| RouteRecordNormalized | 标准化后的路由记录                    |
| RouteRecordMatcher    | 封装了额外信息（parent 等）的路由记录 |

## 核心方法

### insertMatcher

将 RouteRecordMatcher 按优先级插入数组：

```ts
function insertMatcher(matcher: RouteRecordMatcher) {
  let i = 0
  // 计算插入位置（按分数排序）
  while (
    i < matchers.length &&
    comparePathParserScore(matcher, matchers[i]) >= 0
  ) {
    i++
  }

  // 插入数组
  matchers.splice(i, 0, matcher)

  // 添加到 Map
  if (matcher.record.name && !isAliasRecord(matcher)) {
    matcherMap.set(matcher.record.name, matcher)
  }
}
```

### removeRoute

删除路由记录（包括子路由和别名）：

```ts
function removeRoute(matcherRef: RouteRecordName | RouteRecordMatcher) {
  if (isRouteName(matcherRef)) {
    const matcher = matcherMap.get(matcherRef)
    if (matcher) {
      matcherMap.delete(matcherRef)
      matchers.splice(matchers.indexOf(matcher), 1)
      // 递归删除子路由和别名
      matcher.children.forEach(removeRoute)
      matcher.alias.forEach(removeRoute)
    }
  } else {
    const index = matchers.indexOf(matcherRef)
    if (index > -1) {
      matchers.splice(index, 1)
      if (matcherRef.record.name) {
        matcherMap.delete(matcherRef.record.name)
      }
      matcherRef.children.forEach(removeRoute)
      matcherRef.alias.forEach(removeRoute)
    }
  }
}
```

### resolve

根据 location 解析匹配的路由：

```ts
function resolve(location, currentLocation) {
  let matcher: RouteRecordMatcher | undefined

  if ('name' in location && location.name) {
    // 按名称查找
    matcher = matcherMap.get(location.name)
  } else if (location.path != null) {
    // 按路径遍历查找
    for (let i = 0; i < matchers.length; i++) {
      if (matchers[i].re.test(location.path)) {
        matcher = matchers[i]
        break
      }
    }
  }

  // 返回匹配结果
  return {
    name: matcher?.record.name,
    path: location.path,
    params: extractedParams,
    matched: extractMatchedRecords(matcher),
  }
}
```

## 为什么同时使用数组和 Map

| 数据结构 | 用途                                   |
| -------- | -------------------------------------- |
| 数组     | 有序遍历，按路径匹配时需要按优先级遍历 |
| Map      | O(1) 查找，按名称查找时高效            |

两者结合，在遍历和查找场景都能获得最佳性能。
