---
title: '导航守卫流程解析'
pubDate: 2024-01-15
category: 'Vue'
tags: ['VueRouter', '源码']
description: 'Vue Router 导航守卫执行流程源码解析'
---

## 导航守卫分类

| 类型     | 守卫              | 触发时机             |
| -------- | ----------------- | -------------------- |
| 全局守卫 | beforeEach        | 每次导航             |
|          | beforeResolve     | 导航确认前           |
|          | afterEach         | 导航完成后           |
| 路由独享 | beforeEnter       | 进入特定路由         |
| 组件内   | beforeRouteEnter  | 组件渲染前           |
|          | beforeRouteUpdate | 路由更新（复用组件） |
|          | beforeRouteLeave  | 离开组件             |

## 完整执行流程

```
1. 导航触发（push/replace/go）
2. beforeRouteLeave（离开的组件）
3. beforeEach（全局）
4. beforeRouteUpdate（复用的组件）
5. beforeEnter（路由配置）
6. beforeRouteEnter（进入的组件）
7. beforeResolve（全局）
8. 导航确认
9. afterEach（全局）
10. DOM 更新
```

## navigate 方法

导航触发时调用，处理所有守卫逻辑：

```ts
function navigate(to, from) {
  let guards = []

  // 提取变化的路由记录
  const [leavingRecords, updatingRecords, enteringRecords] =
    extractChangingRecords(to, from)

  // 依次处理各类守卫
  return runGuardQueue(guards)
    .then(() => /* beforeRouteLeave */)
    .then(() => /* beforeEach */)
    .then(() => /* beforeRouteUpdate */)
    .then(() => /* beforeEnter */)
    .then(() => /* beforeRouteEnter */)
    .then(() => /* beforeResolve */)
}
```

## extractChangingRecords

提取要离开、更新、进入的路由记录：

```ts
function extractChangingRecords(to, from) {
  const leavingRecords = []
  const updatingRecords = []
  const enteringRecords = []

  const len = Math.max(from.matched.length, to.matched.length)

  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i]
    if (recordFrom) {
      if (to.matched.find((r) => isSameRouteRecord(r, recordFrom))) {
        updatingRecords.push(recordFrom) // 存在于两边 → 更新
      } else {
        leavingRecords.push(recordFrom) // 只在 from → 离开
      }
    }

    const recordTo = to.matched[i]
    if (recordTo && !from.matched.find((r) => isSameRouteRecord(r, recordTo))) {
      enteringRecords.push(recordTo) // 只在 to → 进入
    }
  }

  return [leavingRecords, updatingRecords, enteringRecords]
}
```

## guardToPromiseFn

将守卫函数转为 Promise：

```ts
function guardToPromiseFn(guard, to, from, record, name) {
  return () =>
    new Promise((resolve, reject) => {
      // 定义 next 函数
      const next = (valid) => {
        if (valid === false) {
          reject(createRouterError(ErrorTypes.NAVIGATION_ABORTED))
        } else if (valid instanceof Error) {
          reject(valid)
        } else if (isRouteLocation(valid)) {
          reject(
            createRouterError(ErrorTypes.NAVIGATION_GUARD_REDIRECT, {
              to: valid,
            })
          )
        } else {
          // 如果是回调函数，存储到 enterCallbacks
          if (typeof valid === 'function' && enterCallbackArray) {
            enterCallbackArray.push(valid)
          }
          resolve()
        }
      }

      // 执行守卫
      const guardReturn = guard.call(record?.instances[name], to, from, next)

      // 如果守卫参数少于 3 个（没有用 next），自动调用 next
      let guardCall = Promise.resolve(guardReturn)
      if (guard.length < 3) {
        guardCall = guardCall.then(next)
      }
      guardCall.catch((err) => reject(err))
    })
}
```

## runGuardQueue

顺序执行守卫队列：

```ts
function runGuardQueue(guards) {
  return guards.reduce(
    (promise, guard) => promise.then(() => guard()),
    Promise.resolve()
  )
}
```

## next 函数的处理

| 调用方式         | 行为                     |
| ---------------- | ------------------------ |
| `next()`         | 继续导航                 |
| `next(false)`    | 中止导航                 |
| `next(Error)`    | 中止并抛出错误           |
| `next('/path')`  | 重定向                   |
| `next(callback)` | 存储回调，导航确认后执行 |
