---
title: '事件绑定与更新'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '面试']
description: '面试题：说一下 Vue 内部是如何绑定和更新事件的？'
---

## 面试题

> 说一下 Vue 内部是如何绑定和更新事件的？

## 事件在 vnode 中的表示

```vue
<p @click="clickHandler">text</p>
```

```js
const vnode = {
  type: 'p',
  props: {
    onClick: () => {
      /* ... */
    },
  },
  children: 'text',
}
```

事件是以 `on` 开头的特殊属性。

## 基本绑定

```js
function patchProps(el, key, prevValue, nextValue) {
  if (/^on/.test(key)) {
    const name = key.slice(2).toLowerCase() // onClick → click
    el.addEventListener(name, nextValue)
  }
}
```

## 事件更新优化

**简单方案**：先移除旧事件，再绑定新事件

```js
prevValue && el.removeEventListener(name, prevValue)
el.addEventListener(name, nextValue)
```

**问题**：频繁绑定/卸载影响性能。

**优化方案**：使用中间层对象

```js
function patchProps(el, key, prevValue, nextValue) {
  if (/^on/.test(key)) {
    const name = key.slice(2).toLowerCase()
    const invokers = el._vei || (el._vei = {})
    let invoker = invokers[key]

    if (nextValue) {
      if (!invoker) {
        // 首次绑定：创建中间层
        invoker = invokers[key] = (e) => {
          if (Array.isArray(invoker.value)) {
            invoker.value.forEach((fn) => fn(e))
          } else {
            invoker.value(e)
          }
        }
        invoker.value = nextValue
        el.addEventListener(name, invoker)
      } else {
        // 更新：只更新 value 属性
        invoker.value = nextValue
      }
    } else if (invoker) {
      // 移除事件
      el.removeEventListener(name, invoker)
    }
  }
}
```

## 支持的场景

```js
// 多种事件类型
{
  onClick: () => {},
  onContextmenu: () => {}
}

// 同一事件多个处理函数
{
  onClick: [fn1, fn2]
}
```

## 参考答案

事件在 vnode 中以 props 形式存在（on 开头）。渲染器检测到 on 开头的 prop 时进行事件绑定。

为避免更新时频繁卸载/绑定的性能消耗，Vue 内部使用中间层对象：

```js
{
  onClick: [fn1, fn2],
  onContextmenu: fn3
}
```

更新事件时只需修改对象属性值，无需操作 DOM 事件监听。

这种设计支持：

1. 一个元素绑定多种事件
2. 同种事件绑定多个处理函数
