---
title: '模板编译器原理（二）：转换器'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '面试']
description: 'Vue 编译器转换器原理：将模板 AST 转换为 JS AST'
---

## 转换器的作用

将模板 AST 转换为 JavaScript AST，为生成渲染函数做准备。

```
模板 AST  →  [转换器]  →  JS AST
```

## 深度优先遍历

转换器采用深度优先遍历 AST：

```ts
function traverseNode(ast, context) {
  context.currentNode = ast

  // 获取转换函数
  const transforms = context.nodeTransforms
  const exitFns = []

  // 执行转换函数（进入阶段）
  for (let i = 0; i < transforms.length; i++) {
    const onExit = transforms[i](context.currentNode, context)
    if (onExit) {
      exitFns.push(onExit)
    }
    // 节点可能被替换或删除
    if (!context.currentNode) return
  }

  // 递归处理子节点
  const children = context.currentNode.children
  if (children) {
    for (let i = 0; i < children.length; i++) {
      context.parent = context.currentNode
      context.childIndex = i
      traverseNode(children[i], context)
    }
  }

  // 执行退出函数（退出阶段）
  let i = exitFns.length
  while (i--) {
    exitFns[i]()
  }
}
```

## 转换上下文

```ts
interface TransformContext {
  currentNode: ASTNode | null // 当前节点
  parent: ASTNode | null // 父节点
  childIndex: number // 在父节点中的索引
  nodeTransforms: Function[] // 转换函数列表

  replaceNode(node) // 替换当前节点
  removeNode() // 删除当前节点
}
```

## 转换示例

### 文本节点转换

```ts
// 模板 AST
{ type: 'Text', content: 'hello' }

// JS AST
{
  type: 'StringLiteral',
  value: 'hello'
}
```

### 元素节点转换

```ts
// 模板 AST
{
  type: 'Element',
  tag: 'div',
  children: [...]
}

// JS AST
{
  type: 'CallExpression',
  callee: { type: 'Identifier', name: 'h' },
  arguments: [
    { type: 'StringLiteral', value: 'div' },
    // children...
  ]
}
```

## 核心转换函数

```ts
function transform(ast) {
  const context = {
    currentNode: null,
    parent: null,
    childIndex: 0,
    nodeTransforms: [
      transformElement, // 转换元素
      transformText, // 转换文本
      transformExpression, // 转换表达式
    ],
    replaceNode(node) {
      context.parent.children[context.childIndex] = node
      context.currentNode = node
    },
    removeNode() {
      context.parent.children.splice(context.childIndex, 1)
      context.currentNode = null
    },
  }

  traverseNode(ast, context)
}
```

## 为什么需要退出函数

有些转换需要在子节点处理完后才能完成：

```ts
function transformElement(node, context) {
  // 返回退出函数
  return () => {
    // 子节点已处理完，可以构建完整的 JS AST
    node.codegenNode = createVNodeCall(
      context,
      node.tag,
      node.props,
      node.children
    )
  }
}
```
