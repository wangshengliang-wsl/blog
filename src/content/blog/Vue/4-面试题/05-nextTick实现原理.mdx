---
title: 'nextTick 实现原理'
pubDate: 2024-01-15
category: 'Vue'
tags: ['Vue3', '面试']
description: '面试题：Vue 的 nextTick 是如何实现的？'
---

## 面试题

> Vue 的 nextTick 是如何实现的？

## 为什么需要 nextTick

```js
const increment = () => {
  for (let i = 1; i <= 1000; i++) {
    count.value = i
  }
}
```

点击后页面只渲染 1 次，因为：

1. 同步代码中多次修改会被**合并**
2. DOM 更新是**异步**的（微任务）

## 问题

修改数据后立即获取 DOM 会拿到旧值：

```js
count.value++
console.log(el.textContent) // 旧值！
```

## 解决方案

将获取 DOM 的操作放到微任务中：

```js
// 手动实现
count.value++
Promise.resolve().then(() => {
  console.log(el.textContent) // 新值
})

// 使用 nextTick
count.value++
nextTick(() => {
  console.log(el.textContent) // 新值
})

// 使用 await
count.value++
await nextTick()
console.log(el.textContent) // 新值
```

## 源码实现

```js
// Vue3 源码（简化版）
const resolvedPromise = Promise.resolve()
let currentFlushPromise = null

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true
    currentFlushPromise = resolvedPromise.then(flushJobs)
  }
}

function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise
  return fn ? p.then(fn) : p
}
```

**核心原理**：将回调包装为微任务，确保在 DOM 更新后执行。

## Vue2 vs Vue3 实现

|      | Vue2         | Vue3             |
| ---- | ------------ | ---------------- |
| 策略 | 多种降级方案 | 直接使用 Promise |

**Vue2 降级方案**（按优先级）：

1. Promise（微任务）
2. MutationObserver（微任务）
3. setImmediate（宏任务）
4. setTimeout（宏任务）

**Vue3**：只使用 Promise，代码更简洁。

## 参考答案

nextTick 的本质是将回调函数包装为微任务放入队列，确保在 DOM 更新后执行。

- Vue2：为兼容旧浏览器，有多种降级方案
- Vue3：只使用 Promise，更简洁高效
