---
title: Server Actions
description: æŒæ¡ Next.js Server Actionsï¼Œå®ç°ä»å®¢æˆ·ç«¯ç›´æ¥è°ƒç”¨æœåŠ¡ç«¯å‡½æ•°ï¼Œç®€åŒ–è¡¨å•å¤„ç†ä¸æ•°æ®å˜æ›´
pubDate: 2025-12-03
toc: true
ogImage: true
category: Next
tags: ['Next.js', 'Server Actions', 'è¡¨å•å¤„ç†', 'use server']
---

ğŸ™‹ ä¼ ç»Ÿæ–¹å¼éœ€è¦åˆ›å»º API è·¯ç”±æ¥å¤„ç†è¡¨å•ï¼ŸServer Actions è®©ä½ ç›´æ¥ä»å®¢æˆ·ç«¯è°ƒç”¨æœåŠ¡ç«¯å‡½æ•°ã€‚

## ä»€ä¹ˆæ˜¯ Server Actions

Server Actions æ˜¯åœ¨æœåŠ¡å™¨ä¸Šæ‰§è¡Œçš„å¼‚æ­¥å‡½æ•°ï¼Œå¯ä»¥ç›´æ¥ä» Client æˆ– Server Components è°ƒç”¨ã€‚

```tsx
// ä¼ ç»Ÿæ–¹å¼
// 1. åˆ›å»º API è·¯ç”± /api/submit
// 2. å®¢æˆ·ç«¯ fetch è°ƒç”¨
// 3. å¤„ç†å“åº”

// Server Actions æ–¹å¼
// ç›´æ¥è°ƒç”¨æœåŠ¡ç«¯å‡½æ•°ï¼Œæ— éœ€åˆ›å»º API
```

## åŸºç¡€ç”¨æ³•

### å®šä¹‰ Server Action

```tsx
// app/actions.ts
'use server'

export async function createPost(formData: FormData) {
  const title = formData.get('title') as string
  const content = formData.get('content') as string

  // ç›´æ¥æ“ä½œæ•°æ®åº“
  await db.post.create({
    data: { title, content },
  })

  return { success: true }
}
```

### åœ¨ Server Component ä¸­ä½¿ç”¨

```tsx
// app/posts/new/page.tsx
// Next.js 15.x
import { createPost } from '@/app/actions'

export default function NewPostPage() {
  return (
    <form action={createPost}>
      <input name="title" placeholder="æ ‡é¢˜" required />
      <textarea name="content" placeholder="å†…å®¹" required />
      <button type="submit">å‘å¸ƒ</button>
    </form>
  )
}
```

### åœ¨ Client Component ä¸­ä½¿ç”¨

```tsx
// components/PostForm.tsx
'use client'

import { createPost } from '@/app/actions'
import { useActionState } from 'react'

export function PostForm() {
  const [state, formAction, isPending] = useActionState(createPost, null)

  return (
    <form action={formAction}>
      <input name="title" placeholder="æ ‡é¢˜" disabled={isPending} />
      <textarea name="content" placeholder="å†…å®¹" disabled={isPending} />
      <button type="submit" disabled={isPending}>
        {isPending ? 'å‘å¸ƒä¸­...' : 'å‘å¸ƒ'}
      </button>
      {state?.error && <p className="text-red-500">{state.error}</p>}
    </form>
  )
}
```

## è¡¨å•å¤„ç†

### å¸¦éªŒè¯çš„è¡¨å•

```tsx
// app/actions.ts
'use server'

import { z } from 'zod'
import { revalidatePath } from 'next/cache'

const PostSchema = z.object({
  title: z.string().min(1, 'æ ‡é¢˜ä¸èƒ½ä¸ºç©º').max(100, 'æ ‡é¢˜è¿‡é•¿'),
  content: z.string().min(10, 'å†…å®¹è‡³å°‘ 10 ä¸ªå­—ç¬¦'),
})

export async function createPost(prevState: any, formData: FormData) {
  // éªŒè¯æ•°æ®
  const validatedFields = PostSchema.safeParse({
    title: formData.get('title'),
    content: formData.get('content'),
  })

  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
      message: 'éªŒè¯å¤±è´¥',
    }
  }

  const { title, content } = validatedFields.data

  try {
    await db.post.create({ data: { title, content } })

    // é‡æ–°éªŒè¯ç¼“å­˜
    revalidatePath('/posts')

    return { message: 'å‘å¸ƒæˆåŠŸ' }
  } catch (error) {
    return { message: 'å‘å¸ƒå¤±è´¥ï¼Œè¯·é‡è¯•' }
  }
}
```

```tsx
// components/PostForm.tsx
'use client'

import { useActionState } from 'react'
import { createPost } from '@/app/actions'

const initialState = {
  message: '',
  errors: {},
}

export function PostForm() {
  const [state, formAction, isPending] = useActionState(
    createPost,
    initialState
  )

  return (
    <form action={formAction} className="space-y-4">
      <div>
        <label className="block font-medium">æ ‡é¢˜</label>
        <input
          name="title"
          className="w-full border rounded px-3 py-2"
          aria-describedby="title-error"
        />
        {state.errors?.title && (
          <p id="title-error" className="text-red-500 text-sm mt-1">
            {state.errors.title[0]}
          </p>
        )}
      </div>

      <div>
        <label className="block font-medium">å†…å®¹</label>
        <textarea
          name="content"
          rows={5}
          className="w-full border rounded px-3 py-2"
          aria-describedby="content-error"
        />
        {state.errors?.content && (
          <p id="content-error" className="text-red-500 text-sm mt-1">
            {state.errors.content[0]}
          </p>
        )}
      </div>

      <button
        type="submit"
        disabled={isPending}
        className="bg-blue-600 text-white px-4 py-2 rounded disabled:opacity-50"
      >
        {isPending ? 'æäº¤ä¸­...' : 'å‘å¸ƒ'}
      </button>

      {state.message && (
        <p className={state.errors ? 'text-red-500' : 'text-green-500'}>
          {state.message}
        </p>
      )}
    </form>
  )
}
```

### æ–‡ä»¶ä¸Šä¼ 

```tsx
// app/actions.ts
'use server'

import { writeFile } from 'fs/promises'
import { join } from 'path'

export async function uploadFile(formData: FormData) {
  const file = formData.get('file') as File

  if (!file) {
    return { error: 'è¯·é€‰æ‹©æ–‡ä»¶' }
  }

  // éªŒè¯æ–‡ä»¶ç±»å‹
  const allowedTypes = ['image/jpeg', 'image/png', 'image/webp']
  if (!allowedTypes.includes(file.type)) {
    return { error: 'åªæ”¯æŒ JPGã€PNGã€WebP æ ¼å¼' }
  }

  // éªŒè¯æ–‡ä»¶å¤§å°ï¼ˆ5MBï¼‰
  if (file.size > 5 * 1024 * 1024) {
    return { error: 'æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ 5MB' }
  }

  const bytes = await file.arrayBuffer()
  const buffer = Buffer.from(bytes)

  // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
  const uniqueName = `${Date.now()}-${file.name}`
  const path = join(process.cwd(), 'public', 'uploads', uniqueName)

  await writeFile(path, buffer)

  return { url: `/uploads/${uniqueName}` }
}
```

```tsx
// components/FileUpload.tsx
'use client'

import { useState } from 'react'
import { uploadFile } from '@/app/actions'

export function FileUpload() {
  const [uploading, setUploading] = useState(false)
  const [result, setResult] = useState<{ url?: string; error?: string } | null>(
    null
  )

  async function handleSubmit(formData: FormData) {
    setUploading(true)
    const res = await uploadFile(formData)
    setResult(res)
    setUploading(false)
  }

  return (
    <form action={handleSubmit}>
      <input type="file" name="file" accept="image/*" />
      <button type="submit" disabled={uploading}>
        {uploading ? 'ä¸Šä¼ ä¸­...' : 'ä¸Šä¼ '}
      </button>

      {result?.error && <p className="text-red-500">{result.error}</p>}
      {result?.url && (
        <img src={result.url} alt="Uploaded" className="mt-4 max-w-xs" />
      )}
    </form>
  )
}
```

## ä¹è§‚æ›´æ–°

### useOptimistic

```tsx
// components/LikeButton.tsx
'use client'

import { useOptimistic, useTransition } from 'react'
import { toggleLike } from '@/app/actions'

interface Props {
  postId: string
  initialLiked: boolean
  initialCount: number
}

export function LikeButton({ postId, initialLiked, initialCount }: Props) {
  const [isPending, startTransition] = useTransition()
  const [optimisticState, addOptimistic] = useOptimistic(
    { liked: initialLiked, count: initialCount },
    (state, newLiked: boolean) => ({
      liked: newLiked,
      count: state.count + (newLiked ? 1 : -1),
    })
  )

  function handleClick() {
    startTransition(async () => {
      // ç«‹å³æ›´æ–° UI
      addOptimistic(!optimisticState.liked)
      // æ‰§è¡ŒæœåŠ¡ç«¯æ“ä½œ
      await toggleLike(postId)
    })
  }

  return (
    <button
      onClick={handleClick}
      disabled={isPending}
      className="flex items-center gap-2"
    >
      <span>{optimisticState.liked ? 'â¤ï¸' : 'ğŸ¤'}</span>
      <span>{optimisticState.count}</span>
    </button>
  )
}
```

```tsx
// app/actions.ts
'use server'

import { revalidatePath } from 'next/cache'

export async function toggleLike(postId: string) {
  const userId = await getCurrentUserId()

  const existing = await db.like.findUnique({
    where: { postId_userId: { postId, userId } },
  })

  if (existing) {
    await db.like.delete({
      where: { postId_userId: { postId, userId } },
    })
  } else {
    await db.like.create({
      data: { postId, userId },
    })
  }

  revalidatePath('/posts')
}
```

### ä¹è§‚åˆ—è¡¨æ“ä½œ

```tsx
// components/TodoList.tsx
'use client'

import { useOptimistic } from 'react'
import { addTodo, deleteTodo } from '@/app/actions'

interface Todo {
  id: string
  text: string
  pending?: boolean
}

export function TodoList({ initialTodos }: { initialTodos: Todo[] }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    initialTodos,
    (state, action: { type: 'add' | 'delete'; todo?: Todo; id?: string }) => {
      if (action.type === 'add' && action.todo) {
        return [...state, { ...action.todo, pending: true }]
      }
      if (action.type === 'delete' && action.id) {
        return state.filter((t) => t.id !== action.id)
      }
      return state
    }
  )

  async function handleAdd(formData: FormData) {
    const text = formData.get('text') as string
    const tempId = `temp-${Date.now()}`

    addOptimisticTodo({ type: 'add', todo: { id: tempId, text } })
    await addTodo(formData)
  }

  async function handleDelete(id: string) {
    addOptimisticTodo({ type: 'delete', id })
    await deleteTodo(id)
  }

  return (
    <div>
      <form action={handleAdd} className="flex gap-2 mb-4">
        <input
          name="text"
          placeholder="æ–°ä»»åŠ¡"
          className="border rounded px-2"
        />
        <button type="submit" className="bg-blue-600 text-white px-4 rounded">
          æ·»åŠ 
        </button>
      </form>

      <ul className="space-y-2">
        {optimisticTodos.map((todo) => (
          <li
            key={todo.id}
            className={`flex justify-between items-center p-2 border rounded ${
              todo.pending ? 'opacity-50' : ''
            }`}
          >
            <span>{todo.text}</span>
            <button
              onClick={() => handleDelete(todo.id)}
              className="text-red-500"
            >
              åˆ é™¤
            </button>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

## é‡å®šå‘ä¸é‡æ–°éªŒè¯

### æ“ä½œåé‡å®šå‘

```tsx
// app/actions.ts
'use server'

import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'

export async function createPost(formData: FormData) {
  const post = await db.post.create({
    data: {
      title: formData.get('title') as string,
      content: formData.get('content') as string,
    },
  })

  // é‡æ–°éªŒè¯åˆ—è¡¨é¡µç¼“å­˜
  revalidatePath('/posts')

  // é‡å®šå‘åˆ°æ–°æ–‡ç« 
  redirect(`/posts/${post.id}`)
}

export async function deletePost(id: string) {
  await db.post.delete({ where: { id } })

  revalidatePath('/posts')
  redirect('/posts')
}
```

### æŒ‰æ ‡ç­¾é‡æ–°éªŒè¯

```tsx
// app/actions.ts
'use server'

import { revalidateTag } from 'next/cache'

export async function updateProduct(id: string, formData: FormData) {
  await db.product.update({
    where: { id },
    data: {
      name: formData.get('name') as string,
      price: Number(formData.get('price')),
    },
  })

  // é‡æ–°éªŒè¯ç‰¹å®šäº§å“çš„ç¼“å­˜
  revalidateTag(`product-${id}`)

  // é‡æ–°éªŒè¯äº§å“åˆ—è¡¨
  revalidateTag('products')
}
```

## é”™è¯¯å¤„ç†

### è¿”å›é”™è¯¯çŠ¶æ€

```tsx
// app/actions.ts
'use server'

export async function createUser(formData: FormData) {
  const email = formData.get('email') as string

  // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
  const existing = await db.user.findUnique({ where: { email } })
  if (existing) {
    return { error: 'è¯¥é‚®ç®±å·²è¢«æ³¨å†Œ' }
  }

  try {
    const user = await db.user.create({
      data: {
        email,
        name: formData.get('name') as string,
      },
    })

    return { success: true, user }
  } catch (error) {
    return { error: 'åˆ›å»ºç”¨æˆ·å¤±è´¥ï¼Œè¯·é‡è¯•' }
  }
}
```

### ä½¿ç”¨ error.tsx

```tsx
// app/actions.ts
'use server'

export async function dangerousAction() {
  // æŠ›å‡ºçš„é”™è¯¯ä¼šè¢«æœ€è¿‘çš„ error.tsx æ•è·
  throw new Error('æ“ä½œå¤±è´¥')
}
```

```tsx
// app/error.tsx
'use client'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div className="p-4 bg-red-50 rounded">
      <h2 className="text-red-600 font-bold">å‡ºé”™äº†</h2>
      <p>{error.message}</p>
      <button onClick={reset} className="mt-2 text-blue-600">
        é‡è¯•
      </button>
    </div>
  )
}
```

## å®‰å…¨æ€§

### è¾“å…¥éªŒè¯

```tsx
// app/actions.ts
'use server'

import { z } from 'zod'

const CommentSchema = z.object({
  content: z
    .string()
    .min(1, 'è¯„è®ºä¸èƒ½ä¸ºç©º')
    .max(1000, 'è¯„è®ºè¿‡é•¿')
    .transform((s) => s.trim()),
  postId: z.string().uuid('æ— æ•ˆçš„æ–‡ç«  ID'),
})

export async function addComment(formData: FormData) {
  const result = CommentSchema.safeParse({
    content: formData.get('content'),
    postId: formData.get('postId'),
  })

  if (!result.success) {
    return { error: result.error.flatten().fieldErrors }
  }

  // ä½¿ç”¨éªŒè¯åçš„æ•°æ®
  await db.comment.create({ data: result.data })
}
```

### æƒé™æ£€æŸ¥

```tsx
// app/actions.ts
'use server'

import { auth } from '@/lib/auth'
import { redirect } from 'next/navigation'

export async function updateProfile(formData: FormData) {
  const session = await auth()

  // æœªç™»å½•é‡å®šå‘
  if (!session?.user) {
    redirect('/login')
  }

  // åªèƒ½ä¿®æ”¹è‡ªå·±çš„èµ„æ–™
  const userId = formData.get('userId') as string
  if (userId !== session.user.id) {
    return { error: 'æ— æƒä¿®æ”¹' }
  }

  await db.user.update({
    where: { id: userId },
    data: { name: formData.get('name') as string },
  })

  return { success: true }
}
```

### é˜²æ­¢é‡æ”¾æ”»å‡»

```tsx
// app/actions.ts
'use server'

import { headers } from 'next/headers'

export async function sensitiveAction(formData: FormData) {
  const headersList = await headers()
  const csrfToken = headersList.get('x-csrf-token')

  // éªŒè¯ CSRF Token
  if (!validateCsrfToken(csrfToken)) {
    return { error: 'æ— æ•ˆçš„è¯·æ±‚' }
  }

  // æ‰§è¡Œæ“ä½œ
}
```

## å®æˆ˜ç¤ºä¾‹

### å®Œæ•´çš„ CRUD æ“ä½œ

```tsx
// app/actions/posts.ts
'use server'

import { z } from 'zod'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { auth } from '@/lib/auth'
import { db } from '@/lib/db'

const PostSchema = z.object({
  title: z.string().min(1).max(200),
  content: z.string().min(1),
  published: z.boolean().default(false),
})

// åˆ›å»º
export async function createPost(prevState: any, formData: FormData) {
  const session = await auth()
  if (!session?.user) {
    return { error: 'è¯·å…ˆç™»å½•' }
  }

  const validated = PostSchema.safeParse({
    title: formData.get('title'),
    content: formData.get('content'),
    published: formData.get('published') === 'true',
  })

  if (!validated.success) {
    return { errors: validated.error.flatten().fieldErrors }
  }

  const post = await db.post.create({
    data: {
      ...validated.data,
      authorId: session.user.id,
    },
  })

  revalidatePath('/posts')
  redirect(`/posts/${post.id}`)
}

// æ›´æ–°
export async function updatePost(
  id: string,
  prevState: any,
  formData: FormData
) {
  const session = await auth()
  if (!session?.user) {
    return { error: 'è¯·å…ˆç™»å½•' }
  }

  const post = await db.post.findUnique({ where: { id } })
  if (!post || post.authorId !== session.user.id) {
    return { error: 'æ— æƒä¿®æ”¹' }
  }

  const validated = PostSchema.safeParse({
    title: formData.get('title'),
    content: formData.get('content'),
    published: formData.get('published') === 'true',
  })

  if (!validated.success) {
    return { errors: validated.error.flatten().fieldErrors }
  }

  await db.post.update({
    where: { id },
    data: validated.data,
  })

  revalidatePath('/posts')
  revalidatePath(`/posts/${id}`)

  return { success: true }
}

// åˆ é™¤
export async function deletePost(id: string) {
  const session = await auth()
  if (!session?.user) {
    return { error: 'è¯·å…ˆç™»å½•' }
  }

  const post = await db.post.findUnique({ where: { id } })
  if (!post || post.authorId !== session.user.id) {
    return { error: 'æ— æƒåˆ é™¤' }
  }

  await db.post.delete({ where: { id } })

  revalidatePath('/posts')
  redirect('/posts')
}
```

```tsx
// components/PostEditor.tsx
'use client'

import { useActionState } from 'react'
import { createPost, updatePost } from '@/app/actions/posts'

interface Post {
  id: string
  title: string
  content: string
  published: boolean
}

interface Props {
  post?: Post
}

export function PostEditor({ post }: Props) {
  const action = post ? updatePost.bind(null, post.id) : createPost

  const [state, formAction, isPending] = useActionState(action, null)

  return (
    <form action={formAction} className="space-y-4 max-w-2xl">
      <div>
        <label className="block font-medium mb-1">æ ‡é¢˜</label>
        <input
          name="title"
          defaultValue={post?.title}
          className="w-full border rounded px-3 py-2"
        />
        {state?.errors?.title && (
          <p className="text-red-500 text-sm">{state.errors.title[0]}</p>
        )}
      </div>

      <div>
        <label className="block font-medium mb-1">å†…å®¹</label>
        <textarea
          name="content"
          defaultValue={post?.content}
          rows={10}
          className="w-full border rounded px-3 py-2"
        />
        {state?.errors?.content && (
          <p className="text-red-500 text-sm">{state.errors.content[0]}</p>
        )}
      </div>

      <label className="flex items-center gap-2">
        <input
          type="checkbox"
          name="published"
          value="true"
          defaultChecked={post?.published}
        />
        <span>ç«‹å³å‘å¸ƒ</span>
      </label>

      {state?.error && <p className="text-red-500">{state.error}</p>}

      <button
        type="submit"
        disabled={isPending}
        className="bg-blue-600 text-white px-6 py-2 rounded disabled:opacity-50"
      >
        {isPending ? 'ä¿å­˜ä¸­...' : post ? 'æ›´æ–°' : 'åˆ›å»º'}
      </button>
    </form>
  )
}
```

## å¸¸è§é—®é¢˜

ğŸ¤” **Q: Server Actions å’Œ API Routes æ€ä¹ˆé€‰ï¼Ÿ**

| åœºæ™¯       | æ¨èæ–¹æ¡ˆ       |
| ---------- | -------------- |
| è¡¨å•æäº¤   | Server Actions |
| æ•°æ®å˜æ›´   | Server Actions |
| ç¬¬ä¸‰æ–¹è°ƒç”¨ | API Routes     |
| Webhook    | API Routes     |
| å…¬å¼€ API   | API Routes     |

ğŸ¤” **Q: Server Actions å®‰å…¨å—ï¼Ÿ**

æ˜¯çš„ã€‚Server Actionsï¼š

- è‡ªåŠ¨åŠ å¯†ä¼ è¾“
- æ”¯æŒ CSRF ä¿æŠ¤
- ä»…æš´éœ²å¿…è¦çš„ç«¯ç‚¹

ğŸ¤” **Q: å¦‚ä½•è°ƒè¯• Server Actionsï¼Ÿ**

```tsx
'use server'

export async function myAction(formData: FormData) {
  console.log('æ”¶åˆ°æ•°æ®:', Object.fromEntries(formData))
  // æ—¥å¿—ä¼šå‡ºç°åœ¨æœåŠ¡å™¨ç»ˆç«¯
}
```

---

ä¸‹ä¸€ç¯‡å°†ä»‹ç» Route Handlersï¼Œå­¦ä¹ å¦‚ä½•åˆ›å»ºè‡ªå®šä¹‰ API ç«¯ç‚¹ã€‚

-EOF-
