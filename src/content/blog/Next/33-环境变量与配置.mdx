---
title: ç¯å¢ƒå˜é‡ä¸é…ç½®
description: æŒæ¡ Next.js ç¯å¢ƒå˜é‡ç®¡ç†ï¼Œå®‰å…¨é…ç½®æ•æ„Ÿä¿¡æ¯ä¸è¿è¡Œæ—¶é…ç½®
pubDate: 2025-12-03
toc: true
ogImage: true
category: Next
tags: ['Next.js', 'ç¯å¢ƒå˜é‡', 'é…ç½®', 'å®‰å…¨']
---

ğŸ™‹ API å¯†é’¥ã€æ•°æ®åº“è¿æ¥ä¸²è¿™äº›æ•æ„Ÿä¿¡æ¯æ€ä¹ˆç®¡ç†ï¼Ÿå¦‚ä½•åŒºåˆ†å¼€å‘å’Œç”Ÿäº§ç¯å¢ƒï¼Ÿ

## ç¯å¢ƒå˜é‡åŸºç¡€

### .env æ–‡ä»¶

```
.env                 # æ‰€æœ‰ç¯å¢ƒï¼Œæäº¤åˆ° git
.env.local           # æœ¬åœ°è¦†ç›–ï¼Œä¸æäº¤
.env.development     # å¼€å‘ç¯å¢ƒ
.env.production      # ç”Ÿäº§ç¯å¢ƒ
.env.test            # æµ‹è¯•ç¯å¢ƒ
```

åŠ è½½ä¼˜å…ˆçº§ï¼ˆé«˜åˆ°ä½ï¼‰ï¼š

```
.env.development.local
.env.local
.env.development
.env
```

### å®šä¹‰ç¯å¢ƒå˜é‡

```bash
# .env.local
DATABASE_URL="postgresql://user:password@localhost:5432/mydb"
API_SECRET="super-secret-key"

# å®¢æˆ·ç«¯å¯è®¿é—®ï¼ˆéœ€è¦ NEXT_PUBLIC_ å‰ç¼€ï¼‰
NEXT_PUBLIC_APP_URL="http://localhost:3000"
NEXT_PUBLIC_GA_ID="G-XXXXXXXXXX"
```

### ä½¿ç”¨ç¯å¢ƒå˜é‡

```tsx
// æœåŠ¡ç«¯ï¼ˆä»»æ„ç¯å¢ƒå˜é‡ï¼‰
const dbUrl = process.env.DATABASE_URL
const secret = process.env.API_SECRET

// å®¢æˆ·ç«¯ï¼ˆä»… NEXT_PUBLIC_ å‰ç¼€ï¼‰
const appUrl = process.env.NEXT_PUBLIC_APP_URL

// âŒ å®¢æˆ·ç«¯æ— æ³•è®¿é—®
const secret = process.env.API_SECRET // undefined
```

## ç±»å‹å®‰å…¨

### ç¯å¢ƒå˜é‡éªŒè¯

```tsx
// lib/env.ts
import { z } from 'zod'

const envSchema = z.object({
  // æœåŠ¡ç«¯å˜é‡
  DATABASE_URL: z.string().url(),
  API_SECRET: z.string().min(32),
  REDIS_URL: z.string().url().optional(),

  // å®¢æˆ·ç«¯å˜é‡
  NEXT_PUBLIC_APP_URL: z.string().url(),
  NEXT_PUBLIC_GA_ID: z.string().optional(),
})

// éªŒè¯å¹¶å¯¼å‡º
const parsed = envSchema.safeParse(process.env)

if (!parsed.success) {
  console.error('âŒ Invalid environment variables:', parsed.error.format())
  throw new Error('Invalid environment variables')
}

export const env = parsed.data
```

### ä½¿ç”¨ç±»å‹å®‰å…¨çš„ç¯å¢ƒå˜é‡

```tsx
// app/page.tsx
import { env } from '@/lib/env'

export default function Page() {
  // ç±»å‹å®‰å…¨ï¼ŒIDE è‡ªåŠ¨è¡¥å…¨
  const appUrl = env.NEXT_PUBLIC_APP_URL

  return <div>{appUrl}</div>
}
```

### åˆ†ç¦»æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯

```tsx
// lib/env.ts
import { z } from 'zod'

// æœåŠ¡ç«¯ç¯å¢ƒå˜é‡
const serverEnvSchema = z.object({
  DATABASE_URL: z.string().url(),
  API_SECRET: z.string().min(32),
  AUTH_SECRET: z.string().min(32),
})

// å®¢æˆ·ç«¯ç¯å¢ƒå˜é‡
const clientEnvSchema = z.object({
  NEXT_PUBLIC_APP_URL: z.string().url(),
  NEXT_PUBLIC_GA_ID: z.string().optional(),
})

// æœåŠ¡ç«¯å˜é‡ï¼ˆä»…åœ¨æœåŠ¡ç«¯éªŒè¯ï¼‰
export const serverEnv = (() => {
  if (typeof window !== 'undefined') {
    throw new Error('serverEnv cannot be accessed on the client')
  }
  return serverEnvSchema.parse(process.env)
})()

// å®¢æˆ·ç«¯å˜é‡
export const clientEnv = clientEnvSchema.parse({
  NEXT_PUBLIC_APP_URL: process.env.NEXT_PUBLIC_APP_URL,
  NEXT_PUBLIC_GA_ID: process.env.NEXT_PUBLIC_GA_ID,
})
```

## è¿è¡Œæ—¶é…ç½®

### next.config.ts ç¯å¢ƒå˜é‡

```tsx
// next.config.ts
import type { NextConfig } from 'next'

const config: NextConfig = {
  env: {
    // æ„å»ºæ—¶æ³¨å…¥
    BUILD_TIME: new Date().toISOString(),
    GIT_COMMIT: process.env.VERCEL_GIT_COMMIT_SHA || 'development',
  },
}

export default config
```

### å…¬å…±è¿è¡Œæ—¶é…ç½®

```tsx
// next.config.ts
const config: NextConfig = {
  publicRuntimeConfig: {
    // å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯éƒ½å¯è®¿é—®
    staticFolder: '/static',
  },
  serverRuntimeConfig: {
    // ä»…æœåŠ¡ç«¯å¯è®¿é—®
    mySecret: process.env.MY_SECRET,
  },
}
```

```tsx
// ä½¿ç”¨
import getConfig from 'next/config'

const { serverRuntimeConfig, publicRuntimeConfig } = getConfig()

// æœåŠ¡ç«¯
console.log(serverRuntimeConfig.mySecret)

// å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯
console.log(publicRuntimeConfig.staticFolder)
```

## å¤šç¯å¢ƒé…ç½®

### å¼€å‘ç¯å¢ƒ

```bash
# .env.development
DATABASE_URL="postgresql://localhost:5432/myapp_dev"
NEXT_PUBLIC_APP_URL="http://localhost:3000"
LOG_LEVEL="debug"
```

### ç”Ÿäº§ç¯å¢ƒ

```bash
# .env.production
DATABASE_URL="postgresql://prod-server:5432/myapp"
NEXT_PUBLIC_APP_URL="https://myapp.com"
LOG_LEVEL="error"
```

### æµ‹è¯•ç¯å¢ƒ

```bash
# .env.test
DATABASE_URL="postgresql://localhost:5432/myapp_test"
NEXT_PUBLIC_APP_URL="http://localhost:3000"
LOG_LEVEL="warn"
```

### æ¡ä»¶é€»è¾‘

```tsx
// lib/config.ts
const isDevelopment = process.env.NODE_ENV === 'development'
const isProduction = process.env.NODE_ENV === 'production'
const isTest = process.env.NODE_ENV === 'test'

export const config = {
  isDevelopment,
  isProduction,
  isTest,

  apiUrl: isProduction ? 'https://api.myapp.com' : 'http://localhost:4000',

  features: {
    debugMode: isDevelopment,
    analytics: isProduction,
  },
}
```

## å®‰å…¨æœ€ä½³å®è·µ

### ä¸è¦æäº¤æ•æ„Ÿä¿¡æ¯

```text
# .gitignore
.env.local
.env.*.local
```

### æä¾›ç¤ºä¾‹æ–‡ä»¶

```bash
# .env.exampleï¼ˆæäº¤åˆ° gitï¼‰
DATABASE_URL="postgresql://user:password@localhost:5432/mydb"
API_SECRET="your-api-secret-here"
NEXT_PUBLIC_APP_URL="http://localhost:3000"
```

### éªŒè¯å¿…éœ€å˜é‡

```tsx
// lib/env.ts
const requiredEnvVars = ['DATABASE_URL', 'API_SECRET', 'AUTH_SECRET'] as const

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new Error(`Missing required environment variable: ${envVar}`)
  }
}
```

### ä¸è¦åœ¨å®¢æˆ·ç«¯æš´éœ²æ•æ„Ÿä¿¡æ¯

```tsx
// âŒ é”™è¯¯ï¼šæ•æ„Ÿä¿¡æ¯æš´éœ²ç»™å®¢æˆ·ç«¯
const NEXT_PUBLIC_API_SECRET = 'secret' // ä¸è¦è¿™æ ·åšï¼

// âœ… æ­£ç¡®ï¼šé€šè¿‡ API è·¯ç”±è®¿é—®
// app/api/protected/route.ts
const secret = process.env.API_SECRET // ä»…æœåŠ¡ç«¯å¯è®¿é—®
```

## éƒ¨ç½²å¹³å°é…ç½®

### Vercel

```bash
# é€šè¿‡ CLI è®¾ç½®
vercel env add DATABASE_URL

# æˆ–åœ¨ä»ªè¡¨æ¿ä¸­è®¾ç½®
# Settings > Environment Variables
```

```tsx
// ä½¿ç”¨ Vercel ç‰¹æœ‰å˜é‡
const commitSha = process.env.VERCEL_GIT_COMMIT_SHA
const deploymentUrl = process.env.VERCEL_URL
```

### Docker

```dockerfile
# Dockerfile
FROM node:20-alpine

# æ„å»ºå‚æ•°
ARG DATABASE_URL
ARG NEXT_PUBLIC_APP_URL

# è®¾ç½®ç¯å¢ƒå˜é‡
ENV DATABASE_URL=$DATABASE_URL
ENV NEXT_PUBLIC_APP_URL=$NEXT_PUBLIC_APP_URL

# ...
```

```bash
# æ„å»ºæ—¶ä¼ å…¥
docker build \
  --build-arg DATABASE_URL="..." \
  --build-arg NEXT_PUBLIC_APP_URL="https://myapp.com" \
  -t myapp .
```

### Docker Compose

```yaml
# docker-compose.yml
services:
  app:
    build: .
    environment:
      - DATABASE_URL=postgresql://db:5432/myapp
      - API_SECRET=${API_SECRET}
    env_file:
      - .env.production
```

## é…ç½®æ–‡ä»¶ç»„ç»‡

### é›†ä¸­ç®¡ç†

```tsx
// config/index.ts
import { env } from '@/lib/env'

export const config = {
  app: {
    name: 'My App',
    url: env.NEXT_PUBLIC_APP_URL,
    version: process.env.npm_package_version || '0.0.0',
  },

  database: {
    url: env.DATABASE_URL,
    poolSize: parseInt(process.env.DB_POOL_SIZE || '10'),
  },

  auth: {
    secret: env.AUTH_SECRET,
    sessionMaxAge: 60 * 60 * 24 * 7, // 7 å¤©
  },

  email: {
    from: process.env.EMAIL_FROM || 'noreply@myapp.com',
    replyTo: process.env.EMAIL_REPLY_TO,
  },

  features: {
    enableRegistration: process.env.ENABLE_REGISTRATION !== 'false',
    maintenanceMode: process.env.MAINTENANCE_MODE === 'true',
  },
}
```

### ä½¿ç”¨é…ç½®

```tsx
// app/api/auth/route.ts
import { config } from '@/config'

export async function POST() {
  if (config.features.maintenanceMode) {
    return Response.json({ error: 'ç³»ç»Ÿç»´æŠ¤ä¸­' }, { status: 503 })
  }

  // ...
}
```

## åŠ¨æ€é…ç½®

### ä»æ•°æ®åº“åŠ è½½

```tsx
// lib/dynamic-config.ts
import { cache } from 'react'
import { db } from '@/lib/db'

export const getConfig = cache(async () => {
  const settings = await db.setting.findMany()

  return settings.reduce(
    (acc, setting) => {
      acc[setting.key] = setting.value
      return acc
    },
    {} as Record<string, string>
  )
})
```

### ç‰¹æ€§å¼€å…³

```tsx
// lib/features.ts
import { cache } from 'react'
import { db } from '@/lib/db'

interface FeatureFlags {
  newDashboard: boolean
  betaFeatures: boolean
  darkMode: boolean
}

export const getFeatureFlags = cache(async (): Promise<FeatureFlags> => {
  const flags = await db.featureFlag.findMany()

  return {
    newDashboard:
      flags.find((f) => f.name === 'newDashboard')?.enabled ?? false,
    betaFeatures:
      flags.find((f) => f.name === 'betaFeatures')?.enabled ?? false,
    darkMode: flags.find((f) => f.name === 'darkMode')?.enabled ?? true,
  }
})
```

```tsx
// app/dashboard/page.tsx
import { getFeatureFlags } from '@/lib/features'
import { NewDashboard } from '@/components/NewDashboard'
import { OldDashboard } from '@/components/OldDashboard'

export default async function DashboardPage() {
  const flags = await getFeatureFlags()

  return flags.newDashboard ? <NewDashboard /> : <OldDashboard />
}
```

## å¸¸è§é—®é¢˜

ğŸ¤” **Q: ç¯å¢ƒå˜é‡ä¿®æ”¹åä¸ç”Ÿæ•ˆï¼Ÿ**

éœ€è¦é‡å¯å¼€å‘æœåŠ¡å™¨ã€‚ç¯å¢ƒå˜é‡åœ¨å¯åŠ¨æ—¶è¯»å–ã€‚

```bash
# åœæ­¢åé‡æ–°å¯åŠ¨
pnpm dev
```

ğŸ¤” **Q: å¦‚ä½•åœ¨æ„å»ºæ—¶ä½¿ç”¨ä¸åŒçš„ç¯å¢ƒå˜é‡ï¼Ÿ**

```bash
# ä½¿ç”¨ç‰¹å®šç¯å¢ƒæ–‡ä»¶
NODE_ENV=production pnpm build

# æˆ–ç›´æ¥æŒ‡å®š
DATABASE_URL="..." pnpm build
```

ğŸ¤” **Q: å®¢æˆ·ç«¯èƒ½è®¿é—® process.env å—ï¼Ÿ**

åªèƒ½è®¿é—® `NEXT_PUBLIC_` å‰ç¼€çš„å˜é‡ã€‚å…¶ä»–å˜é‡åœ¨å®¢æˆ·ç«¯æ‰“åŒ…æ—¶ä¼šè¢«æ›¿æ¢ä¸º `undefined`ã€‚

---

ä¸‹ä¸€ç¯‡å°†ä»‹ç»æµ‹è¯•ç­–ç•¥ï¼Œå­¦ä¹ å¦‚ä½•æµ‹è¯• Next.js åº”ç”¨ã€‚

-EOF-
