---
title: æ•°æ®åº“é›†æˆ
description: åœ¨ Next.js ä¸­é›†æˆ Prisma å’Œ Drizzle ORMï¼Œå®ç°ç±»å‹å®‰å…¨çš„æ•°æ®åº“æ“ä½œä¸è¿æ¥æ± ç®¡ç†
pubDate: 2025-12-03
toc: true
ogImage: true
category: Next
tags: ['Next.js', 'Prisma', 'Drizzle', 'æ•°æ®åº“', 'ORM']
---

ğŸ™‹ å…¨æ ˆåº”ç”¨éœ€è¦æ•°æ®åº“ã€‚å¦‚ä½•åœ¨ Next.js ä¸­é«˜æ•ˆã€å®‰å…¨åœ°è¿›è¡Œæ•°æ®åº“æ“ä½œï¼Ÿ

## ORM é€‰æ‹©

| ç‰¹æ€§        | Prisma       | Drizzle    |
| ----------- | ------------ | ---------- |
| ç±»å‹å®‰å…¨    | âœ…           | âœ…         |
| Schema å®šä¹‰ | .prisma æ–‡ä»¶ | TypeScript |
| å­¦ä¹ æ›²çº¿    | ä¸­ç­‰         | è¾ƒä½       |
| æŸ¥è¯¢é£æ ¼    | é“¾å¼ API     | SQL-like   |
| Bundle å¤§å° | è¾ƒå¤§         | è¾ƒå°       |
| Edge æ”¯æŒ   | éœ€è¦é€‚é…å™¨   | åŸç”Ÿæ”¯æŒ   |

## Prisma é›†æˆ

### å®‰è£…ä¸åˆå§‹åŒ–

```bash
# å®‰è£… Prisma
pnpm add prisma @prisma/client
pnpm add -D prisma

# åˆå§‹åŒ–
npx prisma init
```

### Schema å®šä¹‰

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  password  String
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
  tags      Tag[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([authorId])
}

model Tag {
  id    String @id @default(cuid())
  name  String @unique
  posts Post[]
}
```

### å®¢æˆ·ç«¯å®ä¾‹

```tsx
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      process.env.NODE_ENV === 'development'
        ? ['query', 'error', 'warn']
        : ['error'],
  })

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
}
```

ğŸ”¶ **é‡è¦**ï¼šåœ¨å¼€å‘ç¯å¢ƒä½¿ç”¨å…¨å±€å˜é‡é¿å…çƒ­é‡è½½åˆ›å»ºå¤šä¸ªè¿æ¥ã€‚

### æ•°æ®åº“è¿ç§»

```bash
# åˆ›å»ºè¿ç§»
npx prisma migrate dev --name init

# ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
npx prisma migrate deploy

# é‡ç½®æ•°æ®åº“ï¼ˆå¼€å‘ç”¨ï¼‰
npx prisma migrate reset

# ç”Ÿæˆå®¢æˆ·ç«¯
npx prisma generate
```

### åŸºç¡€ CRUD æ“ä½œ

```tsx
// app/actions/users.ts
'use server'

import { prisma } from '@/lib/prisma'
import { revalidatePath } from 'next/cache'

// åˆ›å»º
export async function createUser(data: {
  email: string
  name: string
  password: string
}) {
  const user = await prisma.user.create({
    data: {
      email: data.email,
      name: data.name,
      password: data.password, // å®é™…åº”è¯¥å“ˆå¸Œå¤„ç†
    },
  })

  revalidatePath('/users')
  return user
}

// æŸ¥è¯¢
export async function getUsers() {
  return prisma.user.findMany({
    select: {
      id: true,
      email: true,
      name: true,
      createdAt: true,
      _count: {
        select: { posts: true },
      },
    },
    orderBy: { createdAt: 'desc' },
  })
}

// æŸ¥è¯¢å•ä¸ª
export async function getUser(id: string) {
  return prisma.user.findUnique({
    where: { id },
    include: {
      posts: {
        where: { published: true },
        orderBy: { createdAt: 'desc' },
      },
    },
  })
}

// æ›´æ–°
export async function updateUser(
  id: string,
  data: { name?: string; email?: string }
) {
  const user = await prisma.user.update({
    where: { id },
    data,
  })

  revalidatePath('/users')
  revalidatePath(`/users/${id}`)
  return user
}

// åˆ é™¤
export async function deleteUser(id: string) {
  await prisma.user.delete({
    where: { id },
  })

  revalidatePath('/users')
}
```

### å…³è”æŸ¥è¯¢

```tsx
// è·å–æ–‡ç« åŠä½œè€…
export async function getPostWithAuthor(id: string) {
  return prisma.post.findUnique({
    where: { id },
    include: {
      author: {
        select: { id: true, name: true, email: true },
      },
      tags: true,
    },
  })
}

// è·å–ç”¨æˆ·çš„æ‰€æœ‰æ–‡ç« 
export async function getUserPosts(userId: string) {
  return prisma.post.findMany({
    where: { authorId: userId },
    include: { tags: true },
    orderBy: { createdAt: 'desc' },
  })
}

// åˆ›å»ºæ–‡ç« å¹¶å…³è”æ ‡ç­¾
export async function createPost(data: {
  title: string
  content: string
  authorId: string
  tags: string[]
}) {
  return prisma.post.create({
    data: {
      title: data.title,
      content: data.content,
      authorId: data.authorId,
      tags: {
        connectOrCreate: data.tags.map((name) => ({
          where: { name },
          create: { name },
        })),
      },
    },
    include: { tags: true },
  })
}
```

### äº‹åŠ¡å¤„ç†

```tsx
// è½¬è´¦ç¤ºä¾‹
export async function transfer(fromId: string, toId: string, amount: number) {
  return prisma.$transaction(async (tx) => {
    // æ‰£é™¤å‘é€æ–¹ä½™é¢
    const sender = await tx.user.update({
      where: { id: fromId },
      data: { balance: { decrement: amount } },
    })

    if (sender.balance < 0) {
      throw new Error('ä½™é¢ä¸è¶³')
    }

    // å¢åŠ æ¥æ”¶æ–¹ä½™é¢
    await tx.user.update({
      where: { id: toId },
      data: { balance: { increment: amount } },
    })

    // è®°å½•äº¤æ˜“
    await tx.transaction.create({
      data: { fromId, toId, amount },
    })

    return { success: true }
  })
}
```

## Drizzle é›†æˆ

### å®‰è£…

```bash
# PostgreSQL
pnpm add drizzle-orm postgres
pnpm add -D drizzle-kit

# æˆ– MySQL
pnpm add drizzle-orm mysql2
pnpm add -D drizzle-kit
```

### Schema å®šä¹‰

```tsx
// db/schema.ts
import { pgTable, text, timestamp, boolean, uuid } from 'drizzle-orm/pg-core'
import { relations } from 'drizzle-orm'

export const users = pgTable('users', {
  id: uuid('id').defaultRandom().primaryKey(),
  email: text('email').notNull().unique(),
  name: text('name'),
  password: text('password').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
})

export const posts = pgTable('posts', {
  id: uuid('id').defaultRandom().primaryKey(),
  title: text('title').notNull(),
  content: text('content'),
  published: boolean('published').default(false).notNull(),
  authorId: uuid('author_id')
    .notNull()
    .references(() => users.id),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
})

export const tags = pgTable('tags', {
  id: uuid('id').defaultRandom().primaryKey(),
  name: text('name').notNull().unique(),
})

export const postsToTags = pgTable('posts_to_tags', {
  postId: uuid('post_id')
    .notNull()
    .references(() => posts.id),
  tagId: uuid('tag_id')
    .notNull()
    .references(() => tags.id),
})

// å®šä¹‰å…³ç³»
export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}))

export const postsRelations = relations(posts, ({ one, many }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
  tags: many(postsToTags),
}))
```

### å®¢æˆ·ç«¯å®ä¾‹

```tsx
// db/index.ts
import { drizzle } from 'drizzle-orm/postgres-js'
import postgres from 'postgres'
import * as schema from './schema'

const connectionString = process.env.DATABASE_URL!

// è¿æ¥æ± é…ç½®
const client = postgres(connectionString, {
  max: 10,
  idle_timeout: 20,
  connect_timeout: 10,
})

export const db = drizzle(client, { schema })
```

### é…ç½®æ–‡ä»¶

```tsx
// drizzle.config.ts
import type { Config } from 'drizzle-kit'

export default {
  schema: './db/schema.ts',
  out: './drizzle',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
} satisfies Config
```

### è¿ç§»å‘½ä»¤

```bash
# ç”Ÿæˆè¿ç§»
npx drizzle-kit generate

# æ‰§è¡Œè¿ç§»
npx drizzle-kit migrate

# æ¨é€ schemaï¼ˆå¼€å‘ç”¨ï¼‰
npx drizzle-kit push

# æ‰“å¼€ Studio
npx drizzle-kit studio
```

### åŸºç¡€ CRUD æ“ä½œ

```tsx
// app/actions/users.ts
'use server'

import { db } from '@/db'
import { users, posts } from '@/db/schema'
import { eq, desc } from 'drizzle-orm'
import { revalidatePath } from 'next/cache'

// åˆ›å»º
export async function createUser(data: {
  email: string
  name: string
  password: string
}) {
  const [user] = await db
    .insert(users)
    .values({
      email: data.email,
      name: data.name,
      password: data.password,
    })
    .returning()

  revalidatePath('/users')
  return user
}

// æŸ¥è¯¢æ‰€æœ‰
export async function getUsers() {
  return db.select().from(users).orderBy(desc(users.createdAt))
}

// æŸ¥è¯¢å•ä¸ª
export async function getUser(id: string) {
  const [user] = await db.select().from(users).where(eq(users.id, id))
  return user
}

// æ›´æ–°
export async function updateUser(
  id: string,
  data: { name?: string; email?: string }
) {
  const [user] = await db
    .update(users)
    .set({ ...data, updatedAt: new Date() })
    .where(eq(users.id, id))
    .returning()

  revalidatePath('/users')
  return user
}

// åˆ é™¤
export async function deleteUser(id: string) {
  await db.delete(users).where(eq(users.id, id))
  revalidatePath('/users')
}
```

### å…³è”æŸ¥è¯¢

```tsx
// ä½¿ç”¨ with è¿›è¡Œå…³è”æŸ¥è¯¢
export async function getUserWithPosts(id: string) {
  const result = await db.query.users.findFirst({
    where: eq(users.id, id),
    with: {
      posts: {
        orderBy: desc(posts.createdAt),
      },
    },
  })

  return result
}

// æ‰‹åŠ¨ JOIN
export async function getPostsWithAuthors() {
  return db
    .select({
      post: posts,
      author: {
        id: users.id,
        name: users.name,
        email: users.email,
      },
    })
    .from(posts)
    .leftJoin(users, eq(posts.authorId, users.id))
    .orderBy(desc(posts.createdAt))
}
```

### äº‹åŠ¡å¤„ç†

```tsx
export async function createPostWithTags(data: {
  title: string
  content: string
  authorId: string
  tagNames: string[]
}) {
  return db.transaction(async (tx) => {
    // åˆ›å»ºæ–‡ç« 
    const [post] = await tx
      .insert(posts)
      .values({
        title: data.title,
        content: data.content,
        authorId: data.authorId,
      })
      .returning()

    // åˆ›å»ºæˆ–è·å–æ ‡ç­¾
    for (const name of data.tagNames) {
      const [tag] = await tx
        .insert(tags)
        .values({ name })
        .onConflictDoNothing()
        .returning()

      const existingTag =
        tag ||
        (await tx.query.tags.findFirst({
          where: eq(tags.name, name),
        }))

      if (existingTag) {
        await tx.insert(postsToTags).values({
          postId: post.id,
          tagId: existingTag.id,
        })
      }
    }

    return post
  })
}
```

## è¿æ¥æ± ç®¡ç†

### Serverless ç¯å¢ƒ

```tsx
// lib/db.ts (Prisma with connection pooling)
import { PrismaClient } from '@prisma/client'
import { Pool } from '@neondatabase/serverless'
import { PrismaNeon } from '@prisma/adapter-neon'

const pool = new Pool({ connectionString: process.env.DATABASE_URL })
const adapter = new PrismaNeon(pool)

export const prisma = new PrismaClient({ adapter })
```

### ä½¿ç”¨å¤–éƒ¨è¿æ¥æ± 

```
# .env
# ç›´æ¥è¿æ¥ï¼ˆç”¨äºè¿ç§»ï¼‰
DATABASE_URL="postgresql://user:password@host:5432/db"

# è¿æ¥æ± ï¼ˆç”¨äºåº”ç”¨ï¼‰
DATABASE_URL_POOLED="postgresql://user:password@pooler.host:6543/db?pgbouncer=true"
```

```tsx
// å¼€å‘ç¯å¢ƒä½¿ç”¨ç›´æ¥è¿æ¥ï¼Œç”Ÿäº§ä½¿ç”¨è¿æ¥æ± 
const connectionString =
  process.env.NODE_ENV === 'production'
    ? process.env.DATABASE_URL_POOLED
    : process.env.DATABASE_URL
```

## åœ¨ Server Components ä¸­ä½¿ç”¨

```tsx
// app/users/page.tsx
// Next.js 15.x
import { prisma } from '@/lib/prisma'
import Link from 'next/link'

export default async function UsersPage() {
  const users = await prisma.user.findMany({
    select: {
      id: true,
      name: true,
      email: true,
      _count: { select: { posts: true } },
    },
    orderBy: { createdAt: 'desc' },
  })

  return (
    <div>
      <h1 className="text-2xl font-bold mb-4">ç”¨æˆ·åˆ—è¡¨</h1>
      <ul className="space-y-2">
        {users.map((user) => (
          <li key={user.id} className="p-4 border rounded">
            <Link href={`/users/${user.id}`}>
              <h2 className="font-medium">{user.name || 'æœªå‘½å'}</h2>
              <p className="text-gray-500">{user.email}</p>
              <p className="text-sm">{user._count.posts} ç¯‡æ–‡ç« </p>
            </Link>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

## æ•°æ®éªŒè¯

### ä½¿ç”¨ Zod

```tsx
// lib/validations/user.ts
import { z } from 'zod'

export const createUserSchema = z.object({
  email: z.string().email('æ— æ•ˆçš„é‚®ç®±æ ¼å¼'),
  name: z.string().min(2, 'åç§°è‡³å°‘ 2 ä¸ªå­—ç¬¦').max(50),
  password: z.string().min(8, 'å¯†ç è‡³å°‘ 8 ä¸ªå­—ç¬¦'),
})

export const updateUserSchema = createUserSchema.partial()

export type CreateUserInput = z.infer<typeof createUserSchema>
export type UpdateUserInput = z.infer<typeof updateUserSchema>
```

```tsx
// app/actions/users.ts
'use server'

import { prisma } from '@/lib/prisma'
import { createUserSchema, updateUserSchema } from '@/lib/validations/user'
import { hash } from 'bcryptjs'

export async function createUser(formData: FormData) {
  const rawData = {
    email: formData.get('email'),
    name: formData.get('name'),
    password: formData.get('password'),
  }

  const result = createUserSchema.safeParse(rawData)

  if (!result.success) {
    return { errors: result.error.flatten().fieldErrors }
  }

  const hashedPassword = await hash(result.data.password, 12)

  try {
    const user = await prisma.user.create({
      data: {
        ...result.data,
        password: hashedPassword,
      },
    })

    return { user }
  } catch (error) {
    if ((error as any).code === 'P2002') {
      return { errors: { email: ['é‚®ç®±å·²è¢«æ³¨å†Œ'] } }
    }
    throw error
  }
}
```

## æ€§èƒ½ä¼˜åŒ–

### é€‰æ‹©æ€§æŸ¥è¯¢

```tsx
// âœ… åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
const users = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    // ä¸æŸ¥è¯¢ password ç­‰æ•æ„Ÿå­—æ®µ
  },
})

// âŒ æŸ¥è¯¢æ‰€æœ‰å­—æ®µ
const users = await prisma.user.findMany()
```

### åˆ†é¡µæŸ¥è¯¢

```tsx
export async function getPaginatedPosts(page: number, limit: number = 10) {
  const [posts, total] = await Promise.all([
    prisma.post.findMany({
      skip: (page - 1) * limit,
      take: limit,
      orderBy: { createdAt: 'desc' },
    }),
    prisma.post.count(),
  ])

  return {
    posts,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
    },
  }
}
```

### ç¼“å­˜æ•°æ®åº“æŸ¥è¯¢

```tsx
import { cache } from 'react'

// ä½¿ç”¨ React cache å»é‡
export const getUser = cache(async (id: string) => {
  return prisma.user.findUnique({ where: { id } })
})

// ä½¿ç”¨ unstable_cache æŒä¹…åŒ–
import { unstable_cache } from 'next/cache'

export const getCachedUser = unstable_cache(
  async (id: string) => {
    return prisma.user.findUnique({ where: { id } })
  },
  ['user'],
  { revalidate: 60, tags: ['users'] }
)
```

## å¸¸è§é—®é¢˜

ğŸ¤” **Q: Prisma å’Œ Drizzle æ€ä¹ˆé€‰ï¼Ÿ**

- Prismaï¼šåŠŸèƒ½å…¨é¢ï¼Œç”Ÿæ€æˆç†Ÿï¼Œé€‚åˆå¿«é€Ÿå¼€å‘
- Drizzleï¼šè½»é‡é«˜æ•ˆï¼ŒSQL-like è¯­æ³•ï¼Œé€‚åˆè¿½æ±‚æ€§èƒ½

ğŸ¤” **Q: å¦‚ä½•å¤„ç†æ•°æ®åº“è¿æ¥è¶…æ—¶ï¼Ÿ**

é…ç½®è¿æ¥æ± å‚æ•°ï¼š

```tsx
// Prisma
new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
})

// Drizzle with postgres.js
postgres(url, {
  max: 10,
  idle_timeout: 20,
  connect_timeout: 10,
})
```

ğŸ¤” **Q: Edge Runtime å¦‚ä½•ä½¿ç”¨æ•°æ®åº“ï¼Ÿ**

ä½¿ç”¨æ”¯æŒ Edge çš„æ•°æ®åº“é©±åŠ¨ï¼Œå¦‚ Neonã€PlanetScale æˆ– Tursoã€‚

---

ä¸‹ä¸€ç¯‡å°†ä»‹ç»é”™è¯¯å¤„ç†ï¼Œå­¦ä¹ å¦‚ä½•ä¼˜é›…åœ°å¤„ç†åº”ç”¨ä¸­çš„å„ç§é”™è¯¯ã€‚

-EOF-
