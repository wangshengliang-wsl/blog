---
title: Route Handlers
description: æŒæ¡ Next.js Route Handlersï¼Œåˆ›å»ºè‡ªå®šä¹‰ API ç«¯ç‚¹ï¼Œå¤„ç†å„ç§ HTTP è¯·æ±‚ä¸æµå¼å“åº”
pubDate: 2025-12-03
toc: true
ogImage: true
category: Next
tags: ['Next.js', 'Route Handlers', 'API', 'REST']
---

ğŸ™‹ éœ€è¦åˆ›å»º REST API æˆ–å¤„ç† Webhookï¼ŸRoute Handlers è®©ä½ åœ¨ App Router ä¸­è½»æ¾æ„å»º API ç«¯ç‚¹ã€‚

## åŸºç¡€ç”¨æ³•

### åˆ›å»º Route Handler

```
app/
â””â”€â”€ api/
    â””â”€â”€ hello/
        â””â”€â”€ route.ts   # /api/hello
```

```tsx
// app/api/hello/route.ts
// Next.js 15.x
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.json({ message: 'Hello, World!' })
}
```

### HTTP æ–¹æ³•

```tsx
// app/api/posts/route.ts
import { NextRequest, NextResponse } from 'next/server'

// GET /api/posts
export async function GET() {
  const posts = await db.post.findMany()
  return NextResponse.json(posts)
}

// POST /api/posts
export async function POST(request: NextRequest) {
  const data = await request.json()
  const post = await db.post.create({ data })
  return NextResponse.json(post, { status: 201 })
}
```

```tsx
// app/api/posts/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'

// GET /api/posts/:id
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const post = await db.post.findUnique({ where: { id } })

  if (!post) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  return NextResponse.json(post)
}

// PUT /api/posts/:id
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const data = await request.json()

  const post = await db.post.update({
    where: { id },
    data,
  })

  return NextResponse.json(post)
}

// DELETE /api/posts/:id
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  await db.post.delete({ where: { id } })

  return new NextResponse(null, { status: 204 })
}
```

æ”¯æŒçš„ HTTP æ–¹æ³•ï¼š`GET`ã€`POST`ã€`PUT`ã€`PATCH`ã€`DELETE`ã€`HEAD`ã€`OPTIONS`

## è¯·æ±‚å¤„ç†

### è·å–è¯·æ±‚æ•°æ®

```tsx
// app/api/submit/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  // JSON æ•°æ®
  const json = await request.json()

  // FormData
  const formData = await request.formData()
  const name = formData.get('name')

  // æ–‡æœ¬
  const text = await request.text()

  // ArrayBuffer
  const buffer = await request.arrayBuffer()

  return NextResponse.json({ received: true })
}
```

### URL å‚æ•°

```tsx
// app/api/search/route.ts
import { NextRequest, NextResponse } from 'next/server'

// GET /api/search?q=keyword&page=1
export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  const query = searchParams.get('q')
  const page = parseInt(searchParams.get('page') || '1')

  const results = await db.post.findMany({
    where: {
      title: { contains: query || '' },
    },
    skip: (page - 1) * 10,
    take: 10,
  })

  return NextResponse.json({
    results,
    page,
    query,
  })
}
```

### è¯·æ±‚å¤´

```tsx
// app/api/protected/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { headers } from 'next/headers'

export async function GET(request: NextRequest) {
  // æ–¹å¼ä¸€ï¼šä» request è·å–
  const authHeader = request.headers.get('authorization')

  // æ–¹å¼äºŒï¼šä½¿ç”¨ headers() å‡½æ•°
  const headersList = await headers()
  const userAgent = headersList.get('user-agent')

  if (!authHeader?.startsWith('Bearer ')) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const token = authHeader.split(' ')[1]
  // éªŒè¯ token...

  return NextResponse.json({ authenticated: true })
}
```

### Cookies

```tsx
// app/api/auth/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function GET(request: NextRequest) {
  // æ–¹å¼ä¸€ï¼šä» request è·å–
  const token = request.cookies.get('token')?.value

  // æ–¹å¼äºŒï¼šä½¿ç”¨ cookies() å‡½æ•°
  const cookieStore = await cookies()
  const session = cookieStore.get('session')

  return NextResponse.json({ token, session: session?.value })
}

export async function POST(request: NextRequest) {
  const cookieStore = await cookies()

  // è®¾ç½® cookie
  cookieStore.set('token', 'abc123', {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 24 * 7, // 7 å¤©
  })

  return NextResponse.json({ success: true })
}

export async function DELETE() {
  const cookieStore = await cookies()

  // åˆ é™¤ cookie
  cookieStore.delete('token')

  return NextResponse.json({ success: true })
}
```

## å“åº”å¤„ç†

### JSON å“åº”

```tsx
// app/api/data/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  // åŸºæœ¬ JSON å“åº”
  return NextResponse.json({ name: 'Next.js' })

  // å¸¦çŠ¶æ€ç 
  return NextResponse.json({ error: 'Not found' }, { status: 404 })

  // å¸¦è‡ªå®šä¹‰å¤´
  return NextResponse.json(
    { data: 'value' },
    {
      status: 200,
      headers: {
        'X-Custom-Header': 'custom-value',
      },
    }
  )
}
```

### é‡å®šå‘

```tsx
// app/api/redirect/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { redirect } from 'next/navigation'

export async function GET(request: NextRequest) {
  // æ–¹å¼ä¸€ï¼šNextResponse.redirect
  return NextResponse.redirect(new URL('/dashboard', request.url))

  // æ–¹å¼äºŒï¼šredirect å‡½æ•°
  redirect('/dashboard')
}
```

### è®¾ç½®å“åº”å¤´

```tsx
// app/api/cors/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET() {
  const response = NextResponse.json({ data: 'value' })

  // è®¾ç½® CORS å¤´
  response.headers.set('Access-Control-Allow-Origin', '*')
  response.headers.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
  response.headers.set('Access-Control-Allow-Headers', 'Content-Type')

  return response
}

// å¤„ç† OPTIONS é¢„æ£€è¯·æ±‚
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  })
}
```

## æµå¼å“åº”

### æ–‡æœ¬æµ

```tsx
// app/api/stream/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  const encoder = new TextEncoder()

  const stream = new ReadableStream({
    async start(controller) {
      const messages = ['Hello', ' ', 'World', '!']

      for (const message of messages) {
        controller.enqueue(encoder.encode(message))
        await new Promise((resolve) => setTimeout(resolve, 500))
      }

      controller.close()
    },
  })

  return new NextResponse(stream, {
    headers: {
      'Content-Type': 'text/plain',
      'Transfer-Encoding': 'chunked',
    },
  })
}
```

### Server-Sent Events

```tsx
// app/api/events/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  const encoder = new TextEncoder()

  const stream = new ReadableStream({
    async start(controller) {
      let count = 0

      const interval = setInterval(() => {
        count++
        const data = JSON.stringify({ count, time: new Date().toISOString() })
        controller.enqueue(encoder.encode(`data: ${data}\n\n`))

        if (count >= 10) {
          clearInterval(interval)
          controller.close()
        }
      }, 1000)
    },
  })

  return new NextResponse(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  })
}
```

å®¢æˆ·ç«¯ä½¿ç”¨ï¼š

```tsx
// components/EventStream.tsx
'use client'

import { useEffect, useState } from 'react'

export function EventStream() {
  const [events, setEvents] = useState<string[]>([])

  useEffect(() => {
    const eventSource = new EventSource('/api/events')

    eventSource.onmessage = (event) => {
      setEvents((prev) => [...prev, event.data])
    }

    eventSource.onerror = () => {
      eventSource.close()
    }

    return () => eventSource.close()
  }, [])

  return (
    <ul>
      {events.map((event, i) => (
        <li key={i}>{event}</li>
      ))}
    </ul>
  )
}
```

### AI æµå¼å“åº”

```tsx
// app/api/chat/route.ts
import { NextRequest } from 'next/server'

export async function POST(request: NextRequest) {
  const { messages } = await request.json()

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
    },
    body: JSON.stringify({
      model: 'gpt-4',
      messages,
      stream: true,
    }),
  })

  // ç›´æ¥è½¬å‘æµ
  return new Response(response.body, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
    },
  })
}
```

## æ–‡ä»¶å¤„ç†

### æ–‡ä»¶ä¸Šä¼ 

```tsx
// app/api/upload/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { writeFile } from 'fs/promises'
import { join } from 'path'

export async function POST(request: NextRequest) {
  const formData = await request.formData()
  const file = formData.get('file') as File

  if (!file) {
    return NextResponse.json({ error: 'No file uploaded' }, { status: 400 })
  }

  const bytes = await file.arrayBuffer()
  const buffer = Buffer.from(bytes)

  const filename = `${Date.now()}-${file.name}`
  const path = join(process.cwd(), 'public', 'uploads', filename)

  await writeFile(path, buffer)

  return NextResponse.json({
    url: `/uploads/${filename}`,
    size: file.size,
    type: file.type,
  })
}
```

### æ–‡ä»¶ä¸‹è½½

```tsx
// app/api/download/[filename]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { readFile } from 'fs/promises'
import { join } from 'path'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ filename: string }> }
) {
  const { filename } = await params
  const path = join(process.cwd(), 'files', filename)

  try {
    const file = await readFile(path)

    return new NextResponse(file, {
      headers: {
        'Content-Type': 'application/octet-stream',
        'Content-Disposition': `attachment; filename="${filename}"`,
      },
    })
  } catch {
    return NextResponse.json({ error: 'File not found' }, { status: 404 })
  }
}
```

## ç¼“å­˜ä¸é‡éªŒè¯

### é»˜è®¤ç¼“å­˜è¡Œä¸º

```tsx
// app/api/time/route.ts
import { NextResponse } from 'next/server'

// GET è¯·æ±‚é»˜è®¤ä¼šè¢«ç¼“å­˜ï¼ˆå¦‚æœæ²¡æœ‰ä½¿ç”¨åŠ¨æ€å‡½æ•°ï¼‰
export async function GET() {
  return NextResponse.json({ time: new Date().toISOString() })
}
```

### ç¦ç”¨ç¼“å­˜

```tsx
// app/api/realtime/route.ts
import { NextResponse } from 'next/server'

// æ–¹å¼ä¸€ï¼šå¯¼å‡º dynamic é…ç½®
export const dynamic = 'force-dynamic'

export async function GET() {
  return NextResponse.json({ time: new Date().toISOString() })
}
```

```tsx
// æ–¹å¼äºŒï¼šè®¾ç½® revalidate
export const revalidate = 0

// æ–¹å¼ä¸‰ï¼šä½¿ç”¨åŠ¨æ€å‡½æ•°
import { headers } from 'next/headers'

export async function GET() {
  const headersList = await headers() // è§¦å‘åŠ¨æ€æ¸²æŸ“
  return NextResponse.json({ time: new Date().toISOString() })
}
```

### å®šæ—¶é‡éªŒè¯

```tsx
// app/api/news/route.ts
import { NextResponse } from 'next/server'

// æ¯ 60 ç§’é‡æ–°éªŒè¯
export const revalidate = 60

export async function GET() {
  const news = await fetch('https://api.example.com/news').then((r) => r.json())
  return NextResponse.json(news)
}
```

## è®¤è¯ä¸æˆæƒ

### Bearer Token è®¤è¯

```tsx
// app/api/protected/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { verifyToken } from '@/lib/auth'

export async function GET(request: NextRequest) {
  const authHeader = request.headers.get('authorization')

  if (!authHeader?.startsWith('Bearer ')) {
    return NextResponse.json(
      { error: 'Missing authorization header' },
      { status: 401 }
    )
  }

  const token = authHeader.split(' ')[1]

  try {
    const payload = await verifyToken(token)
    return NextResponse.json({ user: payload })
  } catch {
    return NextResponse.json({ error: 'Invalid token' }, { status: 401 })
  }
}
```

### API Key è®¤è¯

```tsx
// app/api/v1/[...path]/route.ts
import { NextRequest, NextResponse } from 'next/server'

const API_KEYS = new Set(process.env.API_KEYS?.split(',') || [])

function validateApiKey(request: NextRequest) {
  const apiKey = request.headers.get('x-api-key')
  return apiKey && API_KEYS.has(apiKey)
}

export async function GET(request: NextRequest) {
  if (!validateApiKey(request)) {
    return NextResponse.json({ error: 'Invalid API key' }, { status: 403 })
  }

  // å¤„ç†è¯·æ±‚...
  return NextResponse.json({ data: 'protected' })
}
```

## Webhook å¤„ç†

### GitHub Webhook

```tsx
// app/api/webhooks/github/route.ts
import { NextRequest, NextResponse } from 'next/server'
import crypto from 'crypto'

function verifySignature(payload: string, signature: string) {
  const secret = process.env.GITHUB_WEBHOOK_SECRET!
  const expectedSignature = `sha256=${crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex')}`

  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  )
}

export async function POST(request: NextRequest) {
  const payload = await request.text()
  const signature = request.headers.get('x-hub-signature-256')

  if (!signature || !verifySignature(payload, signature)) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 })
  }

  const event = request.headers.get('x-github-event')
  const data = JSON.parse(payload)

  switch (event) {
    case 'push':
      console.log('Push event:', data.ref)
      // å¤„ç†æ¨é€äº‹ä»¶
      break
    case 'pull_request':
      console.log('PR event:', data.action)
      // å¤„ç† PR äº‹ä»¶
      break
  }

  return NextResponse.json({ received: true })
}
```

### Stripe Webhook

```tsx
// app/api/webhooks/stripe/route.ts
import { NextRequest, NextResponse } from 'next/server'
import Stripe from 'stripe'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)
const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!

export async function POST(request: NextRequest) {
  const payload = await request.text()
  const signature = request.headers.get('stripe-signature')!

  let event: Stripe.Event

  try {
    event = stripe.webhooks.constructEvent(payload, signature, webhookSecret)
  } catch (err) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })
  }

  switch (event.type) {
    case 'checkout.session.completed':
      const session = event.data.object as Stripe.Checkout.Session
      await handleCheckoutComplete(session)
      break
    case 'invoice.paid':
      const invoice = event.data.object as Stripe.Invoice
      await handleInvoicePaid(invoice)
      break
  }

  return NextResponse.json({ received: true })
}

async function handleCheckoutComplete(session: Stripe.Checkout.Session) {
  // å¤„ç†æ”¯ä»˜å®Œæˆ
}

async function handleInvoicePaid(invoice: Stripe.Invoice) {
  // å¤„ç†å‘ç¥¨æ”¯ä»˜
}
```

## å®æˆ˜ç¤ºä¾‹

### RESTful API

```tsx
// app/api/v1/users/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { db } from '@/lib/db'

const CreateUserSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
})

export async function GET(request: NextRequest) {
  const { searchParams } = request.nextUrl
  const page = parseInt(searchParams.get('page') || '1')
  const limit = parseInt(searchParams.get('limit') || '10')

  const [users, total] = await Promise.all([
    db.user.findMany({
      skip: (page - 1) * limit,
      take: limit,
      select: { id: true, name: true, email: true, createdAt: true },
    }),
    db.user.count(),
  ])

  return NextResponse.json({
    data: users,
    meta: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
    },
  })
}

export async function POST(request: NextRequest) {
  const body = await request.json()
  const result = CreateUserSchema.safeParse(body)

  if (!result.success) {
    return NextResponse.json(
      { errors: result.error.flatten().fieldErrors },
      { status: 400 }
    )
  }

  const existing = await db.user.findUnique({
    where: { email: result.data.email },
  })

  if (existing) {
    return NextResponse.json({ error: 'Email already exists' }, { status: 409 })
  }

  const user = await db.user.create({
    data: result.data,
  })

  return NextResponse.json(user, { status: 201 })
}
```

```tsx
// app/api/v1/users/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { db } from '@/lib/db'

const UpdateUserSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  email: z.string().email().optional(),
})

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const user = await db.user.findUnique({
    where: { id },
    select: { id: true, name: true, email: true, createdAt: true },
  })

  if (!user) {
    return NextResponse.json({ error: 'User not found' }, { status: 404 })
  }

  return NextResponse.json(user)
}

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const body = await request.json()
  const result = UpdateUserSchema.safeParse(body)

  if (!result.success) {
    return NextResponse.json(
      { errors: result.error.flatten().fieldErrors },
      { status: 400 }
    )
  }

  try {
    const user = await db.user.update({
      where: { id },
      data: result.data,
    })
    return NextResponse.json(user)
  } catch {
    return NextResponse.json({ error: 'User not found' }, { status: 404 })
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params

  try {
    await db.user.delete({ where: { id } })
    return new NextResponse(null, { status: 204 })
  } catch {
    return NextResponse.json({ error: 'User not found' }, { status: 404 })
  }
}
```

## å¸¸è§é—®é¢˜

ğŸ¤” **Q: Route Handlers å’Œ Server Actions æ€ä¹ˆé€‰ï¼Ÿ**

- Route Handlersï¼šåˆ›å»º REST APIã€å¤„ç† Webhookã€ç¬¬ä¸‰æ–¹é›†æˆ
- Server Actionsï¼šè¡¨å•å¤„ç†ã€æ•°æ®å˜æ›´ã€ä¸ UI ç´§å¯†ç»“åˆ

ğŸ¤” **Q: å¦‚ä½•å¤„ç†è·¨åŸŸè¯·æ±‚ï¼Ÿ**

```tsx
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const response = NextResponse.next()

  if (request.nextUrl.pathname.startsWith('/api/')) {
    response.headers.set('Access-Control-Allow-Origin', '*')
    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
  }

  return response
}
```

ğŸ¤” **Q: å¦‚ä½•é™åˆ¶è¯·æ±‚é¢‘ç‡ï¼Ÿ**

ä½¿ç”¨ä¸­é—´ä»¶æˆ–ç¬¬ä¸‰æ–¹åº“å¦‚ `@upstash/ratelimit` å®ç°é€Ÿç‡é™åˆ¶ã€‚

---

ä¸‹ä¸€ç¯‡å°†ä»‹ç»æ•°æ®åº“é›†æˆï¼Œå­¦ä¹ å¦‚ä½•åœ¨ Next.js ä¸­ä½¿ç”¨ Prisma å’Œ Drizzleã€‚

-EOF-
