---
title: NextAuth é›†æˆ
description: ä½¿ç”¨ Auth.js (NextAuth) å¿«é€Ÿå®ç°å¤šç§ç™»å½•æ–¹å¼ï¼ŒåŒ…æ‹¬ OAuthã€é‚®ç®±ç™»å½•å’Œå‡­è¯ç™»å½•
pubDate: 2025-12-03
toc: true
ogImage: true
category: Next
tags: ['Next.js', 'NextAuth', 'Auth.js', 'OAuth', 'è®¤è¯']
---

ğŸ™‹ éœ€è¦æ”¯æŒ GitHubã€Google ç™»å½•ï¼ŸAuth.jsï¼ˆåŸ NextAuthï¼‰è®©è®¤è¯å˜å¾—ç®€å•ã€‚

## å®‰è£…é…ç½®

```bash
pnpm add next-auth@beta
```

ğŸ”¶ **æ³¨æ„**ï¼šNext.js 15 éœ€è¦ä½¿ç”¨ Auth.js v5 (beta)ã€‚

## åŸºç¡€é…ç½®

### åˆ›å»ºé…ç½®æ–‡ä»¶

```tsx
// auth.ts
import NextAuth from 'next-auth'
import GitHub from 'next-auth/providers/github'
import Google from 'next-auth/providers/google'

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    GitHub({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!,
    }),
    Google({
      clientId: process.env.GOOGLE_ID!,
      clientSecret: process.env.GOOGLE_SECRET!,
    }),
  ],
})
```

### ç¯å¢ƒå˜é‡

```bash
# .env.local
AUTH_SECRET="your-auth-secret" # openssl rand -base64 32

# GitHub OAuth
GITHUB_ID="your-github-client-id"
GITHUB_SECRET="your-github-client-secret"

# Google OAuth
GOOGLE_ID="your-google-client-id"
GOOGLE_SECRET="your-google-client-secret"
```

### API è·¯ç”±

```tsx
// app/api/auth/[...nextauth]/route.ts
import { handlers } from '@/auth'

export const { GET, POST } = handlers
```

## OAuth æä¾›è€…

### GitHub

```tsx
// auth.ts
import GitHub from 'next-auth/providers/github'

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    GitHub({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!,
      // è‡ªå®šä¹‰æˆæƒèŒƒå›´
      authorization: {
        params: {
          scope: 'read:user user:email',
        },
      },
    }),
  ],
})
```

### Google

```tsx
import Google from 'next-auth/providers/google'

Google({
  clientId: process.env.GOOGLE_ID!,
  clientSecret: process.env.GOOGLE_SECRET!,
  authorization: {
    params: {
      prompt: 'consent',
      access_type: 'offline',
      response_type: 'code',
    },
  },
})
```

### å¾®ä¿¡ï¼ˆéœ€è¦è‡ªå®šä¹‰ï¼‰

```tsx
// lib/wechat-provider.ts
import type { OAuthConfig } from 'next-auth/providers'

export function Wechat(): OAuthConfig<any> {
  return {
    id: 'wechat',
    name: 'å¾®ä¿¡',
    type: 'oauth',
    authorization: {
      url: 'https://open.weixin.qq.com/connect/qrconnect',
      params: {
        appid: process.env.WECHAT_APP_ID,
        scope: 'snsapi_login',
      },
    },
    token: 'https://api.weixin.qq.com/sns/oauth2/access_token',
    userinfo: 'https://api.weixin.qq.com/sns/userinfo',
    profile(profile) {
      return {
        id: profile.unionid || profile.openid,
        name: profile.nickname,
        image: profile.headimgurl,
      }
    },
    clientId: process.env.WECHAT_APP_ID,
    clientSecret: process.env.WECHAT_APP_SECRET,
  }
}
```

## å‡­è¯ç™»å½•

### é…ç½®

```tsx
// auth.ts
import NextAuth from 'next-auth'
import Credentials from 'next-auth/providers/credentials'
import { compare } from 'bcryptjs'
import { db } from '@/lib/db'

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    Credentials({
      name: 'credentials',
      credentials: {
        email: { label: 'é‚®ç®±', type: 'email' },
        password: { label: 'å¯†ç ', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null
        }

        const user = await db.user.findUnique({
          where: { email: credentials.email as string },
        })

        if (!user || !user.password) {
          return null
        }

        const isValid = await compare(
          credentials.password as string,
          user.password
        )

        if (!isValid) {
          return null
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          image: user.image,
        }
      },
    }),
  ],
  pages: {
    signIn: '/login',
  },
})
```

### ç™»å½•è¡¨å•

```tsx
// components/LoginForm.tsx
'use client'

import { signIn } from 'next-auth/react'
import { useState } from 'react'
import { useRouter } from 'next/navigation'

export function LoginForm() {
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)
  const router = useRouter()

  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault()
    setLoading(true)
    setError('')

    const formData = new FormData(e.currentTarget)

    const result = await signIn('credentials', {
      email: formData.get('email'),
      password: formData.get('password'),
      redirect: false,
    })

    setLoading(false)

    if (result?.error) {
      setError('é‚®ç®±æˆ–å¯†ç é”™è¯¯')
    } else {
      router.push('/dashboard')
      router.refresh()
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <input
          name="email"
          type="email"
          placeholder="é‚®ç®±"
          required
          className="w-full border rounded px-3 py-2"
        />
      </div>
      <div>
        <input
          name="password"
          type="password"
          placeholder="å¯†ç "
          required
          className="w-full border rounded px-3 py-2"
        />
      </div>

      {error && <p className="text-red-500">{error}</p>}

      <button
        type="submit"
        disabled={loading}
        className="w-full bg-blue-600 text-white py-2 rounded"
      >
        {loading ? 'ç™»å½•ä¸­...' : 'ç™»å½•'}
      </button>
    </form>
  )
}
```

## æ•°æ®åº“é€‚é…å™¨

### Prisma é€‚é…å™¨

```bash
pnpm add @auth/prisma-adapter
```

```tsx
// auth.ts
import NextAuth from 'next-auth'
import { PrismaAdapter } from '@auth/prisma-adapter'
import { prisma } from '@/lib/prisma'
import GitHub from 'next-auth/providers/github'

export const { handlers, auth, signIn, signOut } = NextAuth({
  adapter: PrismaAdapter(prisma),
  providers: [
    GitHub({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!,
    }),
  ],
  session: {
    strategy: 'database', // ä½¿ç”¨æ•°æ®åº“å­˜å‚¨ session
  },
})
```

### Prisma Schema

```prisma
// prisma/schema.prisma

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
```

## è·å–ä¼šè¯

### æœåŠ¡ç«¯

```tsx
// app/dashboard/page.tsx
import { auth } from '@/auth'
import { redirect } from 'next/navigation'

export default async function DashboardPage() {
  const session = await auth()

  if (!session) {
    redirect('/login')
  }

  return (
    <div>
      <h1>æ¬¢è¿ï¼Œ{session.user?.name}</h1>
      <img src={session.user?.image || ''} alt="å¤´åƒ" />
    </div>
  )
}
```

### å®¢æˆ·ç«¯

```tsx
// components/UserMenu.tsx
'use client'

import { useSession, signOut } from 'next-auth/react'

export function UserMenu() {
  const { data: session, status } = useSession()

  if (status === 'loading') {
    return <div>åŠ è½½ä¸­...</div>
  }

  if (!session) {
    return <a href="/login">ç™»å½•</a>
  }

  return (
    <div className="flex items-center gap-4">
      <img
        src={session.user?.image || ''}
        alt="å¤´åƒ"
        className="w-8 h-8 rounded-full"
      />
      <span>{session.user?.name}</span>
      <button onClick={() => signOut()}>é€€å‡º</button>
    </div>
  )
}
```

### SessionProvider

```tsx
// app/providers.tsx
'use client'

import { SessionProvider } from 'next-auth/react'

export function Providers({ children }: { children: React.ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>
}
```

```tsx
// app/layout.tsx
import { Providers } from './providers'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="zh-CN">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  )
}
```

## å›è°ƒé…ç½®

### è‡ªå®šä¹‰ JWT

```tsx
// auth.ts
export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [...],
  callbacks: {
    async jwt({ token, user, account }) {
      // é¦–æ¬¡ç™»å½•æ—¶æ·»åŠ ç”¨æˆ·ä¿¡æ¯
      if (user) {
        token.id = user.id
        token.role = user.role
      }

      // æ·»åŠ  OAuth è®¿é—®ä»¤ç‰Œ
      if (account) {
        token.accessToken = account.access_token
      }

      return token
    },
    async session({ session, token }) {
      // å°† token ä¿¡æ¯æ·»åŠ åˆ° session
      session.user.id = token.id as string
      session.user.role = token.role as string
      session.accessToken = token.accessToken as string

      return session
    },
  },
})
```

### ç±»å‹æ‰©å±•

```tsx
// types/next-auth.d.ts
import { DefaultSession } from 'next-auth'

declare module 'next-auth' {
  interface Session {
    user: {
      id: string
      role: string
    } & DefaultSession['user']
    accessToken?: string
  }

  interface User {
    role?: string
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    id: string
    role: string
    accessToken?: string
  }
}
```

### ç™»å½•å›è°ƒ

```tsx
callbacks: {
  async signIn({ user, account, profile }) {
    // é™åˆ¶ç‰¹å®šåŸŸåé‚®ç®±
    if (account?.provider === 'google') {
      return profile?.email?.endsWith('@company.com') ?? false
    }

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¢«ç¦ç”¨
    const dbUser = await db.user.findUnique({
      where: { email: user.email! },
    })

    if (dbUser?.banned) {
      return false
    }

    return true
  },
}
```

## ä¸­é—´ä»¶ä¿æŠ¤

```tsx
// middleware.ts
import { auth } from '@/auth'

export default auth((req) => {
  const isLoggedIn = !!req.auth
  const isAuthPage = req.nextUrl.pathname.startsWith('/login')
  const isProtected = req.nextUrl.pathname.startsWith('/dashboard')

  if (isProtected && !isLoggedIn) {
    return Response.redirect(new URL('/login', req.url))
  }

  if (isAuthPage && isLoggedIn) {
    return Response.redirect(new URL('/dashboard', req.url))
  }
})

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
}
```

## è‡ªå®šä¹‰ç™»å½•é¡µ

```tsx
// app/login/page.tsx
import { signIn } from '@/auth'

export default function LoginPage() {
  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="max-w-md w-full space-y-8 p-8">
        <h1 className="text-2xl font-bold text-center">ç™»å½•</h1>

        {/* OAuth ç™»å½• */}
        <div className="space-y-4">
          <form
            action={async () => {
              'use server'
              await signIn('github', { redirectTo: '/dashboard' })
            }}
          >
            <button
              type="submit"
              className="w-full flex items-center justify-center gap-2 border rounded py-2"
            >
              <GitHubIcon />
              ä½¿ç”¨ GitHub ç™»å½•
            </button>
          </form>

          <form
            action={async () => {
              'use server'
              await signIn('google', { redirectTo: '/dashboard' })
            }}
          >
            <button
              type="submit"
              className="w-full flex items-center justify-center gap-2 border rounded py-2"
            >
              <GoogleIcon />
              ä½¿ç”¨ Google ç™»å½•
            </button>
          </form>
        </div>

        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t" />
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">æˆ–</span>
          </div>
        </div>

        {/* å‡­è¯ç™»å½•è¡¨å• */}
        <CredentialsForm />
      </div>
    </div>
  )
}
```

## é€€å‡ºç™»å½•

```tsx
// æœåŠ¡ç«¯ Action
import { signOut } from '@/auth'

export default function LogoutButton() {
  return (
    <form
      action={async () => {
        'use server'
        await signOut({ redirectTo: '/' })
      }}
    >
      <button type="submit">é€€å‡ºç™»å½•</button>
    </form>
  )
}

// å®¢æˆ·ç«¯
;('use client')
import { signOut } from 'next-auth/react'

export function ClientLogoutButton() {
  return <button onClick={() => signOut({ callbackUrl: '/' })}>é€€å‡ºç™»å½•</button>
}
```

## å¸¸è§é—®é¢˜

ğŸ¤” **Q: OAuth å›è°ƒåœ°å€æ€ä¹ˆé…ç½®ï¼Ÿ**

åœ¨ OAuth æä¾›å•†åå°é…ç½®ï¼š

```
å¼€å‘ç¯å¢ƒ: http://localhost:3000/api/auth/callback/github
ç”Ÿäº§ç¯å¢ƒ: https://yourdomain.com/api/auth/callback/github
```

ğŸ¤” **Q: å¦‚ä½•åŒæ—¶æ”¯æŒ JWT å’Œæ•°æ®åº“ Sessionï¼Ÿ**

```tsx
session: {
  strategy: 'jwt', // æˆ– 'database'
}
```

JWT æ›´é€‚åˆ serverlessï¼Œæ•°æ®åº“ Session æ›´æ˜“ç®¡ç†ã€‚

ğŸ¤” **Q: å¦‚ä½•åˆ·æ–° OAuth Access Tokenï¼Ÿ**

ä½¿ç”¨ `@auth/core` çš„ rotation åŠŸèƒ½æˆ–åœ¨ jwt å›è°ƒä¸­å¤„ç†ã€‚

---

ä¸‹ä¸€ç¯‡å°†ä»‹ç»ç¯å¢ƒå˜é‡ä¸é…ç½®ï¼Œå­¦ä¹ å¦‚ä½•å®‰å…¨ç®¡ç†åº”ç”¨é…ç½®ã€‚

-EOF-
