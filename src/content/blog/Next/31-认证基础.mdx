---
title: è®¤è¯åŸºç¡€
description: ç†è§£ Next.js åº”ç”¨çš„è®¤è¯æœºåˆ¶ï¼ŒæŒæ¡ Sessionã€JWT å’Œ Cookie çš„ä½¿ç”¨
pubDate: 2025-12-03
toc: true
ogImage: true
category: Next
tags: ['Next.js', 'è®¤è¯', 'Session', 'JWT', 'Cookie']
---

ğŸ™‹ ç”¨æˆ·ç™»å½•åå¦‚ä½•ä¿æŒçŠ¶æ€ï¼Ÿå¦‚ä½•ä¿æŠ¤éœ€è¦ç™»å½•æ‰èƒ½è®¿é—®çš„é¡µé¢ï¼Ÿ

## è®¤è¯æ–¹å¼å¯¹æ¯”

| æ–¹å¼    | ä¼˜ç‚¹               | ç¼ºç‚¹             | é€‚ç”¨åœºæ™¯            |
| ------- | ------------------ | ---------------- | ------------------- |
| Session | å®‰å…¨ã€å¯æ’¤é”€       | éœ€è¦å­˜å‚¨ã€éš¾æ‰©å±• | ä¼ ç»Ÿåº”ç”¨            |
| JWT     | æ— çŠ¶æ€ã€æ˜“æ‰©å±•     | éš¾æ’¤é”€ã€ä½“ç§¯å¤§   | APIã€å¾®æœåŠ¡         |
| Cookie  | è‡ªåŠ¨å‘é€ã€HttpOnly | å¤§å°é™åˆ¶         | ä¸ Session/JWT é…åˆ |

## Cookie åŸºç¡€

### è®¾ç½® Cookie

```tsx
// app/api/login/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function POST(request: NextRequest) {
  const { email, password } = await request.json()

  // éªŒè¯ç”¨æˆ·...
  const user = await authenticateUser(email, password)

  if (!user) {
    return NextResponse.json({ error: 'ç™»å½•å¤±è´¥' }, { status: 401 })
  }

  // è®¾ç½® Cookie
  const cookieStore = await cookies()
  cookieStore.set('session', user.sessionId, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 24 * 7, // 7 å¤©
    path: '/',
  })

  return NextResponse.json({ user: { id: user.id, name: user.name } })
}
```

### è¯»å– Cookie

```tsx
// app/api/me/route.ts
import { NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function GET() {
  const cookieStore = await cookies()
  const session = cookieStore.get('session')

  if (!session) {
    return NextResponse.json({ error: 'æœªç™»å½•' }, { status: 401 })
  }

  const user = await getUserBySession(session.value)

  if (!user) {
    return NextResponse.json({ error: 'ä¼šè¯æ— æ•ˆ' }, { status: 401 })
  }

  return NextResponse.json({ user })
}
```

### åˆ é™¤ Cookie

```tsx
// app/api/logout/route.ts
import { NextResponse } from 'next/server'
import { cookies } from 'next/headers'

export async function POST() {
  const cookieStore = await cookies()
  cookieStore.delete('session')

  return NextResponse.json({ success: true })
}
```

## Session è®¤è¯

### åˆ›å»º Session

```tsx
// lib/session.ts
import { cookies } from 'next/headers'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = new TextEncoder().encode(process.env.SESSION_SECRET!)

interface SessionPayload {
  userId: string
  expiresAt: Date
}

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 å¤©

  const session = await new SignJWT({ userId, expiresAt })
    .setProtectedHeader({ alg: 'HS256' })
    .setExpirationTime('7d')
    .sign(secretKey)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    expires: expiresAt,
    path: '/',
  })
}

export async function verifySession(): Promise<SessionPayload | null> {
  const cookieStore = await cookies()
  const session = cookieStore.get('session')?.value

  if (!session) return null

  try {
    const { payload } = await jwtVerify(session, secretKey)
    return payload as SessionPayload
  } catch {
    return null
  }
}

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

### ç™»å½•æµç¨‹

```tsx
// app/actions/auth.ts
'use server'

import { z } from 'zod'
import { createSession, deleteSession } from '@/lib/session'
import { redirect } from 'next/navigation'
import { hash, compare } from 'bcryptjs'

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
})

export async function login(prevState: any, formData: FormData) {
  const result = loginSchema.safeParse({
    email: formData.get('email'),
    password: formData.get('password'),
  })

  if (!result.success) {
    return { error: 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±å’Œå¯†ç ' }
  }

  const { email, password } = result.data

  const user = await db.user.findUnique({ where: { email } })

  if (!user || !(await compare(password, user.password))) {
    return { error: 'é‚®ç®±æˆ–å¯†ç é”™è¯¯' }
  }

  await createSession(user.id)
  redirect('/dashboard')
}

export async function logout() {
  await deleteSession()
  redirect('/login')
}

export async function register(prevState: any, formData: FormData) {
  const email = formData.get('email') as string
  const password = formData.get('password') as string
  const name = formData.get('name') as string

  const hashedPassword = await hash(password, 12)

  try {
    const user = await db.user.create({
      data: { email, password: hashedPassword, name },
    })

    await createSession(user.id)
    redirect('/dashboard')
  } catch {
    return { error: 'æ³¨å†Œå¤±è´¥ï¼Œé‚®ç®±å¯èƒ½å·²è¢«ä½¿ç”¨' }
  }
}
```

## JWT è®¤è¯

### ç”Ÿæˆ Token

```tsx
// lib/jwt.ts
import { SignJWT, jwtVerify } from 'jose'

const secretKey = new TextEncoder().encode(process.env.JWT_SECRET!)

interface TokenPayload {
  userId: string
  email: string
}

export async function generateToken(payload: TokenPayload): Promise<string> {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('1h')
    .sign(secretKey)
}

export async function generateRefreshToken(userId: string): Promise<string> {
  return new SignJWT({ userId })
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(secretKey)
}

export async function verifyToken(token: string): Promise<TokenPayload | null> {
  try {
    const { payload } = await jwtVerify(token, secretKey)
    return payload as TokenPayload
  } catch {
    return null
  }
}
```

### Token åˆ·æ–°

```tsx
// app/api/auth/refresh/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'
import { verifyToken, generateToken, generateRefreshToken } from '@/lib/jwt'

export async function POST(request: NextRequest) {
  const cookieStore = await cookies()
  const refreshToken = cookieStore.get('refreshToken')?.value

  if (!refreshToken) {
    return NextResponse.json({ error: 'No refresh token' }, { status: 401 })
  }

  const payload = await verifyToken(refreshToken)

  if (!payload) {
    return NextResponse.json(
      { error: 'Invalid refresh token' },
      { status: 401 }
    )
  }

  const user = await db.user.findUnique({ where: { id: payload.userId } })

  if (!user) {
    return NextResponse.json({ error: 'User not found' }, { status: 401 })
  }

  // ç”Ÿæˆæ–° token
  const accessToken = await generateToken({
    userId: user.id,
    email: user.email,
  })
  const newRefreshToken = await generateRefreshToken(user.id)

  // æ›´æ–° refresh token cookie
  cookieStore.set('refreshToken', newRefreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 24 * 7,
    path: '/',
  })

  return NextResponse.json({ accessToken })
}
```

## è·¯ç”±ä¿æŠ¤

### ä¸­é—´ä»¶ä¿æŠ¤

```tsx
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { verifySession } from '@/lib/session'

// éœ€è¦ç™»å½•çš„è·¯ç”±
const protectedRoutes = ['/dashboard', '/settings', '/profile']
// ç™»å½•åä¸èƒ½è®¿é—®çš„è·¯ç”±
const authRoutes = ['/login', '/register']

export async function middleware(request: NextRequest) {
  const path = request.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.some((route) =>
    path.startsWith(route)
  )
  const isAuthRoute = authRoutes.some((route) => path.startsWith(route))

  const session = await verifySession()

  // æœªç™»å½•è®¿é—®å—ä¿æŠ¤è·¯ç”±
  if (isProtectedRoute && !session) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // å·²ç™»å½•è®¿é—®ç™»å½•é¡µ
  if (isAuthRoute && session) {
    return NextResponse.redirect(new URL('/dashboard', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
}
```

### æœåŠ¡ç«¯ç»„ä»¶ä¿æŠ¤

```tsx
// app/dashboard/page.tsx
import { redirect } from 'next/navigation'
import { verifySession } from '@/lib/session'

export default async function DashboardPage() {
  const session = await verifySession()

  if (!session) {
    redirect('/login')
  }

  const user = await db.user.findUnique({
    where: { id: session.userId },
  })

  return (
    <div>
      <h1>æ¬¢è¿ï¼Œ{user?.name}</h1>
    </div>
  )
}
```

### å°è£…è®¤è¯æ£€æŸ¥

```tsx
// lib/auth.ts
import { verifySession } from './session'
import { redirect } from 'next/navigation'
import { cache } from 'react'

export const getUser = cache(async () => {
  const session = await verifySession()

  if (!session) {
    return null
  }

  return db.user.findUnique({
    where: { id: session.userId },
    select: {
      id: true,
      name: true,
      email: true,
      role: true,
    },
  })
})

export async function requireAuth() {
  const user = await getUser()

  if (!user) {
    redirect('/login')
  }

  return user
}

export async function requireAdmin() {
  const user = await requireAuth()

  if (user.role !== 'ADMIN') {
    redirect('/unauthorized')
  }

  return user
}
```

ä½¿ç”¨ï¼š

```tsx
// app/admin/page.tsx
import { requireAdmin } from '@/lib/auth'

export default async function AdminPage() {
  const admin = await requireAdmin()

  return <div>ç®¡ç†å‘˜é¡µé¢ï¼Œ{admin.name}</div>
}
```

## å®¢æˆ·ç«¯è®¤è¯çŠ¶æ€

### Context Provider

```tsx
// context/auth.tsx
'use client'

import {
  createContext,
  useContext,
  useState,
  useEffect,
  ReactNode,
} from 'react'

interface User {
  id: string
  name: string
  email: string
}

interface AuthContextType {
  user: User | null
  loading: boolean
  login: (email: string, password: string) => Promise<void>
  logout: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | null>(null)

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    checkAuth()
  }, [])

  async function checkAuth() {
    try {
      const res = await fetch('/api/me')
      if (res.ok) {
        const data = await res.json()
        setUser(data.user)
      }
    } catch {
      setUser(null)
    } finally {
      setLoading(false)
    }
  }

  async function login(email: string, password: string) {
    const res = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (!res.ok) {
      throw new Error('ç™»å½•å¤±è´¥')
    }

    const data = await res.json()
    setUser(data.user)
  }

  async function logout() {
    await fetch('/api/logout', { method: 'POST' })
    setUser(null)
  }

  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}
```

### ä½¿ç”¨ Hook

```tsx
// components/Header.tsx
'use client'

import { useAuth } from '@/context/auth'
import Link from 'next/link'

export function Header() {
  const { user, loading, logout } = useAuth()

  if (loading) {
    return <div>åŠ è½½ä¸­...</div>
  }

  return (
    <header className="flex justify-between items-center p-4">
      <Link href="/">Logo</Link>

      <nav>
        {user ? (
          <div className="flex items-center gap-4">
            <span>æ¬¢è¿ï¼Œ{user.name}</span>
            <button onClick={logout}>é€€å‡º</button>
          </div>
        ) : (
          <div className="flex gap-4">
            <Link href="/login">ç™»å½•</Link>
            <Link href="/register">æ³¨å†Œ</Link>
          </div>
        )}
      </nav>
    </header>
  )
}
```

## ç™»å½•è¡¨å•

```tsx
// components/LoginForm.tsx
'use client'

import { useActionState } from 'react'
import { login } from '@/app/actions/auth'

export function LoginForm() {
  const [state, formAction, isPending] = useActionState(login, null)

  return (
    <form action={formAction} className="space-y-4 max-w-md">
      <div>
        <label htmlFor="email" className="block font-medium">
          é‚®ç®±
        </label>
        <input
          id="email"
          name="email"
          type="email"
          required
          className="w-full border rounded px-3 py-2"
        />
      </div>

      <div>
        <label htmlFor="password" className="block font-medium">
          å¯†ç 
        </label>
        <input
          id="password"
          name="password"
          type="password"
          required
          className="w-full border rounded px-3 py-2"
        />
      </div>

      {state?.error && <p className="text-red-500">{state.error}</p>}

      <button
        type="submit"
        disabled={isPending}
        className="w-full bg-blue-600 text-white py-2 rounded disabled:opacity-50"
      >
        {isPending ? 'ç™»å½•ä¸­...' : 'ç™»å½•'}
      </button>
    </form>
  )
}
```

## å¸¸è§é—®é¢˜

ğŸ¤” **Q: Session è¿˜æ˜¯ JWTï¼Ÿ**

- ä¼ ç»Ÿ Web åº”ç”¨ï¼šSession + Cookie
- API æœåŠ¡/å¾®æœåŠ¡ï¼šJWT
- æ··åˆåº”ç”¨ï¼šå¯ä»¥ä¸¤è€…ç»“åˆä½¿ç”¨

ğŸ¤” **Q: å¦‚ä½•å®‰å…¨å­˜å‚¨å¯†ç ï¼Ÿ**

ä½¿ç”¨ bcrypt æˆ– argon2 å“ˆå¸Œï¼š

```tsx
import { hash, compare } from 'bcryptjs'

const hashedPassword = await hash(password, 12)
const isValid = await compare(password, hashedPassword)
```

ğŸ¤” **Q: Cookie è®¾ç½®æœ€ä½³å®è·µï¼Ÿ**

```tsx
cookieStore.set('session', value, {
  httpOnly: true, // é˜²æ­¢ XSS
  secure: true, // ä»… HTTPS
  sameSite: 'lax', // é˜²æ­¢ CSRF
  maxAge: 60 * 60 * 24 * 7,
  path: '/',
})
```

---

ä¸‹ä¸€ç¯‡å°†ä»‹ç» NextAuth é›†æˆï¼Œå­¦ä¹ å¦‚ä½•å¿«é€Ÿå®ç°å¤šç§ç™»å½•æ–¹å¼ã€‚

-EOF-
