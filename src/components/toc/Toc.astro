---
import TocButton from '~/components/toc/TocButton.astro'
import TocItem from '~/components/toc/TocItem.astro'
import { generateToc } from '~/utils/toc'
import { FEATURES } from '~/config'

import type { MarkdownHeading } from 'astro'
import type { TocConfig } from '~/types'

type Props =
  | {
      headings: MarkdownHeading[]
      anchors?: never
      style?: string
    }
  | {
      anchors: string[]
      headings?: never
      style?: string
    }

const { headings = [], anchors = [], style } = Astro.props

const getTocConfig = () => {
  const defaultConfig: TocConfig = {
    minHeadingLevel: 2,
    maxHeadingLevel: 4,
    displayPosition: 'left',
    displayMode: 'hover',
  }

  if (!Array.isArray(FEATURES.toc) || !FEATURES.toc[0]) {
    return defaultConfig
  }

  return { ...defaultConfig, ...FEATURES.toc[1] }
}

const isArticle = !!headings.length
const { minHeadingLevel, maxHeadingLevel, displayPosition, displayMode } =
  getTocConfig()
const specHeadings = generateToc(headings, minHeadingLevel, maxHeadingLevel)
---

<aside>
  <table-of-contents
    data-min-h={isArticle ? minHeadingLevel : undefined}
    data-max-h={isArticle ? maxHeadingLevel : undefined}
  >
    <!-- Greater than or equal to 1128px -->
    <nav
      class:list={{
        'toc-desktop': true,
        'toc-desktop-on': displayMode === 'always',
        'toc-desktop-content': displayMode === 'content',
        'toc-desktop-right': displayPosition === 'right',
      }}
      {style}
    >
      <div class="toc-search-box">
        <button type="button" class="toc-search-trigger" aria-label="搜索">
          <span class="i-ri-search-line"></span>
        </button>
        <input
          type="text"
          class="toc-search-input"
          placeholder="搜索目录..."
          autocomplete="off"
        />
        <button
          type="button"
          class="toc-search-clear hidden"
          aria-label="清除搜索"
        >
          <span class="i-ri-close-line"></span>
        </button>
      </div>
      <div class="toc-desktop-anchor i-ri-menu-2-fill"></div>
      <ul>
        {
          !!specHeadings.length &&
            specHeadings.map((heading) => <TocItem {heading} />)
        }
        {!!anchors.length && <TocItem {anchors} />}
      </ul>
    </nav>
    <!-- less than 1128px -->
    <TocButton>
      {
        !!specHeadings.length &&
          specHeadings.map((heading) => <TocItem {heading} />)
      }
      {!!anchors.length && <TocItem {anchors} />}
    </TocButton>
  </table-of-contents>
</aside>

<script>
  class Toc extends HTMLElement {
    #minH: number | undefined
    #maxH: number | undefined
    #observer: IntersectionObserver | null = null
    #headingMapToc = new Map<Element, HTMLAnchorElement[]>()

    #currentActiveHeading: Element | null = null
    #previousActiveLinks: HTMLAnchorElement[] = []

    #searchTimeout: ReturnType<typeof setTimeout> | null = null
    readonly #DEBOUNCE_DELAY = 300

    connectedCallback() {
      this.#onIdle(() => this.#init())
    }

    disconnectedCallback() {
      this.#cleanup()
    }

    #init = () => {
      this.#minH = this.#getHeadingLevel(this.dataset.minH)
      this.#maxH = this.#getHeadingLevel(this.dataset.maxH)

      // 设置搜索功能
      this.#setupSearch()

      // map heading elements to their corresponding toc links
      const tocLinks = this.#getElements('a', false) as HTMLAnchorElement[]
      this.#generateHeadingMapToc(tocLinks)

      // get all belonging heading elements on the page
      const headings =
        this.#minH && this.#maxH
          ? this.#getElements(
              this.#getTocHeadingsSelector(this.#minH, this.#maxH)
            )
          : this.#getElements('.toc-heading')

      // observe heading elements to trigger highlight change
      this.#observer = new IntersectionObserver(this.#onIntersect, {
        root: null,
        rootMargin: '0% 0% -75% 0%',
        threshold: 0,
      })

      for (const headingEl of headings) {
        this.#observer.observe(headingEl)
      }
    }

    #onIdle = (cb: IdleRequestCallback) =>
      (window.requestIdleCallback || ((cb) => setTimeout(cb, 1)))(cb)

    #onIntersect = (entries: IntersectionObserverEntry[]) => {
      if (!entries.length) return

      // get latest trigger heading element
      let latest = entries[0]
      for (let i = 1; i < entries.length; i++) {
        if (entries[i].time > latest.time) latest = entries[i]
      }
      const latestTriggerHeading = latest.target
      if (!latestTriggerHeading) return

      // get need to highlight heading element
      // (if current heading is located below 1/4 of the viewport,
      // highlight previous heading)
      // (avoid highlight next heading when scrolling up)
      const isLocatedBelow =
        latest.boundingClientRect.top > window.innerHeight / 4
      const targetHeading = isLocatedBelow
        ? this.#getPreviousHeading(this.#headingMapToc, latestTriggerHeading)
        : latestTriggerHeading

      // if target heading is not changed, return
      if (!targetHeading || targetHeading === this.#currentActiveHeading) return

      // diff update aria-current
      const newLinks = this.#headingMapToc.get(targetHeading) ?? []

      if (this.#previousActiveLinks && this.#previousActiveLinks.length) {
        for (const tocLinkEl of this.#previousActiveLinks) {
          tocLinkEl.removeAttribute('aria-current')
        }
      }
      for (const tocLinkEl of newLinks) {
        tocLinkEl.setAttribute('aria-current', 'true')

        // when toc is too long, scroll active toc link into viewport
        tocLinkEl.scrollIntoView({ behavior: 'smooth', block: 'center' })
      }

      this.#currentActiveHeading = targetHeading
      this.#previousActiveLinks = newLinks
    }

    #getHeadingLevel = (level: string | undefined) => {
      return level ? parseInt(level, 10) : undefined
    }

    #getElements = (selector: string, fromDocument = true) => {
      return fromDocument
        ? Array.from(document.querySelectorAll(selector))
        : Array.from(this.querySelectorAll(selector))
    }

    #generateHeadingMapToc = (tocLinks: HTMLAnchorElement[]) => {
      for (const link of tocLinks) {
        const { hash } = new URL(link.href)
        const id = decodeURIComponent(hash.replace(/^#/, ''))
        const headingEl = document.getElementById(id)

        if (headingEl) {
          if (this.#headingMapToc.has(headingEl)) {
            this.#headingMapToc.get(headingEl)?.push(link)
          } else {
            this.#headingMapToc.set(headingEl, [link])
          }
        }
      }
    }

    // returns a CSS selector string for the specified heading levels
    #getTocHeadingsSelector = (
      minH: number,
      maxH: number,
      baseSelector = ''
    ) => {
      const levelSelectors = []
      for (let i = minH; i <= maxH; i++) {
        baseSelector
          ? levelSelectors.push(`${baseSelector} h${i}`)
          : levelSelectors.push(`h${i}`)
      }

      return levelSelectors.join(', ')
    }

    #getPreviousHeading = (
      headingMapToc: Map<Element, HTMLAnchorElement[]>,
      curHeading: Element
    ) => {
      let prevHeading = null

      for (const h of headingMapToc.keys()) {
        if (h === curHeading) return prevHeading
        prevHeading = h
      }

      return null
    }

    #cleanup = () => {
      this.#observer?.disconnect()
      this.#observer = null
      this.#headingMapToc.clear()
      this.#currentActiveHeading = null
      this.#previousActiveLinks = []
      if (this.#searchTimeout) {
        clearTimeout(this.#searchTimeout)
        this.#searchTimeout = null
      }
    }

    // 防抖函数
    #debounce = (fn: () => void) => {
      if (this.#searchTimeout) {
        clearTimeout(this.#searchTimeout)
      }
      this.#searchTimeout = setTimeout(fn, this.#DEBOUNCE_DELAY)
    }

    #setupSearch = () => {
      const searchBox = this.querySelector('.toc-search-box')
      const searchTrigger = this.querySelector('.toc-search-trigger')
      const searchInput = this.querySelector(
        '.toc-search-input'
      ) as HTMLInputElement
      const clearBtn = this.querySelector('.toc-search-clear')

      if (!searchInput) return

      const expand = () => {
        searchBox?.classList.add('expanded')
        setTimeout(() => searchInput.focus(), 50)
      }

      const collapse = () => {
        if (!searchInput.value) {
          searchBox?.classList.remove('expanded')
        }
      }

      searchTrigger?.addEventListener('click', (e) => {
        e.stopPropagation()
        expand()
      })

      searchInput.addEventListener('focus', () => {
        searchBox?.classList.add('expanded')
      })

      searchInput.addEventListener('blur', () => {
        setTimeout(collapse, 150)
      })

      searchInput.addEventListener('input', () => {
        this.#debounce(() => {
          this.#filterToc(searchInput.value.trim())
        })
        clearBtn?.classList.toggle('hidden', !searchInput.value)
      })

      clearBtn?.addEventListener('click', (e) => {
        e.stopPropagation()
        searchInput.value = ''
        clearBtn.classList.add('hidden')
        this.#filterToc('')
        searchBox?.classList.remove('expanded')
      })
    }

    #filterToc = (keyword: string) => {
      const lowerKeyword = keyword.toLowerCase()
      const tocItems = this.querySelectorAll('ul > li')

      tocItems.forEach((item) => {
        const link = item.querySelector('a')
        const text = link?.textContent || ''

        if (!keyword || text.toLowerCase().includes(lowerKeyword)) {
          item.classList.remove('toc-search-no-match')
        } else {
          item.classList.add('toc-search-no-match')
        }
      })
    }
  }

  customElements.define('table-of-contents', Toc)
</script>
