---
import '~/styles/music.css'
---

<div class="gramophone-wrapper">
  <div id="gramophone-canvas" class="gramophone-canvas"></div>

  <!-- 提示信息 -->
  <div class="gramophone-hints">
    <div class="hint-item">
      <span class="i-ri-hand-coin-line"></span>
      <span>点击唱臂播放</span>
    </div>
    <div class="hint-item">
      <span class="i-ri-drag-move-line"></span>
      <span>拖拽旋转视角</span>
    </div>
    <div class="hint-item">
      <span class="i-ri-zoom-in-line"></span>
      <span>滚轮缩放</span>
    </div>
  </div>
</div>

<style>
  .gramophone-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .gramophone-canvas {
    width: 100%;
    height: 100%;
    border-radius: 16px;
    overflow: hidden;
  }

  .gramophone-hints {
    position: absolute;
    top: 0.75rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(8px);
    border-radius: 20px;
    z-index: 10;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .hint-item {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.65rem;
    color: rgba(255, 255, 255, 0.8);
    white-space: nowrap;
    padding: 0.25rem 0.5rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    transition: all 0.2s ease;
  }

  .hint-item:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  .hint-item span:first-child {
    font-size: 0.75rem;
    opacity: 0.9;
  }

  @media (max-width: 768px) {
    .gramophone-wrapper {
      min-height: 400px;
    }

    .gramophone-canvas {
      min-height: 350px;
    }

    .gramophone-hints {
      flex-direction: column;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
    }
  }
</style>

<script>
  import * as THREE from 'three'

  interface Song {
    id: string
    name: string
    duration: string
    url: string
  }

  interface Album {
    id: string
    name: string
    description: string
    artist: string
    cover: string
    color: string
    songs: Song[]
  }

  document.addEventListener('astro:page-load', () => {
    const container = document.getElementById('gramophone-canvas')

    if (!container) return

    // Get container size
    const getContainerSize = () => {
      const width = container.clientWidth || 800
      const height = container.clientHeight || 500
      return { width, height }
    }

    const initialSize = getContainerSize()

    // Helper function to get theme background color
    const getThemeBackgroundColor = () => {
      const isDark = document.documentElement.classList.contains('dark')
      // Return appropriate background color based on theme
      return isDark ? 0x1a1a1a : 0xf5f5f5
    }

    // Scene setup
    const scene = new THREE.Scene()
    scene.background = new THREE.Color(getThemeBackgroundColor())

    // Camera - top-down 45 degree view
    const camera = new THREE.PerspectiveCamera(
      45,
      initialSize.width / initialSize.height,
      0.1,
      1000
    )

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: false,
    })
    renderer.setSize(initialSize.width, initialSize.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    renderer.toneMapping = THREE.ACESFilmicToneMapping
    renderer.toneMappingExposure = 1.4
    renderer.outputColorSpace = THREE.SRGBColorSpace
    container.appendChild(renderer.domElement)

    // ==================== Lighting ====================
    // Ambient light - general illumination
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4)
    scene.add(ambientLight)

    // Main spotlight from above (creates vinyl reflection)
    const spotLight = new THREE.SpotLight(0xffffff, 60)
    spotLight.position.set(0, 10, 0)
    spotLight.angle = Math.PI / 3
    spotLight.penumbra = 0.4
    spotLight.decay = 1.5
    spotLight.distance = 25
    spotLight.castShadow = true
    spotLight.shadow.mapSize.width = 2048
    spotLight.shadow.mapSize.height = 2048
    spotLight.shadow.camera.near = 1
    spotLight.shadow.camera.far = 25
    scene.add(spotLight)
    scene.add(spotLight.target)

    // Front spotlight - illuminates vinyl grooves from front
    const frontSpotLight = new THREE.SpotLight(0xffffff, 40)
    frontSpotLight.position.set(0, 6, 8)
    frontSpotLight.angle = Math.PI / 4
    frontSpotLight.penumbra = 0.5
    frontSpotLight.decay = 1.5
    frontSpotLight.distance = 20
    frontSpotLight.target.position.set(-0.3, 0.65, 0)
    scene.add(frontSpotLight)
    scene.add(frontSpotLight.target)

    // Side spotlight - creates vinyl texture highlight
    const sideSpotLight = new THREE.SpotLight(0xffeedd, 35)
    sideSpotLight.position.set(-6, 5, 4)
    sideSpotLight.angle = Math.PI / 5
    sideSpotLight.penumbra = 0.3
    sideSpotLight.decay = 1.5
    sideSpotLight.distance = 18
    sideSpotLight.target.position.set(-0.3, 0.65, 0)
    scene.add(sideSpotLight)
    scene.add(sideSpotLight.target)

    // Back spotlight - rim lighting effect
    const backSpotLight = new THREE.SpotLight(0xddeeff, 30)
    backSpotLight.position.set(4, 4, -6)
    backSpotLight.angle = Math.PI / 5
    backSpotLight.penumbra = 0.4
    backSpotLight.decay = 1.5
    backSpotLight.distance = 18
    backSpotLight.target.position.set(-0.3, 0.65, 0)
    scene.add(backSpotLight)
    scene.add(backSpotLight.target)

    // Rim lights for edge highlights
    const rimLight1 = new THREE.DirectionalLight(0x4fc3f7, 0.5)
    rimLight1.position.set(-8, 4, 8)
    scene.add(rimLight1)

    const rimLight2 = new THREE.DirectionalLight(0xff7043, 0.4)
    rimLight2.position.set(8, 3, -8)
    scene.add(rimLight2)

    // Fill light from front
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3)
    fillLight.position.set(0, 5, 10)
    scene.add(fillLight)

    // Bottom fill light - shows vinyl underside detail
    const bottomFillLight = new THREE.DirectionalLight(0xffffff, 0.15)
    bottomFillLight.position.set(0, -2, 5)
    scene.add(bottomFillLight)

    // ==================== Materials ====================
    // Matte black material for turntable body
    const matteBlackMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a1a1a,
      roughness: 0.85,
      metalness: 0.1,
    })

    // Brushed aluminum material
    const aluminumMaterial = new THREE.MeshStandardMaterial({
      color: 0xd0d0d0,
      roughness: 0.35,
      metalness: 0.85,
    })

    // Chrome/polished metal material
    const chromeMaterial = new THREE.MeshStandardMaterial({
      color: 0xfafafa,
      roughness: 0.1,
      metalness: 0.95,
    })

    // Rubber mat material
    const rubberMaterial = new THREE.MeshStandardMaterial({
      color: 0x2a2a2a,
      roughness: 0.9,
      metalness: 0,
    })

    // Vinyl material with reflective properties
    const vinylMaterial = new THREE.MeshStandardMaterial({
      color: 0x0a0a0a,
      roughness: 0.1,
      metalness: 0.15,
    })

    // Gold accent material
    const goldMaterial = new THREE.MeshStandardMaterial({
      color: 0xd4af37,
      roughness: 0.3,
      metalness: 0.9,
    })

    // Red LED indicator
    const ledMaterial = new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 0.5,
      roughness: 0.3,
      metalness: 0.1,
    })

    // Turntable group
    const turntableGroup = new THREE.Group()

    // ==================== Base/Plinth ====================
    // Main base - sleek rectangular with rounded edges
    const baseShape = new THREE.Shape()
    const baseWidth = 6
    const baseDepth = 5
    const cornerRadius = 0.3

    baseShape.moveTo(-baseWidth / 2 + cornerRadius, -baseDepth / 2)
    baseShape.lineTo(baseWidth / 2 - cornerRadius, -baseDepth / 2)
    baseShape.quadraticCurveTo(
      baseWidth / 2,
      -baseDepth / 2,
      baseWidth / 2,
      -baseDepth / 2 + cornerRadius
    )
    baseShape.lineTo(baseWidth / 2, baseDepth / 2 - cornerRadius)
    baseShape.quadraticCurveTo(
      baseWidth / 2,
      baseDepth / 2,
      baseWidth / 2 - cornerRadius,
      baseDepth / 2
    )
    baseShape.lineTo(-baseWidth / 2 + cornerRadius, baseDepth / 2)
    baseShape.quadraticCurveTo(
      -baseWidth / 2,
      baseDepth / 2,
      -baseWidth / 2,
      baseDepth / 2 - cornerRadius
    )
    baseShape.lineTo(-baseWidth / 2, -baseDepth / 2 + cornerRadius)
    baseShape.quadraticCurveTo(
      -baseWidth / 2,
      -baseDepth / 2,
      -baseWidth / 2 + cornerRadius,
      -baseDepth / 2
    )

    const baseExtrudeSettings = {
      depth: 0.4,
      bevelEnabled: true,
      bevelThickness: 0.05,
      bevelSize: 0.05,
      bevelSegments: 3,
    }

    const baseGeometry = new THREE.ExtrudeGeometry(
      baseShape,
      baseExtrudeSettings
    )
    baseGeometry.rotateX(-Math.PI / 2)
    const baseMesh = new THREE.Mesh(baseGeometry, matteBlackMaterial)
    baseMesh.position.y = 0
    baseMesh.receiveShadow = true
    baseMesh.castShadow = true
    turntableGroup.add(baseMesh)

    // Feet (isolators)
    const footGeometry = new THREE.CylinderGeometry(0.2, 0.25, 0.15, 24)
    const footPositions = [
      [-2.5, -0.075, -2],
      [2.5, -0.075, -2],
      [-2.5, -0.075, 2],
      [2.5, -0.075, 2],
    ]

    footPositions.forEach((pos) => {
      const foot = new THREE.Mesh(footGeometry, rubberMaterial)
      foot.position.set(pos[0], pos[1], pos[2])
      turntableGroup.add(foot)
    })

    // ==================== Platter ====================
    // Platter base ring
    const platterRingGeometry = new THREE.TorusGeometry(2.1, 0.08, 16, 64)
    const platterRing = new THREE.Mesh(platterRingGeometry, aluminumMaterial)
    platterRing.rotation.x = Math.PI / 2
    platterRing.position.set(-0.3, 0.5, 0)
    turntableGroup.add(platterRing)

    // Main platter (rotating part)
    const platterGroup = new THREE.Group()
    platterGroup.position.set(-0.3, 0.55, 0)

    // Platter disc
    const platterGeometry = new THREE.CylinderGeometry(2, 2, 0.1, 64)
    const platter = new THREE.Mesh(platterGeometry, aluminumMaterial)
    platter.castShadow = true
    platter.receiveShadow = true
    platterGroup.add(platter)

    // Rubber mat on platter
    const matGeometry = new THREE.CylinderGeometry(1.9, 1.9, 0.03, 64)
    const mat = new THREE.Mesh(matGeometry, rubberMaterial)
    mat.position.y = 0.065
    platterGroup.add(mat)

    // Spindle
    const spindleGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.3, 16)
    const spindle = new THREE.Mesh(spindleGeometry, chromeMaterial)
    spindle.position.y = 0.2
    platterGroup.add(spindle)

    // Strobe dots around platter edge
    const strobeDotCount = 60
    for (let i = 0; i < strobeDotCount; i++) {
      const angle = (i / strobeDotCount) * Math.PI * 2
      const dotGeometry = new THREE.CircleGeometry(0.02, 8)
      const dotMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff })
      const dot = new THREE.Mesh(dotGeometry, dotMaterial)
      dot.rotation.x = -Math.PI / 2
      dot.position.set(Math.cos(angle) * 1.95, 0.06, Math.sin(angle) * 1.95)
      platterGroup.add(dot)
    }

    turntableGroup.add(platterGroup)

    // ==================== Vinyl Record ====================
    const vinylGroup = new THREE.Group()
    vinylGroup.position.set(-0.3, 0.65, 0)
    vinylGroup.visible = false

    // Main vinyl disc
    const vinylGeometry = new THREE.CylinderGeometry(1.75, 1.75, 0.025, 128)
    const vinyl = new THREE.Mesh(vinylGeometry, vinylMaterial)
    vinyl.castShadow = true
    vinyl.receiveShadow = true
    vinylGroup.add(vinyl)

    // Vinyl grooves with light reflection - more grooves for better detail
    for (let i = 0; i < 50; i++) {
      const radius = 0.45 + (1.2 * i) / 50
      const grooveGeometry = new THREE.TorusGeometry(radius, 0.0015, 4, 128)
      const grooveMaterial = new THREE.MeshStandardMaterial({
        color: i % 3 === 0 ? 0x1a1a1a : 0x121212,
        roughness: 0.15,
        metalness: 0.4,
      })
      const groove = new THREE.Mesh(grooveGeometry, grooveMaterial)
      groove.rotation.x = Math.PI / 2
      groove.position.y = 0.014
      vinylGroup.add(groove)
    }

    // Vinyl highlight ring (catches light)
    const highlightRingGeometry = new THREE.TorusGeometry(1.1, 0.2, 4, 128)
    const highlightRingMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a1a1a,
      roughness: 0.03,
      metalness: 0.5,
      transparent: true,
      opacity: 0.25,
    })
    const highlightRing = new THREE.Mesh(
      highlightRingGeometry,
      highlightRingMaterial
    )
    highlightRing.rotation.x = Math.PI / 2
    highlightRing.position.y = 0.015
    vinylGroup.add(highlightRing)

    // Texture loader for album cover
    const textureLoader = new THREE.TextureLoader()

    // Center label with cover image
    const labelGeometry = new THREE.CylinderGeometry(0.42, 0.42, 0.03, 64)
    const labelMaterial = new THREE.MeshStandardMaterial({
      color: 0xcd853f,
      roughness: 0.5,
      metalness: 0.1,
    })
    const label = new THREE.Mesh(labelGeometry, labelMaterial)
    label.position.y = 0.015
    vinylGroup.add(label)

    // Cover image plane on top of label
    const coverGeometry = new THREE.CircleGeometry(0.38, 64)
    const coverMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.4,
      metalness: 0.1,
      transparent: true,
      opacity: 1,
    })
    const coverMesh = new THREE.Mesh(coverGeometry, coverMaterial)
    coverMesh.rotation.x = -Math.PI / 2
    coverMesh.position.y = 0.032
    vinylGroup.add(coverMesh)

    // Function to update cover image
    function updateCoverImage(coverUrl: string) {
      textureLoader.load(
        coverUrl,
        (texture) => {
          texture.colorSpace = THREE.SRGBColorSpace
          coverMaterial.map = texture
          coverMaterial.needsUpdate = true
        },
        undefined,
        () => {
          // Error loading texture - use fallback color
          coverMaterial.map = null
          coverMaterial.color.setHex(0xcd853f)
          coverMaterial.needsUpdate = true
        }
      )
    }

    // Label ring decoration
    const labelRingGeometry = new THREE.TorusGeometry(0.36, 0.015, 8, 32)
    const labelRing = new THREE.Mesh(
      labelRingGeometry,
      new THREE.MeshStandardMaterial({ color: 0x8b6914, roughness: 0.4 })
    )
    labelRing.rotation.x = Math.PI / 2
    labelRing.position.y = 0.033
    vinylGroup.add(labelRing)

    // Center hole
    const holeGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.04, 16)
    const hole = new THREE.Mesh(
      holeGeometry,
      new THREE.MeshStandardMaterial({ color: 0x050505 })
    )
    hole.position.y = 0.02
    vinylGroup.add(hole)

    turntableGroup.add(vinylGroup)

    // ==================== Tonearm ====================
    // Tonearm base/pivot
    const armBaseGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.35, 32)
    const armBase = new THREE.Mesh(armBaseGeometry, aluminumMaterial)
    armBase.position.set(2.2, 0.57, -1.5)
    armBase.castShadow = true
    turntableGroup.add(armBase)

    // Tonearm pivot cap
    const pivotCapGeometry = new THREE.CylinderGeometry(0.18, 0.2, 0.08, 24)
    const pivotCap = new THREE.Mesh(pivotCapGeometry, chromeMaterial)
    pivotCap.position.set(2.2, 0.79, -1.5)
    turntableGroup.add(pivotCap)

    // Tonearm rotating group
    const tonearmGroup = new THREE.Group()
    tonearmGroup.position.set(2.2, 0.85, -1.5)

    // Tonearm hitbox (invisible, larger for easier clicking)
    const hitboxGeometry = new THREE.BoxGeometry(2.8, 0.5, 0.6)
    const hitboxMaterial = new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 0,
      depthWrite: false,
    })
    const tonearmHitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial)
    tonearmHitbox.position.set(-1.1, 0, 0.2)
    tonearmHitbox.name = 'tonearmHitbox'
    tonearmGroup.add(tonearmHitbox)

    // Arm rest
    const armRestGeometry = new THREE.BoxGeometry(0.15, 0.2, 0.08)
    const armRest = new THREE.Mesh(armRestGeometry, aluminumMaterial)
    armRest.position.set(0.3, -0.05, 0.5)
    tonearmGroup.add(armRest)

    // Main arm tube (S-curve design)
    const armCurve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(-0.5, 0.02, 0.15),
      new THREE.Vector3(-1.2, 0, 0.25),
      new THREE.Vector3(-1.8, -0.03, 0.35),
      new THREE.Vector3(-2.2, -0.08, 0.4),
    ])
    const armTubeGeometry = new THREE.TubeGeometry(
      armCurve,
      48,
      0.03,
      12,
      false
    )
    const armTube = new THREE.Mesh(armTubeGeometry, chromeMaterial)
    armTube.castShadow = true
    tonearmGroup.add(armTube)

    // Headshell
    const headshellGeometry = new THREE.BoxGeometry(0.12, 0.04, 0.15)
    const headshell = new THREE.Mesh(headshellGeometry, aluminumMaterial)
    headshell.position.set(-2.3, -0.1, 0.42)
    headshell.rotation.z = -0.15
    tonearmGroup.add(headshell)

    // Cartridge
    const cartridgeGeometry = new THREE.BoxGeometry(0.08, 0.05, 0.1)
    const cartridgeMaterial = new THREE.MeshStandardMaterial({
      color: 0x2a2a2a,
      roughness: 0.4,
      metalness: 0.2,
    })
    const cartridge = new THREE.Mesh(cartridgeGeometry, cartridgeMaterial)
    cartridge.position.set(-2.3, -0.16, 0.42)
    tonearmGroup.add(cartridge)

    // Stylus/Needle
    const needleGeometry = new THREE.ConeGeometry(0.01, 0.08, 8)
    const needle = new THREE.Mesh(needleGeometry, goldMaterial)
    needle.rotation.x = Math.PI
    needle.position.set(-2.3, -0.24, 0.42)
    tonearmGroup.add(needle)

    // Counterweight
    const counterweightGeometry = new THREE.CylinderGeometry(
      0.12,
      0.12,
      0.18,
      24
    )
    const counterweight = new THREE.Mesh(
      counterweightGeometry,
      aluminumMaterial
    )
    counterweight.rotation.z = Math.PI / 2
    counterweight.position.set(0.35, 0, 0)
    tonearmGroup.add(counterweight)

    // Anti-skate weight
    const antiSkateGeometry = new THREE.SphereGeometry(0.04, 16, 16)
    const antiSkate = new THREE.Mesh(antiSkateGeometry, chromeMaterial)
    antiSkate.position.set(0.15, 0.08, 0.15)
    tonearmGroup.add(antiSkate)

    // Set tonearm to rest position
    tonearmGroup.rotation.y = 0.9

    turntableGroup.add(tonearmGroup)

    // ==================== Controls ====================
    // Start/Stop button
    const buttonBaseGeometry = new THREE.CylinderGeometry(0.2, 0.22, 0.06, 24)
    const buttonBase = new THREE.Mesh(buttonBaseGeometry, aluminumMaterial)
    buttonBase.position.set(2.2, 0.43, 1.8)
    turntableGroup.add(buttonBase)

    const buttonGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.04, 24)
    const buttonMaterial = new THREE.MeshStandardMaterial({
      color: 0x333333,
      roughness: 0.3,
      metalness: 0.2,
    })
    const button = new THREE.Mesh(buttonGeometry, buttonMaterial)
    button.position.set(2.2, 0.48, 1.8)
    turntableGroup.add(button)

    // Speed selector (33/45 RPM)
    const speedSelectorGeometry = new THREE.CylinderGeometry(
      0.15,
      0.15,
      0.05,
      24
    )
    const speedSelector = new THREE.Mesh(
      speedSelectorGeometry,
      aluminumMaterial
    )
    speedSelector.position.set(1.5, 0.45, 1.8)
    turntableGroup.add(speedSelector)

    // Volume knob
    const volumeKnobGroup = new THREE.Group()
    volumeKnobGroup.position.set(2.5, 0.48, 0.8)
    volumeKnobGroup.name = 'volumeKnob'

    const knobBaseGeometry = new THREE.CylinderGeometry(0.18, 0.2, 0.06, 32)
    const knobBase = new THREE.Mesh(knobBaseGeometry, aluminumMaterial)
    volumeKnobGroup.add(knobBase)

    const knobGeometry = new THREE.CylinderGeometry(0.14, 0.14, 0.08, 32)
    const knob = new THREE.Mesh(
      knobGeometry,
      new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.3,
        metalness: 0.2,
      })
    )
    knob.position.y = 0.06
    volumeKnobGroup.add(knob)

    // Knob indicator line
    const indicatorGeometry = new THREE.BoxGeometry(0.02, 0.08, 0.02)
    const indicatorMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
    })
    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial)
    indicator.position.set(0, 0.1, 0.1)
    volumeKnobGroup.add(indicator)

    // Knob grip lines
    for (let i = 0; i < 16; i++) {
      const angle = (i / 16) * Math.PI * 2
      const gripGeometry = new THREE.BoxGeometry(0.008, 0.06, 0.01)
      const grip = new THREE.Mesh(
        gripGeometry,
        new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
      )
      grip.position.set(Math.sin(angle) * 0.12, 0.06, Math.cos(angle) * 0.12)
      grip.rotation.y = angle
      volumeKnobGroup.add(grip)
    }

    turntableGroup.add(volumeKnobGroup)

    // LED power indicator
    const ledGeometry = new THREE.SphereGeometry(0.03, 16, 16)
    const led = new THREE.Mesh(ledGeometry, ledMaterial)
    led.position.set(2.5, 0.45, 1.3)
    turntableGroup.add(led)

    // Brand logo area (simple rectangle)
    const logoGeometry = new THREE.BoxGeometry(0.8, 0.01, 0.15)
    const logoMaterial = new THREE.MeshStandardMaterial({
      color: 0x3a3a3a,
      roughness: 0.5,
      metalness: 0.3,
    })
    const logo = new THREE.Mesh(logoGeometry, logoMaterial)
    logo.position.set(-2.4, 0.41, 1.8)
    turntableGroup.add(logo)

    scene.add(turntableGroup)

    // ==================== State Management ====================
    let isPlaying = false
    let currentAlbum: Album | null = null
    let currentSongIndex = 0
    let audioElement: HTMLAudioElement | null = null
    let volume = 0.7

    // Tonearm angles
    let tonearmAngle = 0.9
    const tonearmPlayStartAngle = -0.15 // Outer groove position
    const tonearmPlayEndAngle = -0.55 // Inner groove position
    const tonearmRestAngle = 0.9 // Rest position
    let isTonearmDown = false
    let playbackProgress = 0

    // Animation variables
    let vinylRotation = 0

    // Knob state - FIXED: reversed direction
    let isDraggingKnob = false
    let knobRotation = -0.7 * Math.PI // Initial 70% volume
    const knobMinRotation = -Math.PI // 0% volume (full left)
    const knobMaxRotation = 0 // 100% volume (full right)

    // 3D view dragging
    let isDraggingScene = false
    let previousMousePosition = { x: 0, y: 0 }
    let cameraTheta = 0 // Horizontal angle - start facing front
    let cameraPhi = Math.PI / 4 // Vertical angle - 45 degrees from above
    let cameraRadius = 12
    const minZoom = 8
    const maxZoom = 20

    // ==================== Volume Knob Interaction ====================
    const raycaster = new THREE.Raycaster()
    const mouse = new THREE.Vector2()
    let lastMouseX = 0

    function updateVolumeFromKnob() {
      // Convert knob rotation to volume (0-1)
      // knobMinRotation (-π) = 0%, knobMaxRotation (0) = 100%
      const normalizedAngle =
        (knobRotation - knobMinRotation) / (knobMaxRotation - knobMinRotation)
      volume = Math.max(0, Math.min(1, normalizedAngle))

      if (audioElement) {
        audioElement.volume = volume
      }

      // Rotate the indicator around Y axis
      volumeKnobGroup.rotation.y = knobRotation
    }

    // Initialize knob position
    updateVolumeFromKnob()

    // Update camera position
    function updateCameraPosition() {
      camera.position.x =
        cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi)
      camera.position.y = cameraRadius * Math.sin(cameraPhi) + 1
      camera.position.z =
        cameraRadius * Math.cos(cameraTheta) * Math.cos(cameraPhi)
      camera.lookAt(0, 0.3, 0)
    }

    // Initialize camera position
    updateCameraPosition()

    renderer.domElement.addEventListener('mousedown', (event) => {
      const rect = renderer.domElement.getBoundingClientRect()
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1

      raycaster.setFromCamera(mouse, camera)

      // Check volume knob click
      const knobIntersects = raycaster.intersectObjects(
        volumeKnobGroup.children,
        true
      )
      if (knobIntersects.length > 0) {
        isDraggingKnob = true
        lastMouseX = event.clientX
        return
      }

      // Check tonearm click (using hitbox for larger area)
      const tonearmObjects = tonearmGroup.children
      const armIntersects = raycaster.intersectObjects(tonearmObjects, true)
      if (armIntersects.length > 0) {
        toggleTonearm()
        return
      }

      // Start scene dragging
      isDraggingScene = true
      previousMousePosition = { x: event.clientX, y: event.clientY }
      renderer.domElement.style.cursor = 'grabbing'
    })

    renderer.domElement.addEventListener('mousemove', (event) => {
      // Drag volume knob
      if (isDraggingKnob) {
        const deltaX = event.clientX - lastMouseX
        // FIXED: changed sign to fix reversed direction
        knobRotation += deltaX * 0.02
        knobRotation = Math.max(
          knobMinRotation,
          Math.min(knobMaxRotation, knobRotation)
        )
        updateVolumeFromKnob()
        lastMouseX = event.clientX
        return
      }

      // Drag 3D scene
      if (isDraggingScene) {
        const deltaX = event.clientX - previousMousePosition.x
        const deltaY = event.clientY - previousMousePosition.y

        cameraTheta -= deltaX * 0.005
        cameraPhi += deltaY * 0.005

        // Limit vertical angle
        cameraPhi = Math.max(0.2, Math.min(Math.PI / 2.2, cameraPhi))

        updateCameraPosition()
        previousMousePosition = { x: event.clientX, y: event.clientY }
        return
      }

      // Hover detection
      const rect = renderer.domElement.getBoundingClientRect()
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1

      raycaster.setFromCamera(mouse, camera)

      const knobIntersects = raycaster.intersectObjects(
        volumeKnobGroup.children,
        true
      )
      const armIntersects = raycaster.intersectObjects(
        tonearmGroup.children,
        true
      )

      if (knobIntersects.length > 0 || armIntersects.length > 0) {
        renderer.domElement.style.cursor = 'pointer'
      } else {
        renderer.domElement.style.cursor = 'grab'
      }
    })

    renderer.domElement.addEventListener('mouseup', () => {
      isDraggingKnob = false
      isDraggingScene = false
      renderer.domElement.style.cursor = 'grab'
    })

    renderer.domElement.addEventListener('mouseleave', () => {
      isDraggingKnob = false
      isDraggingScene = false
      renderer.domElement.style.cursor = 'grab'
    })

    // Scroll zoom
    renderer.domElement.addEventListener(
      'wheel',
      (e) => {
        e.preventDefault()
        const delta = e.deltaY > 0 ? 1 : -1
        cameraRadius = Math.max(
          minZoom,
          Math.min(maxZoom, cameraRadius + delta * 0.5)
        )
        updateCameraPosition()
      },
      { passive: false }
    )

    // Touch pinch zoom
    let touchStartDistance = 0
    let initialPinchRadius = cameraRadius

    renderer.domElement.addEventListener(
      'touchstart',
      (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX
          const dy = e.touches[0].clientY - e.touches[1].clientY
          touchStartDistance = Math.sqrt(dx * dx + dy * dy)
          initialPinchRadius = cameraRadius
        }
      },
      { passive: true }
    )

    renderer.domElement.addEventListener(
      'touchmove',
      (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX
          const dy = e.touches[0].clientY - e.touches[1].clientY
          const distance = Math.sqrt(dx * dx + dy * dy)
          const scale = touchStartDistance / distance
          cameraRadius = Math.max(
            minZoom,
            Math.min(maxZoom, initialPinchRadius * scale)
          )
          updateCameraPosition()
        }
      },
      { passive: true }
    )

    // ==================== Event Listeners ====================
    window.addEventListener('album-selected', ((e: CustomEvent) => {
      // Check if already playing before loading new album
      const wasPlaying = isPlaying && isTonearmDown
      loadAlbum(e.detail)

      // If was playing, auto-play the new album's first song after loading
      if (wasPlaying) {
        setTimeout(() => {
          isTonearmDown = true
          playbackProgress = 0
          animateTonearm(tonearmPlayStartAngle)
          // Play the first song of the new album
          playSong(0)
        }, 600)
      }
    }) as EventListener)

    // Auto-play album when clicked (first time)
    window.addEventListener('auto-play-album', (() => {
      if (!currentAlbum) return

      // Wait for vinyl placement animation then auto-play
      setTimeout(() => {
        if (!isTonearmDown) {
          isTonearmDown = true
          playbackProgress = 0
          animateTonearm(tonearmPlayStartAngle)
          // Play the first song
          playSong(0)
        }
      }, 600)
    }) as EventListener)

    window.addEventListener('song-selected', ((e: CustomEvent) => {
      const { index } = e.detail

      // If tonearm is not down, lower it first
      if (!isTonearmDown && currentAlbum) {
        isTonearmDown = true
        playbackProgress = 0
        animateTonearm(tonearmPlayStartAngle)
      }

      playSong(index)
    }) as EventListener)

    window.addEventListener('seek-to', ((e: CustomEvent) => {
      if (audioElement && audioElement.duration) {
        audioElement.currentTime = audioElement.duration * e.detail
      }
    }) as EventListener)

    // ==================== Playback Control ====================
    function loadAlbum(album: Album) {
      currentAlbum = album
      currentSongIndex = 0
      vinylGroup.visible = true

      // Update label color
      labelMaterial.color.setStyle(album.color || '#8B4513')

      // Load album cover image onto vinyl
      if (album.cover) {
        updateCoverImage(album.cover)
      }

      if (isPlaying) {
        stopPlayback()
      }

      animateVinylPlacement()
    }

    function playSong(index: number) {
      if (!currentAlbum || !currentAlbum.songs[index]) return

      currentSongIndex = index
      const song = currentAlbum.songs[index]

      // Reset progress
      playbackProgress = 0

      // Animate tonearm back to outer groove with smooth animation
      if (isTonearmDown) {
        animateTonearm(tonearmPlayStartAngle)
      }

      if (!audioElement) {
        audioElement = new Audio()
        audioElement.addEventListener('ended', handleSongEnd)
        audioElement.addEventListener('timeupdate', handleTimeUpdate)
        audioElement.addEventListener('loadedmetadata', () => {
          window.dispatchEvent(
            new CustomEvent('playback-progress', {
              detail: {
                currentTime: 0,
                duration: audioElement?.duration || 0,
                songIndex: currentSongIndex,
              },
            })
          )
        })
      }

      audioElement.src = song.url
      audioElement.volume = volume

      // Only play if tonearm is down
      if (isTonearmDown) {
        audioElement.play()
        isPlaying = true
        window.dispatchEvent(
          new CustomEvent('playback-state', {
            detail: { isPlaying: true, songIndex: currentSongIndex },
          })
        )
      }
    }

    function startPlayback() {
      if (!currentAlbum) return

      isPlaying = true

      if (audioElement && audioElement.src) {
        audioElement.play()
      } else if (currentAlbum) {
        playSong(currentSongIndex)
        return
      }

      window.dispatchEvent(
        new CustomEvent('playback-state', {
          detail: { isPlaying: true, songIndex: currentSongIndex },
        })
      )
    }

    function stopPlayback() {
      isPlaying = false

      if (audioElement) {
        audioElement.pause()
      }

      window.dispatchEvent(
        new CustomEvent('playback-state', {
          detail: { isPlaying: false, songIndex: currentSongIndex },
        })
      )
    }

    // Tonearm toggle control
    function toggleTonearm() {
      if (!currentAlbum) return

      if (isTonearmDown) {
        // Lift tonearm - stop playback
        isTonearmDown = false
        playbackProgress = 0
        animateTonearm(tonearmRestAngle)
        stopPlayback()
      } else {
        // Lower tonearm - start playback from outer groove
        isTonearmDown = true
        playbackProgress = 0
        animateTonearm(tonearmPlayStartAngle)
        startPlayback()
      }
    }

    function handleSongEnd() {
      if (!currentAlbum) return

      currentSongIndex++
      if (currentSongIndex < currentAlbum.songs.length) {
        playSong(currentSongIndex)
      } else {
        currentSongIndex = 0
        stopPlayback()
      }
    }

    function handleTimeUpdate() {
      if (!audioElement) return

      // Update playback progress
      if (audioElement.duration > 0) {
        playbackProgress = audioElement.currentTime / audioElement.duration

        // Update tonearm position based on progress (outer to inner)
        if (isTonearmDown && isPlaying) {
          const targetAngle =
            tonearmPlayStartAngle +
            (tonearmPlayEndAngle - tonearmPlayStartAngle) * playbackProgress
          tonearmAngle = targetAngle
          tonearmGroup.rotation.y = targetAngle
        }
      }

      window.dispatchEvent(
        new CustomEvent('playback-progress', {
          detail: {
            currentTime: audioElement.currentTime,
            duration: audioElement.duration,
            songIndex: currentSongIndex,
          },
        })
      )
    }

    // ==================== Animations ====================
    function animateVinylPlacement() {
      vinylGroup.position.y = 2.5
      vinylGroup.scale.set(0.3, 0.3, 0.3)
      vinylGroup.rotation.x = 0.2

      const animate = () => {
        const targetY = 0.65
        const diff = vinylGroup.position.y - targetY

        if (Math.abs(diff) > 0.01) {
          vinylGroup.position.y -= diff * 0.1

          const scale = vinylGroup.scale.x
          if (scale < 1) {
            const newScale = scale + (1 - scale) * 0.1
            vinylGroup.scale.set(newScale, newScale, newScale)
          }

          if (vinylGroup.rotation.x > 0.01) {
            vinylGroup.rotation.x *= 0.85
          }

          requestAnimationFrame(animate)
        } else {
          vinylGroup.position.y = targetY
          vinylGroup.scale.set(1, 1, 1)
          vinylGroup.rotation.x = 0
        }
      }
      animate()
    }

    function animateTonearm(targetAngle: number) {
      const startAngle = tonearmAngle
      const startTime = performance.now()
      const duration = 800 // Smooth animation duration in ms

      // Easing function - ease out cubic for smooth deceleration
      const easeOutCubic = (t: number) => 1 - Math.pow(1 - t, 3)

      const animate = (currentTime: number) => {
        const elapsed = currentTime - startTime
        const progress = Math.min(elapsed / duration, 1)
        const easedProgress = easeOutCubic(progress)

        tonearmAngle = startAngle + (targetAngle - startAngle) * easedProgress
        tonearmGroup.rotation.y = tonearmAngle

        if (progress < 1) {
          requestAnimationFrame(animate)
        } else {
          tonearmAngle = targetAngle
          tonearmGroup.rotation.y = targetAngle
        }
      }

      requestAnimationFrame(animate)
    }

    // ==================== Render Loop ====================
    function animate() {
      requestAnimationFrame(animate)

      // Vinyl rotation - continuous when playing
      if (isPlaying && isTonearmDown && vinylGroup.visible) {
        vinylRotation += 0.02 // ~33 RPM equivalent
        vinylGroup.rotation.y = vinylRotation
        platterGroup.rotation.y = vinylRotation
      }

      // Subtle spotlight animation
      const time = Date.now() * 0.001
      spotLight.position.x = Math.sin(time * 0.2) * 0.5
      spotLight.position.z = Math.cos(time * 0.2) * 0.5

      renderer.render(scene, camera)
    }

    animate()

    // ==================== Responsive ====================
    function handleResize() {
      if (!container) return

      const size = getContainerSize()
      camera.aspect = size.width / size.height
      camera.updateProjectionMatrix()
      renderer.setSize(size.width, size.height)
    }

    window.addEventListener('resize', handleResize)

    // Delayed resize to ensure correct container size
    setTimeout(handleResize, 100)

    // ==================== Theme Adaptation ====================
    const updateThemeColors = () => {
      const isDark = document.documentElement.classList.contains('dark')
      const bgColor = getThemeBackgroundColor()

      // Update scene background
      scene.background = new THREE.Color(bgColor)

      // Adjust lighting based on theme
      if (isDark) {
        // Dark theme: brighter lights for contrast
        ambientLight.intensity = 0.4
        spotLight.intensity = 60
        frontSpotLight.intensity = 40
        sideSpotLight.intensity = 35
        backSpotLight.intensity = 30
        rimLight1.intensity = 0.5
        rimLight2.intensity = 0.4
        fillLight.intensity = 0.3
        bottomFillLight.intensity = 0.15
        renderer.toneMappingExposure = 1.4
      } else {
        // Light theme: softer lights to avoid overexposure
        ambientLight.intensity = 0.5
        spotLight.intensity = 40
        frontSpotLight.intensity = 25
        sideSpotLight.intensity = 20
        backSpotLight.intensity = 18
        rimLight1.intensity = 0.35
        rimLight2.intensity = 0.25
        fillLight.intensity = 0.3
        bottomFillLight.intensity = 0.1
        renderer.toneMappingExposure = 1.1
      }
    }

    // Listen for theme changes
    const themeObserver = new MutationObserver(() => {
      updateThemeColors()
    })

    themeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class'],
    })

    // Initial theme setup
    updateThemeColors()

    // Cleanup
    window.addEventListener('beforeunload', () => {
      themeObserver.disconnect()
      if (audioElement) {
        audioElement.pause()
        audioElement = null
      }
    })
  })
</script>
