---
import '~/styles/music.css'
---

<div class="gramophone-wrapper">
  <div id="gramophone-canvas" class="gramophone-canvas"></div>

  <!-- 提示信息 -->
  <div class="gramophone-hints">
    <div class="hint-item">
      <span class="i-ri-hand-coin-line"></span>
      <span>点击唱臂播放</span>
    </div>
    <div class="hint-item">
      <span class="i-ri-drag-move-line"></span>
      <span>拖拽旋转</span>
    </div>
    <div class="hint-item">
      <span class="i-ri-zoom-in-line"></span>
      <span>滚轮缩放</span>
    </div>
  </div>

  <!-- 拖拽放置区域指示 -->
  <div class="drop-zone-indicator" id="drop-zone-indicator">
    <span class="i-ri-add-circle-line"></span>
    <p>放置唱片</p>
  </div>
</div>

<style>
  .gramophone-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .gramophone-canvas {
    width: 100%;
    height: 100%;
    border-radius: 16px;
    overflow: hidden;
  }

  .gramophone-hints {
    position: absolute;
    top: 0.75rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(8px);
    border-radius: 20px;
    z-index: 10;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .hint-item {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.65rem;
    color: rgba(255, 255, 255, 0.8);
    white-space: nowrap;
    padding: 0.25rem 0.5rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    transition: all 0.2s ease;
  }

  .hint-item:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  .hint-item span:first-child {
    font-size: 0.75rem;
    opacity: 0.9;
  }

  .drop-zone-indicator {
    position: absolute;
    inset: 0;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(139, 69, 19, 0.2);
    border: 3px dashed rgba(139, 69, 19, 0.5);
    border-radius: 16px;
    z-index: 20;
    pointer-events: none;
  }

  .drop-zone-indicator span {
    font-size: 4rem;
    color: rgba(139, 69, 19, 0.7);
    animation: pulse 1.5s ease infinite;
  }

  .drop-zone-indicator p {
    margin-top: 1rem;
    font-size: 1.125rem;
    color: rgba(139, 69, 19, 0.8);
    font-weight: 500;
  }

  @keyframes pulse {
    0%,
    100% {
      transform: scale(1);
      opacity: 0.7;
    }
    50% {
      transform: scale(1.1);
      opacity: 1;
    }
  }

  .gramophone-wrapper.drag-over .drop-zone-indicator {
    display: flex;
  }

  @media (max-width: 768px) {
    .gramophone-wrapper {
      min-height: 400px;
    }

    .gramophone-canvas {
      min-height: 350px;
    }

    .gramophone-hints {
      flex-direction: column;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
    }
  }
</style>

<script>
  import * as THREE from 'three'

  interface Song {
    id: string
    name: string
    duration: string
    url: string
  }

  interface Album {
    id: string
    name: string
    description: string
    artist: string
    cover: string
    color: string
    songs: Song[]
  }

  document.addEventListener('astro:page-load', () => {
    const container = document.getElementById('gramophone-canvas')
    const wrapper = document.querySelector('.gramophone-wrapper')
    const playbackHint = document.getElementById('playback-hint')
    const volumeHint = document.getElementById('volume-hint')

    if (!container) return

    // 获取容器尺寸，确保有有效值
    const getContainerSize = () => {
      const width = container.clientWidth || 800
      const height = container.clientHeight || 500
      return { width, height }
    }

    const initialSize = getContainerSize()

    // 场景设置
    const scene = new THREE.Scene()
    scene.background = null

    // 相机设置 - 调整角度让留声机更好看
    const camera = new THREE.PerspectiveCamera(
      40,
      initialSize.width / initialSize.height,
      0.1,
      1000
    )
    camera.position.set(8, 8, 12)
    camera.lookAt(0, 1.5, 0)

    // 渲染器设置
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
    })
    renderer.setSize(initialSize.width, initialSize.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    renderer.toneMapping = THREE.ACESFilmicToneMapping
    renderer.toneMappingExposure = 1.2
    container.appendChild(renderer.domElement)

    // 光照设置
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6)
    scene.add(ambientLight)

    // 添加半球光，提供更自然的环境照明
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6)
    hemiLight.position.set(0, 20, 0)
    scene.add(hemiLight)

    const mainLight = new THREE.DirectionalLight(0xffffff, 1.0)
    mainLight.position.set(8, 12, 8)
    mainLight.castShadow = true
    mainLight.shadow.mapSize.width = 2048
    mainLight.shadow.mapSize.height = 2048
    mainLight.shadow.camera.near = 0.5
    mainLight.shadow.camera.far = 50
    scene.add(mainLight)

    const fillLight = new THREE.DirectionalLight(0xffd4a8, 0.4)
    fillLight.position.set(-5, 5, -5)
    scene.add(fillLight)

    const rimLight = new THREE.DirectionalLight(0xffffff, 0.3)
    rimLight.position.set(-8, 3, 8)
    scene.add(rimLight)

    // 材质定义
    const woodMaterial = new THREE.MeshStandardMaterial({
      color: 0x4a2511, // 深桃花心木色
      roughness: 0.5,
      metalness: 0.1,
    })

    const darkWoodMaterial = new THREE.MeshStandardMaterial({
      color: 0x2b1409, // 更深的木纹
      roughness: 0.6,
      metalness: 0.1,
    })

    // 银色/镀镍材质 (调整参数以适应无环境贴图场景)
    const nickelMaterial = new THREE.MeshStandardMaterial({
      color: 0xe0e0e0,
      roughness: 0.3,
      metalness: 0.6, // 降低金属度，避免在无环境贴图时变黑
    })

    // 做旧的银色
    const darkNickelMaterial = new THREE.MeshStandardMaterial({
      color: 0x888888,
      roughness: 0.5,
      metalness: 0.5,
    })

    // 黄铜材质 (保留给少部分装饰)
    const brassMaterial = new THREE.MeshStandardMaterial({
      color: 0xc9a227,
      roughness: 0.3,
      metalness: 0.8,
    })

    // 深色黄铜材质 (用于音量旋钮等装饰)
    const darkBrassMaterial = new THREE.MeshStandardMaterial({
      color: 0x8b7355,
      roughness: 0.4,
      metalness: 0.7,
    })

    const blackMetalMaterial = new THREE.MeshStandardMaterial({
      color: 0x111111,
      roughness: 0.4,
      metalness: 0.6,
    })

    const vinylMaterial = new THREE.MeshStandardMaterial({
      color: 0x0a0a0a,
      roughness: 0.15,
      metalness: 0.05,
    })

    const feltMaterial = new THREE.MeshStandardMaterial({
      color: 0x6b1c1c,
      roughness: 0.95,
      metalness: 0,
    })

    // 留声机主体
    const gramophoneGroup = new THREE.Group()

    // ==================== 1. 两层木质底座 (Victor 风格) ====================
    // 下层储物柜 (核心盒子)
    const lowerCabinetGeometry = new THREE.BoxGeometry(4.6, 2.2, 4.0)
    lowerCabinetGeometry.translate(0, 1.1, 0)
    const lowerCabinet = new THREE.Mesh(lowerCabinetGeometry, darkWoodMaterial) // 内部颜色更深
    lowerCabinet.castShadow = true
    lowerCabinet.receiveShadow = true
    gramophoneGroup.add(lowerCabinet)

    // 下层底部底座 (Base Plinth) - 更宽更厚
    const basePlinthGeometry = new THREE.BoxGeometry(5.4, 0.3, 4.8)
    const basePlinth = new THREE.Mesh(basePlinthGeometry, woodMaterial)
    basePlinth.position.y = 0.15
    // 底部边缘倒角效果 (简单的层叠)
    const basePlinth2Geometry = new THREE.BoxGeometry(5.2, 0.15, 4.6)
    const basePlinth2 = new THREE.Mesh(basePlinth2Geometry, woodMaterial)
    basePlinth2.position.y = 0.35
    gramophoneGroup.add(basePlinth)
    gramophoneGroup.add(basePlinth2)

    // 侧面装饰面板 (Recessed Panels)
    // 前后左右四个面的凸起边框
    const panelFrameThickness = 0.15
    const panelDepth = 0.05

    // 创建面板边框的函数
    const createPanelFrame = (width: number, height: number) => {
      const shape = new THREE.Shape()
      shape.moveTo(-width / 2, -height / 2)
      shape.lineTo(width / 2, -height / 2)
      shape.lineTo(width / 2, height / 2)
      shape.lineTo(-width / 2, height / 2)
      shape.lineTo(-width / 2, -height / 2)

      const hole = new THREE.Path()
      hole.moveTo(
        -(width / 2 - panelFrameThickness),
        -(height / 2 - panelFrameThickness)
      )
      hole.lineTo(
        width / 2 - panelFrameThickness,
        -(height / 2 - panelFrameThickness)
      )
      hole.lineTo(
        width / 2 - panelFrameThickness,
        height / 2 - panelFrameThickness
      )
      hole.lineTo(
        -(width / 2 - panelFrameThickness),
        height / 2 - panelFrameThickness
      )
      hole.lineTo(
        -(width / 2 - panelFrameThickness),
        -(height / 2 - panelFrameThickness)
      )
      shape.holes.push(hole)

      const geometry = new THREE.ExtrudeGeometry(shape, {
        depth: panelDepth,
        bevelEnabled: true,
        bevelSize: 0.02,
        bevelThickness: 0.02,
      })
      return new THREE.Mesh(geometry, woodMaterial)
    }

    // 前面板框
    const frontPanel = createPanelFrame(3.0, 1.2)
    frontPanel.position.set(0, 1.1, 2.0) // 突出于 cabinet
    gramophoneGroup.add(frontPanel)

    // 后面板框
    const backPanel = createPanelFrame(3.0, 1.2)
    backPanel.position.set(0, 1.1, -2.05) // 稍微调整位置避免重叠闪烁
    backPanel.rotation.y = Math.PI
    gramophoneGroup.add(backPanel)

    // 左面板框
    const leftPanel = createPanelFrame(3.0, 1.2)
    leftPanel.position.set(-2.3, 1.1, 0)
    leftPanel.rotation.y = -Math.PI / 2
    gramophoneGroup.add(leftPanel)

    // 右面板框
    const rightPanel = createPanelFrame(3.0, 1.2)
    rightPanel.position.set(2.3, 1.1, 0)
    rightPanel.rotation.y = Math.PI / 2
    gramophoneGroup.add(rightPanel)

    // 下层顶部装饰线条
    const midMoldingGeometry = new THREE.BoxGeometry(5.0, 0.15, 4.4)
    const midMolding = new THREE.Mesh(midMoldingGeometry, woodMaterial)
    midMolding.position.y = 2.2
    gramophoneGroup.add(midMolding)

    // 上层平台（放转盘的部分）
    const upperPlatformGeometry = new THREE.BoxGeometry(4.8, 0.6, 4.2)
    upperPlatformGeometry.translate(0, 2.6, 0)
    const upperPlatform = new THREE.Mesh(upperPlatformGeometry, woodMaterial)
    upperPlatform.castShadow = true
    gramophoneGroup.add(upperPlatform)

    // 上层顶部边框 (Top Molding)
    const topMoldingGeometry = new THREE.BoxGeometry(5.1, 0.15, 4.5)
    const topMolding = new THREE.Mesh(topMoldingGeometry, woodMaterial)
    topMolding.position.y = 2.9
    gramophoneGroup.add(topMolding)

    // 四角装饰柱 (Corner Pillars) - 图片中有明显的凹槽细节
    for (let x = -1; x <= 1; x += 2) {
      for (let z = -1; z <= 1; z += 2) {
        const pillarGroup = new THREE.Group()
        pillarGroup.position.set(x * 2.25, 1.1, z * 1.95)

        const pillarGeo = new THREE.BoxGeometry(0.35, 2.0, 0.35)
        const pillar = new THREE.Mesh(pillarGeo, woodMaterial)
        pillarGroup.add(pillar)

        // 柱子上的装饰纹路
        const detailGeo = new THREE.BoxGeometry(0.4, 0.1, 0.4)
        const detailTop = new THREE.Mesh(detailGeo, darkWoodMaterial)
        detailTop.position.y = 0.8
        pillarGroup.add(detailTop)

        const detailBottom = new THREE.Mesh(detailGeo, darkWoodMaterial)
        detailBottom.position.y = -0.8
        pillarGroup.add(detailBottom)

        gramophoneGroup.add(pillarGroup)
      }
    }

    // ==================== 2. 转盘 ====================
    // 转盘基座
    const turntableBaseGeometry = new THREE.CylinderGeometry(1.9, 1.9, 0.1, 64)
    const turntableBase = new THREE.Mesh(
      turntableBaseGeometry,
      blackMetalMaterial
    )
    turntableBase.position.set(0, 3.2, 0)
    gramophoneGroup.add(turntableBase)

    // 转盘金属边缘
    const turntableRimGeometry = new THREE.TorusGeometry(1.85, 0.05, 16, 64)
    const turntableRim = new THREE.Mesh(turntableRimGeometry, brassMaterial)
    turntableRim.rotation.x = Math.PI / 2
    turntableRim.position.set(0, 3.28, 0)
    gramophoneGroup.add(turntableRim)

    // 转盘
    const turntableGroup = new THREE.Group()
    turntableGroup.position.set(0, 3.28, 0)

    const turntableGeometry = new THREE.CylinderGeometry(1.75, 1.75, 0.06, 64)
    const turntable = new THREE.Mesh(turntableGeometry, blackMetalMaterial)
    turntableGroup.add(turntable)

    // 转盘绒布
    const feltGeometry = new THREE.CylinderGeometry(1.65, 1.65, 0.02, 64)
    const felt = new THREE.Mesh(feltGeometry, feltMaterial)
    felt.position.y = 0.04
    turntableGroup.add(felt)

    // 中心轴
    const spindleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 16)
    const spindle = new THREE.Mesh(spindleGeometry, brassMaterial)
    spindle.position.y = 0.18
    turntableGroup.add(spindle)

    gramophoneGroup.add(turntableGroup)

    // ==================== 3. 唱片 ====================
    const vinylGroup = new THREE.Group()
    vinylGroup.position.set(0, 3.35, 0)
    vinylGroup.visible = false

    const vinylGeometry = new THREE.CylinderGeometry(1.55, 1.55, 0.035, 64)
    const vinyl = new THREE.Mesh(vinylGeometry, vinylMaterial)
    vinylGroup.add(vinyl)

    // 唱片纹路
    for (let i = 0; i < 20; i++) {
      const radius = 0.35 + (1.1 * i) / 20
      const grooveGeometry = new THREE.TorusGeometry(radius, 0.002, 4, 64)
      const grooveMaterial = new THREE.MeshStandardMaterial({
        color: 0x151515,
        roughness: 0.4,
        metalness: 0.1,
      })
      const groove = new THREE.Mesh(grooveGeometry, grooveMaterial)
      groove.rotation.x = Math.PI / 2
      groove.position.y = 0.02
      vinylGroup.add(groove)
    }

    // 唱片中心标签 (金色/棕色)
    const labelGeometry = new THREE.CylinderGeometry(0.32, 0.32, 0.04, 32)
    const labelMaterial = new THREE.MeshStandardMaterial({
      color: 0xcd853f,
      roughness: 0.5,
    })
    const label = new THREE.Mesh(labelGeometry, labelMaterial)
    label.position.y = 0.02
    vinylGroup.add(label)

    // 中心孔
    const holeGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.05, 16)
    const hole = new THREE.Mesh(
      holeGeometry,
      new THREE.MeshStandardMaterial({ color: 0x050505 })
    )
    hole.position.y = 0.025
    vinylGroup.add(hole)

    gramophoneGroup.add(vinylGroup)

    // ==================== 4. 唱臂系统 ====================
    // 唱臂支架底座 - 精致的镀镍圆柱
    const armPillarGeometry = new THREE.CylinderGeometry(0.12, 0.16, 0.4, 24)
    const armPillar = new THREE.Mesh(armPillarGeometry, nickelMaterial)
    armPillar.position.set(1.6, 3.4, -1.0)
    armPillar.castShadow = true
    gramophoneGroup.add(armPillar)

    // 支架顶部装饰环
    const pillarCapGeometry = new THREE.TorusGeometry(0.14, 0.025, 12, 24)
    const pillarCap = new THREE.Mesh(pillarCapGeometry, brassMaterial)
    pillarCap.rotation.x = Math.PI / 2
    pillarCap.position.set(1.6, 3.62, -1.0)
    gramophoneGroup.add(pillarCap)

    // 唱臂旋转组
    const tonearmGroup = new THREE.Group()
    tonearmGroup.position.set(1.6, 3.65, -1.0)

    // 唱臂主杆 - 优雅的S形曲线
    const armCurve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(-0.3, 0.02, 0.1),
      new THREE.Vector3(-0.6, 0, 0.15),
      new THREE.Vector3(-0.85, -0.05, 0.2),
    ])
    const armGeometry = new THREE.TubeGeometry(armCurve, 32, 0.025, 16, false)
    const arm = new THREE.Mesh(armGeometry, nickelMaterial)
    arm.castShadow = true
    tonearmGroup.add(arm)

    // 唱头 - 更精致的设计
    const headshellGeometry = new THREE.BoxGeometry(0.08, 0.03, 0.12)
    const headshell = new THREE.Mesh(headshellGeometry, nickelMaterial)
    headshell.position.set(-0.9, -0.08, 0.22)
    headshell.rotation.z = -0.1
    tonearmGroup.add(headshell)

    // 唱针座
    const cartridgeGeometry = new THREE.BoxGeometry(0.05, 0.04, 0.06)
    const cartridge = new THREE.Mesh(cartridgeGeometry, darkNickelMaterial)
    cartridge.position.set(-0.9, -0.12, 0.22)
    tonearmGroup.add(cartridge)

    // 唱针 - 金色尖端
    const needleGeometry = new THREE.ConeGeometry(0.008, 0.06, 8)
    const needleMaterial = new THREE.MeshStandardMaterial({
      color: 0xffd700,
      roughness: 0.2,
      metalness: 0.9,
    })
    const needle = new THREE.Mesh(needleGeometry, needleMaterial)
    needle.rotation.x = Math.PI
    needle.position.set(-0.9, -0.17, 0.22)
    tonearmGroup.add(needle)

    // 配重块 - 唱臂后端
    const counterweightGeometry = new THREE.CylinderGeometry(
      0.06,
      0.06,
      0.1,
      16
    )
    const counterweight = new THREE.Mesh(
      counterweightGeometry,
      darkNickelMaterial
    )
    counterweight.rotation.z = Math.PI / 2
    counterweight.position.set(0.15, 0, 0)
    tonearmGroup.add(counterweight)

    gramophoneGroup.add(tonearmGroup)

    // ==================== 5. 音量调节（在底座正面） ====================
    const volumeKnobGroup = new THREE.Group()
    volumeKnobGroup.position.set(1.8, 1.1, 2.15)
    volumeKnobGroup.name = 'volumeKnob'

    // 旋钮底座
    const knobBaseGeometry = new THREE.CylinderGeometry(0.2, 0.22, 0.08, 24)
    const knobBase = new THREE.Mesh(knobBaseGeometry, darkBrassMaterial)
    knobBase.rotation.x = Math.PI / 2
    volumeKnobGroup.add(knobBase)

    // 旋钮主体
    const knobGeometry = new THREE.CylinderGeometry(0.16, 0.16, 0.12, 24)
    const knob = new THREE.Mesh(knobGeometry, brassMaterial)
    knob.rotation.x = Math.PI / 2
    knob.position.z = 0.08
    volumeKnobGroup.add(knob)

    // 旋钮指示线
    const indicatorGeometry = new THREE.BoxGeometry(0.03, 0.12, 0.02)
    const indicatorMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a1a1a,
    })
    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial)
    indicator.position.set(0, 0.06, 0.15)
    volumeKnobGroup.add(indicator)

    // 旋钮装饰纹路
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2
      const grooveGeometry = new THREE.BoxGeometry(0.012, 0.1, 0.015)
      const groove = new THREE.Mesh(grooveGeometry, darkBrassMaterial)
      groove.position.set(Math.sin(angle) * 0.14, Math.cos(angle) * 0.14, 0.1)
      volumeKnobGroup.add(groove)
    }

    gramophoneGroup.add(volumeKnobGroup)

    // 刻度标识 (0-180度)
    const scaleGroup = new THREE.Group()
    scaleGroup.position.set(1.8, 1.1, 2.12)

    const scaleRadius = 0.32
    const majorTicks = 5

    for (let i = 0; i <= majorTicks - 1; i++) {
      const majorAngle = -Math.PI / 2 + (i / (majorTicks - 1)) * Math.PI

      const majorTickGeometry = new THREE.BoxGeometry(0.06, 0.015, 0.015)
      const majorTick = new THREE.Mesh(majorTickGeometry, brassMaterial)
      majorTick.position.set(
        Math.sin(majorAngle) * scaleRadius,
        Math.cos(majorAngle) * scaleRadius,
        0
      )
      majorTick.rotation.z = majorAngle
      scaleGroup.add(majorTick)
    }

    gramophoneGroup.add(scaleGroup)

    // ==================== 7. 手摇把手 (侧面) ====================
    const crankGroup = new THREE.Group()
    crankGroup.position.set(2.45, 1.1, 0)

    const crankShaftGeometry = new THREE.CylinderGeometry(0.035, 0.035, 0.5, 12)
    const crankShaft = new THREE.Mesh(crankShaftGeometry, nickelMaterial) // 改为镍材质
    crankShaft.rotation.z = Math.PI / 2
    crankGroup.add(crankShaft)

    const crankArmGeometry = new THREE.CylinderGeometry(0.025, 0.025, 0.35, 8)
    const crankArm = new THREE.Mesh(crankArmGeometry, nickelMaterial) // 改为镍材质
    crankArm.position.set(0.3, 0.17, 0)
    crankGroup.add(crankArm)

    const crankHandleGeometry = new THREE.SphereGeometry(0.09, 16, 16)
    const crankHandle = new THREE.Mesh(crankHandleGeometry, woodMaterial) // 改为浅色木材
    crankHandle.position.set(0.3, 0.38, 0)
    crankGroup.add(crankHandle)

    gramophoneGroup.add(crankGroup)

    scene.add(gramophoneGroup)

    // ==================== 状态管理 ====================
    let isPlaying = false
    let currentAlbum: Album | null = null
    let currentSongIndex = 0
    let audioElement: HTMLAudioElement | null = null
    let volume = 0.7

    // 唱臂角度 - 调整为新的位置
    let tonearmAngle = 0.5
    const tonearmPlayAngle = 0.0
    const tonearmRestAngle = 0.5
    let isTonearmDown = false // 唱臂是否放下

    // 动画变量
    let vinylRotation = 0

    // 旋钮拖动状态 - 范围 0-180 度 (即 -π/2 到 π/2)
    let isDraggingKnob = false
    let knobRotation = 0.2 * Math.PI // 初始70%音量对应的角度 (0到π/2之间)

    // 3D 视角拖拽状态
    let isDraggingScene = false
    let previousMousePosition = { x: 0, y: 0 }
    let cameraTheta = Math.PI / 4 // 水平角度
    let cameraPhi = Math.PI / 6 // 垂直角度
    let cameraRadius = 16 // 相机距离
    const minZoom = 10
    const maxZoom = 25

    // ==================== 音量旋钮交互 ====================
    const raycaster = new THREE.Raycaster()
    const mouse = new THREE.Vector2()
    let lastMouseX = 0

    function updateVolumeFromKnob() {
      // 将旋钮角度转换为音量 (0-1)
      // 旋钮旋转范围: -π/2 到 π/2 (即 0 到 180 度)
      const normalizedAngle = (knobRotation + Math.PI / 2) / Math.PI
      volume = Math.max(0, Math.min(1, normalizedAngle))

      if (audioElement) {
        audioElement.volume = volume
      }

      // 旋钮在正面，绕 Z 轴旋转
      volumeKnobGroup.rotation.z = knobRotation
    }

    // 初始化旋钮位置
    updateVolumeFromKnob()

    // 更新相机位置的函数
    function updateCameraPosition() {
      camera.position.x =
        cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi)
      camera.position.y = cameraRadius * Math.sin(cameraPhi) + 2.5
      camera.position.z =
        cameraRadius * Math.cos(cameraTheta) * Math.cos(cameraPhi)
      camera.lookAt(0, 2, 0) // 看向底座中间偏上的位置
    }

    // 初始化相机位置
    updateCameraPosition()

    renderer.domElement.addEventListener('mousedown', (event) => {
      const rect = renderer.domElement.getBoundingClientRect()
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1

      raycaster.setFromCamera(mouse, camera)

      // 检查是否点击音量旋钮
      const knobIntersects = raycaster.intersectObjects(
        volumeKnobGroup.children,
        true
      )
      if (knobIntersects.length > 0) {
        isDraggingKnob = true
        lastMouseX = event.clientX
        if (volumeHint) volumeHint.style.opacity = '0'
        return
      }

      // 检查是否点击唱臂
      const armIntersects = raycaster.intersectObjects(
        tonearmGroup.children,
        true
      )
      if (armIntersects.length > 0) {
        toggleTonearm()
        if (playbackHint) playbackHint.style.opacity = '0'
        return
      }

      // 其他区域开始拖拽场景
      isDraggingScene = true
      previousMousePosition = { x: event.clientX, y: event.clientY }
      renderer.domElement.style.cursor = 'grabbing'
    })

    renderer.domElement.addEventListener('mousemove', (event) => {
      // 拖动音量旋钮
      if (isDraggingKnob) {
        const deltaX = event.clientX - lastMouseX
        knobRotation += deltaX * 0.02
        // 范围 -π/2 到 π/2 (0-180度)
        knobRotation = Math.max(
          -Math.PI / 2,
          Math.min(Math.PI / 2, knobRotation)
        )
        updateVolumeFromKnob()
        lastMouseX = event.clientX
        return
      }

      // 拖拽 3D 场景视角
      if (isDraggingScene) {
        const deltaX = event.clientX - previousMousePosition.x
        const deltaY = event.clientY - previousMousePosition.y

        cameraTheta -= deltaX * 0.005
        cameraPhi += deltaY * 0.005

        // 限制垂直角度
        cameraPhi = Math.max(0.1, Math.min(Math.PI / 2.5, cameraPhi))

        updateCameraPosition()
        previousMousePosition = { x: event.clientX, y: event.clientY }
        return
      }

      // 鼠标悬停检测
      const rect = renderer.domElement.getBoundingClientRect()
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1

      raycaster.setFromCamera(mouse, camera)

      const knobIntersects = raycaster.intersectObjects(
        volumeKnobGroup.children,
        true
      )
      const armIntersects = raycaster.intersectObjects(
        tonearmGroup.children,
        true
      )

      if (knobIntersects.length > 0 || armIntersects.length > 0) {
        renderer.domElement.style.cursor = 'pointer'
      } else {
        renderer.domElement.style.cursor = 'grab'
      }
    })

    renderer.domElement.addEventListener('mouseup', () => {
      isDraggingKnob = false
      isDraggingScene = false
      renderer.domElement.style.cursor = 'grab'
    })

    renderer.domElement.addEventListener('mouseleave', () => {
      isDraggingKnob = false
      isDraggingScene = false
      renderer.domElement.style.cursor = 'grab'
    })

    // 滚轮缩放
    renderer.domElement.addEventListener(
      'wheel',
      (e) => {
        e.preventDefault()
        const delta = e.deltaY > 0 ? 1 : -1
        cameraRadius = Math.max(
          minZoom,
          Math.min(maxZoom, cameraRadius + delta * 0.8)
        )
        updateCameraPosition()
      },
      { passive: false }
    )

    // 触摸屏缩放支持
    let touchStartDistance = 0
    let initialPinchRadius = cameraRadius

    renderer.domElement.addEventListener(
      'touchstart',
      (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX
          const dy = e.touches[0].clientY - e.touches[1].clientY
          touchStartDistance = Math.sqrt(dx * dx + dy * dy)
          initialPinchRadius = cameraRadius
        }
      },
      { passive: true }
    )

    renderer.domElement.addEventListener(
      'touchmove',
      (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX
          const dy = e.touches[0].clientY - e.touches[1].clientY
          const distance = Math.sqrt(dx * dx + dy * dy)
          const scale = touchStartDistance / distance
          cameraRadius = Math.max(
            minZoom,
            Math.min(maxZoom, initialPinchRadius * scale)
          )
          updateCameraPosition()
        }
      },
      { passive: true }
    )

    // ==================== 拖拽事件 ====================
    wrapper?.addEventListener('dragover', (e) => {
      e.preventDefault()
      wrapper.classList.add('drag-over')
    })

    wrapper?.addEventListener('dragleave', () => {
      wrapper.classList.remove('drag-over')
    })

    wrapper?.addEventListener('drop', (e) => {
      e.preventDefault()
      wrapper.classList.remove('drag-over')

      const event = e as DragEvent
      const albumData = event.dataTransfer?.getData('application/json')
      if (albumData) {
        const album = JSON.parse(albumData)
        loadAlbum(album)
      }
    })

    // ==================== 事件监听 ====================
    window.addEventListener('album-selected', ((e: CustomEvent) => {
      loadAlbum(e.detail)
    }) as EventListener)

    window.addEventListener('song-selected', ((e: CustomEvent) => {
      const { index } = e.detail
      playSong(index)
    }) as EventListener)

    window.addEventListener('seek-to', ((e: CustomEvent) => {
      if (audioElement && audioElement.duration) {
        audioElement.currentTime = audioElement.duration * e.detail
      }
    }) as EventListener)

    // ==================== 播放控制 ====================
    function loadAlbum(album: Album) {
      currentAlbum = album
      currentSongIndex = 0
      vinylGroup.visible = true

      labelMaterial.color.setStyle(album.color || '#8B4513')

      if (isPlaying) {
        stopPlayback()
      }

      animateVinylPlacement()
    }

    function playSong(index: number) {
      if (!currentAlbum || !currentAlbum.songs[index]) return

      currentSongIndex = index
      const song = currentAlbum.songs[index]

      if (!audioElement) {
        audioElement = new Audio()
        audioElement.addEventListener('ended', handleSongEnd)
        audioElement.addEventListener('timeupdate', handleTimeUpdate)
        audioElement.addEventListener('loadedmetadata', () => {
          window.dispatchEvent(
            new CustomEvent('playback-progress', {
              detail: {
                currentTime: 0,
                duration: audioElement?.duration || 0,
                songIndex: currentSongIndex,
              },
            })
          )
        })
      }

      audioElement.src = song.url
      audioElement.volume = volume

      // 只有当唱臂放下时才播放
      if (isTonearmDown) {
        audioElement.play()
        isPlaying = true
        window.dispatchEvent(
          new CustomEvent('playback-state', {
            detail: { isPlaying: true, songIndex: currentSongIndex },
          })
        )
      }
    }

    function startPlayback() {
      if (!currentAlbum) return

      isPlaying = true

      if (audioElement && audioElement.src) {
        audioElement.play()
      } else if (currentAlbum) {
        playSong(currentSongIndex)
        return
      }

      window.dispatchEvent(
        new CustomEvent('playback-state', {
          detail: { isPlaying: true, songIndex: currentSongIndex },
        })
      )
    }

    function stopPlayback() {
      isPlaying = false

      if (audioElement) {
        audioElement.pause()
      }

      window.dispatchEvent(
        new CustomEvent('playback-state', {
          detail: { isPlaying: false, songIndex: currentSongIndex },
        })
      )
    }

    // 唱臂放下/抬起控制
    function toggleTonearm() {
      if (!currentAlbum) return

      if (isTonearmDown) {
        // 抬起唱臂 - 停止播放
        isTonearmDown = false
        animateTonearm(tonearmRestAngle)
        stopPlayback()
      } else {
        // 放下唱臂 - 开始播放
        isTonearmDown = true
        animateTonearm(tonearmPlayAngle)
        startPlayback()
      }
    }

    function handleSongEnd() {
      if (!currentAlbum) return

      currentSongIndex++
      if (currentSongIndex < currentAlbum.songs.length) {
        playSong(currentSongIndex)
      } else {
        currentSongIndex = 0
        stopPlayback()
      }
    }

    function handleTimeUpdate() {
      if (!audioElement) return

      window.dispatchEvent(
        new CustomEvent('playback-progress', {
          detail: {
            currentTime: audioElement.currentTime,
            duration: audioElement.duration,
            songIndex: currentSongIndex,
          },
        })
      )
    }

    // ==================== 动画 ====================
    function animateVinylPlacement() {
      vinylGroup.position.y = 5.5
      vinylGroup.scale.set(0.3, 0.3, 0.3)
      vinylGroup.rotation.x = 0.3

      const animate = () => {
        const targetY = 3.35 // 新的转盘高度
        const diff = vinylGroup.position.y - targetY

        if (Math.abs(diff) > 0.01) {
          vinylGroup.position.y -= diff * 0.08

          const scale = vinylGroup.scale.x
          if (scale < 1) {
            const newScale = scale + (1 - scale) * 0.08
            vinylGroup.scale.set(newScale, newScale, newScale)
          }

          if (vinylGroup.rotation.x > 0.01) {
            vinylGroup.rotation.x *= 0.9
          }

          requestAnimationFrame(animate)
        } else {
          vinylGroup.position.y = targetY
          vinylGroup.scale.set(1, 1, 1)
          vinylGroup.rotation.x = 0
        }
      }
      animate()
    }

    function animateTonearm(targetAngle: number) {
      const animate = () => {
        const diff = targetAngle - tonearmAngle
        if (Math.abs(diff) > 0.005) {
          tonearmAngle += diff * 0.08
          tonearmGroup.rotation.y = tonearmAngle
          requestAnimationFrame(animate)
        } else {
          tonearmAngle = targetAngle
          tonearmGroup.rotation.y = targetAngle
        }
      }
      animate()
    }

    // ==================== 渲染循环 ====================
    function animate() {
      requestAnimationFrame(animate)

      // 唱片旋转 - 只有当唱臂放下并且正在播放时
      if (isPlaying && isTonearmDown && vinylGroup.visible) {
        vinylRotation += 0.015
        vinylGroup.rotation.y = vinylRotation
        turntableGroup.rotation.y = vinylRotation
      }

      renderer.render(scene, camera)
    }

    animate()

    // ==================== 响应式 ====================
    function handleResize() {
      if (!container) return

      const size = getContainerSize()
      camera.aspect = size.width / size.height
      camera.updateProjectionMatrix()
      renderer.setSize(size.width, size.height)
    }

    window.addEventListener('resize', handleResize)

    // 延迟执行一次 resize 以确保容器尺寸正确
    setTimeout(handleResize, 100)

    // 清理
    window.addEventListener('beforeunload', () => {
      if (audioElement) {
        audioElement.pause()
        audioElement = null
      }
    })
  })
</script>
