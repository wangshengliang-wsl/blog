---
import '~/styles/music.css'
---

<div class="gramophone-wrapper">
  <div id="gramophone-canvas" class="gramophone-canvas"></div>

  <!-- 提示信息 -->
  <div class="gramophone-hints">
    <div class="hint-item">
      <span class="i-ri-hand-coin-line"></span>
      <span>点击唱臂播放</span>
    </div>
    <div class="hint-item">
      <span class="i-ri-drag-move-line"></span>
      <span>拖拽旋转视角</span>
    </div>
    <div class="hint-item">
      <span class="i-ri-zoom-in-line"></span>
      <span>滚轮缩放</span>
    </div>
  </div>
</div>

<style>
  .gramophone-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .gramophone-canvas {
    width: 100%;
    height: 100%;
    border-radius: 16px;
    overflow: hidden;
  }

  .gramophone-hints {
    position: absolute;
    top: 0.75rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(8px);
    border-radius: 20px;
    z-index: 10;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .hint-item {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.65rem;
    color: rgba(255, 255, 255, 0.8);
    white-space: nowrap;
    padding: 0.25rem 0.5rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    transition: all 0.2s ease;
  }

  .hint-item:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  .hint-item span:first-child {
    font-size: 0.75rem;
    opacity: 0.9;
  }

  @media (max-width: 768px) {
    .gramophone-wrapper {
      min-height: 400px;
    }

    .gramophone-canvas {
      min-height: 350px;
    }

    .gramophone-hints {
      flex-direction: column;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
    }
  }
</style>

<script>
  import * as THREE from 'three'

  interface Song {
    id: string
    name: string
    url: string
  }

  interface Album {
    id: string
    name: string
    description: string
    artist: string
    cover: string
    color: string
    songs: Song[]
  }

  document.addEventListener('astro:page-load', () => {
    const container = document.getElementById('gramophone-canvas')

    if (!container) return

    // Check if already initialized
    if (container.dataset.initialized === 'true') return
    container.dataset.initialized = 'true'

    // Get container size
    const getContainerSize = () => {
      const width = container.clientWidth || 800
      const height = container.clientHeight || 500
      return { width, height }
    }

    const initialSize = getContainerSize()

    // Helper function to get theme background color
    const getThemeBackgroundColor = () => {
      const isDark = document.documentElement.classList.contains('dark')
      // Return appropriate background color based on theme
      return isDark ? 0x1a1a1a : 0xf5f5f5
    }

    // Procedural Textures
    const createVinylTexture = () => {
      const size = 2048
      const canvas = document.createElement('canvas')
      canvas.width = size
      canvas.height = size
      const ctx = canvas.getContext('2d')
      if (!ctx) return null

      const centerX = size / 2
      const centerY = size / 2

      // Background - Deep black for vinyl
      ctx.fillStyle = '#020202'
      ctx.fillRect(0, 0, size, size)

      // Draw grooves
      // Simulating Fresnel/Anisotropic bands with gradients
      // More subtle gradients for realistic vinyl look
      const gradient = ctx.createRadialGradient(
        centerX,
        centerY,
        280,
        centerX,
        centerY,
        960
      )
      gradient.addColorStop(0, '#020202')
      gradient.addColorStop(0.2, '#080808')
      gradient.addColorStop(0.4, '#020202')
      gradient.addColorStop(0.6, '#080808')
      gradient.addColorStop(0.8, '#020202')
      gradient.addColorStop(1, '#050505')

      ctx.fillStyle = gradient
      ctx.beginPath()
      ctx.arc(centerX, centerY, 960, 0, Math.PI * 2)
      ctx.arc(centerX, centerY, 280, 0, Math.PI * 2, true) // hole
      ctx.fill()

      // Fine grooves - denser and more subtle
      ctx.globalAlpha = 0.15
      for (let r = 280; r < 960; r += 0.8) {
        // Track gaps
        if (Math.random() < 0.002) r += 8

        const intensity = Math.random() * 0.1 + 0.02
        ctx.strokeStyle = `rgba(255, 255, 255, ${intensity})`
        ctx.lineWidth = 0.5
        ctx.beginPath()
        ctx.arc(centerX, centerY, r, 0, Math.PI * 2)
        ctx.stroke()
      }
      ctx.globalAlpha = 1.0

      // Add a label border
      ctx.strokeStyle = '#111'
      ctx.lineWidth = 2
      ctx.beginPath()
      ctx.arc(centerX, centerY, 280, 0, Math.PI * 2)
      ctx.stroke()

      const texture = new THREE.CanvasTexture(canvas)
      texture.colorSpace = THREE.SRGBColorSpace
      // Anisotropy filtering for sharper angles
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
      return texture
    }

    const createBrushedMetalTexture = (color = '#d0d0d0') => {
      const canvas = document.createElement('canvas')
      canvas.width = 512
      canvas.height = 512
      const ctx = canvas.getContext('2d')
      if (!ctx) return null

      ctx.fillStyle = color
      ctx.fillRect(0, 0, 512, 512)

      // Add noise/scratches
      for (let i = 0; i < 20000; i++) {
        const x = Math.random() * 512
        const y = Math.random() * 512
        const len = Math.random() * 40 + 10
        const opacity = Math.random() * 0.05

        ctx.strokeStyle = `rgba(0, 0, 0, ${opacity})`
        ctx.lineWidth = 1
        ctx.beginPath()
        ctx.moveTo(x, y)
        ctx.lineTo(x + len, y) // Horizontal scratches
        ctx.stroke()
      }

      const texture = new THREE.CanvasTexture(canvas)
      texture.colorSpace = THREE.SRGBColorSpace
      return texture
    }

    // Scene setup
    const scene = new THREE.Scene()
    scene.background = new THREE.Color(getThemeBackgroundColor())

    // Camera - top-down 45 degree view
    const camera = new THREE.PerspectiveCamera(
      45,
      initialSize.width / initialSize.height,
      0.1,
      1000
    )

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: false,
    })
    renderer.setSize(initialSize.width, initialSize.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    renderer.toneMapping = THREE.ACESFilmicToneMapping
    renderer.toneMappingExposure = 1.4
    renderer.outputColorSpace = THREE.SRGBColorSpace
    container.appendChild(renderer.domElement)

    // ==================== Lighting ====================
    // Ambient light - general illumination
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3)
    scene.add(ambientLight)

    // Main spotlight from above (creates vinyl reflection)
    const spotLight = new THREE.SpotLight(0xffffff, 80)
    spotLight.position.set(0, 12, 0)
    spotLight.angle = Math.PI / 4
    spotLight.penumbra = 0.5
    spotLight.decay = 1.2
    spotLight.distance = 30
    spotLight.castShadow = true
    spotLight.shadow.mapSize.width = 2048
    spotLight.shadow.mapSize.height = 2048
    spotLight.shadow.bias = -0.0001
    scene.add(spotLight)
    scene.add(spotLight.target)

    // Warm highlight light
    const warmLight = new THREE.PointLight(0xffaa00, 20, 20)
    warmLight.position.set(-3, 2, 3)
    scene.add(warmLight)

    // Cool highlight light
    const coolLight = new THREE.PointLight(0x00aaff, 20, 20)
    coolLight.position.set(3, 2, -3)
    scene.add(coolLight)

    // Rim light for metallic edges
    const rimLight = new THREE.DirectionalLight(0xffffff, 1.5)
    rimLight.position.set(0, 5, -10)
    scene.add(rimLight)

    // ==================== Materials ====================
    const vinylTexture = createVinylTexture()
    const brushedMetalTexture = createBrushedMetalTexture()

    // Matte black material for turntable body
    const matteBlackMaterial = new THREE.MeshStandardMaterial({
      color: 0x151515,
      roughness: 0.6,
      metalness: 0.2,
    })

    // Brushed aluminum material
    const aluminumMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      map: brushedMetalTexture,
      roughness: 0.25,
      metalness: 0.8,
    })

    // Chrome/polished metal material
    const chromeMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.05,
      metalness: 0.95,
    })

    // Rubber mat material
    const rubberMaterial = new THREE.MeshStandardMaterial({
      color: 0x202020,
      roughness: 0.9,
      metalness: 0.05,
    })

    // Vinyl material with texture
    const vinylMaterial = new THREE.MeshStandardMaterial({
      color: 0x080808,
      map: vinylTexture,
      bumpMap: vinylTexture,
      bumpScale: 0.02,
      roughness: 0.4,
      metalness: 0.6,
    })

    // Red LED indicator
    const ledMaterial = new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 0.5,
      roughness: 0.3,
      metalness: 0.1,
    })

    // Turntable group
    const turntableGroup = new THREE.Group()

    // ==================== Base/Plinth ====================
    // Main base - sleek rectangular with rounded edges
    const baseShape = new THREE.Shape()
    const baseWidth = 6
    const baseDepth = 5
    const cornerRadius = 0.3

    baseShape.moveTo(-baseWidth / 2 + cornerRadius, -baseDepth / 2)
    baseShape.lineTo(baseWidth / 2 - cornerRadius, -baseDepth / 2)
    baseShape.quadraticCurveTo(
      baseWidth / 2,
      -baseDepth / 2,
      baseWidth / 2,
      -baseDepth / 2 + cornerRadius
    )
    baseShape.lineTo(baseWidth / 2, baseDepth / 2 - cornerRadius)
    baseShape.quadraticCurveTo(
      baseWidth / 2,
      baseDepth / 2,
      baseWidth / 2 - cornerRadius,
      baseDepth / 2
    )
    baseShape.lineTo(-baseWidth / 2 + cornerRadius, baseDepth / 2)
    baseShape.quadraticCurveTo(
      -baseWidth / 2,
      baseDepth / 2,
      -baseWidth / 2,
      baseDepth / 2 - cornerRadius
    )
    baseShape.lineTo(-baseWidth / 2, -baseDepth / 2 + cornerRadius)
    baseShape.quadraticCurveTo(
      -baseWidth / 2,
      -baseDepth / 2,
      -baseWidth / 2 + cornerRadius,
      -baseDepth / 2
    )

    const baseExtrudeSettings = {
      depth: 0.4,
      bevelEnabled: true,
      bevelThickness: 0.05,
      bevelSize: 0.05,
      bevelSegments: 3,
    }

    const baseGeometry = new THREE.ExtrudeGeometry(
      baseShape,
      baseExtrudeSettings
    )
    baseGeometry.rotateX(-Math.PI / 2)
    const baseMesh = new THREE.Mesh(baseGeometry, matteBlackMaterial)
    baseMesh.position.y = 0
    baseMesh.receiveShadow = true
    baseMesh.castShadow = true
    turntableGroup.add(baseMesh)

    // Feet (isolators)
    const footGeometry = new THREE.CylinderGeometry(0.2, 0.25, 0.15, 24)
    const footPositions = [
      [-2.5, -0.075, -2],
      [2.5, -0.075, -2],
      [-2.5, -0.075, 2],
      [2.5, -0.075, 2],
    ]

    footPositions.forEach((pos) => {
      const foot = new THREE.Mesh(footGeometry, rubberMaterial)
      foot.position.set(pos[0], pos[1], pos[2])
      turntableGroup.add(foot)
    })

    // ==================== Platter ====================
    // Platter base ring
    const platterRingGeometry = new THREE.TorusGeometry(2.1, 0.08, 16, 64)
    const platterRing = new THREE.Mesh(platterRingGeometry, aluminumMaterial)
    platterRing.rotation.x = Math.PI / 2
    platterRing.position.set(-0.3, 0.5, 0)
    turntableGroup.add(platterRing)

    // Main platter (rotating part)
    const platterGroup = new THREE.Group()
    platterGroup.position.set(-0.3, 0.55, 0)

    // Platter disc
    const platterGeometry = new THREE.CylinderGeometry(2, 2, 0.1, 64)
    const platter = new THREE.Mesh(platterGeometry, aluminumMaterial)
    platter.castShadow = true
    platter.receiveShadow = true
    platterGroup.add(platter)

    // Rubber mat on platter
    const matGeometry = new THREE.CylinderGeometry(1.9, 1.9, 0.03, 64)
    const mat = new THREE.Mesh(matGeometry, rubberMaterial)
    mat.position.y = 0.065
    platterGroup.add(mat)

    // Spindle
    const spindleGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.3, 16)
    const spindle = new THREE.Mesh(spindleGeometry, chromeMaterial)
    spindle.position.y = 0.2
    platterGroup.add(spindle)

    // Strobe dots around platter edge
    const strobeDotCount = 60
    for (let i = 0; i < strobeDotCount; i++) {
      const angle = (i / strobeDotCount) * Math.PI * 2
      const dotGeometry = new THREE.CircleGeometry(0.02, 8)
      const dotMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff })
      const dot = new THREE.Mesh(dotGeometry, dotMaterial)
      dot.rotation.x = -Math.PI / 2
      dot.position.set(Math.cos(angle) * 1.95, 0.06, Math.sin(angle) * 1.95)
      platterGroup.add(dot)
    }

    turntableGroup.add(platterGroup)

    // ==================== Vinyl Record ====================
    const vinylGroup = new THREE.Group()
    vinylGroup.position.set(-0.3, 0.65, 0)
    vinylGroup.visible = false

    // Main vinyl disc
    const vinylGeometry = new THREE.CylinderGeometry(1.75, 1.75, 0.025, 128)
    const vinyl = new THREE.Mesh(vinylGeometry, vinylMaterial)
    vinyl.castShadow = true
    vinyl.receiveShadow = true
    vinylGroup.add(vinyl)

    // Texture loader for album cover
    const textureLoader = new THREE.TextureLoader()

    // Cover image - full size covering the entire vinyl
    const coverGeometry = new THREE.CircleGeometry(1.72, 128)
    const coverMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.3,
      metalness: 0.1,
      transparent: true,
      opacity: 1,
    })
    const coverMesh = new THREE.Mesh(coverGeometry, coverMaterial)
    coverMesh.rotation.x = -Math.PI / 2
    coverMesh.position.y = 0.014
    vinylGroup.add(coverMesh)

    // Vinyl edge ring for visual effect
    const edgeRingGeometry = new THREE.TorusGeometry(1.73, 0.02, 16, 128)
    const edgeRingMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a1a1a,
      roughness: 0.2,
      metalness: 0.6,
    })
    const edgeRing = new THREE.Mesh(edgeRingGeometry, edgeRingMaterial)
    edgeRing.rotation.x = Math.PI / 2
    edgeRing.position.y = 0.013
    vinylGroup.add(edgeRing)

    // Function to update cover image
    function updateCoverImage(coverUrl: string) {
      textureLoader.load(
        coverUrl,
        (texture) => {
          texture.colorSpace = THREE.SRGBColorSpace
          coverMaterial.map = texture
          coverMaterial.needsUpdate = true
        },
        undefined,
        () => {
          // Error loading texture - use fallback color
          coverMaterial.map = null
          coverMaterial.color.setHex(0xcd853f)
          coverMaterial.needsUpdate = true
        }
      )
    }

    turntableGroup.add(vinylGroup)

    // ==================== Tonearm ====================
    // Tonearm base/pivot
    const armBaseGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.35, 32)
    const armBase = new THREE.Mesh(armBaseGeometry, aluminumMaterial)
    armBase.position.set(2.2, 0.57, -1.5)
    armBase.castShadow = true
    turntableGroup.add(armBase)

    // Tonearm pivot cap
    const pivotCapGeometry = new THREE.CylinderGeometry(0.18, 0.2, 0.08, 24)
    const pivotCap = new THREE.Mesh(pivotCapGeometry, chromeMaterial)
    pivotCap.position.set(2.2, 0.78, -1.5)
    turntableGroup.add(pivotCap)

    // Tonearm rotating group
    const tonearmGroup = new THREE.Group()
    tonearmGroup.position.set(2.2, 0.85, -1.5)

    // Gimbal joint (connecting pivot to arm) - New Component
    const gimbalGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.25)
    const gimbal = new THREE.Mesh(gimbalGeometry, matteBlackMaterial)
    gimbal.position.set(0, -0.02, 0)
    // Add some mechanical details to gimbal
    const gimbalRingGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.3, 16)
    gimbalRingGeo.rotateX(Math.PI / 2)
    const gimbalRing = new THREE.Mesh(gimbalRingGeo, chromeMaterial)
    gimbal.add(gimbalRing)
    tonearmGroup.add(gimbal)

    // Tonearm hitbox (invisible, larger for easier clicking)
    const hitboxGeometry = new THREE.BoxGeometry(2.8, 0.5, 0.6)
    const hitboxMaterial = new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 0,
      depthWrite: false,
    })
    const tonearmHitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial)
    tonearmHitbox.position.set(-1.1, 0, 0.2)
    tonearmHitbox.name = 'tonearmHitbox'
    tonearmGroup.add(tonearmHitbox)

    // Arm rest
    const armRestGeometry = new THREE.BoxGeometry(0.15, 0.2, 0.08)
    const armRest = new THREE.Mesh(armRestGeometry, aluminumMaterial)
    armRest.position.set(0.3, -0.05, 0.5)
    tonearmGroup.add(armRest)

    // Main arm tube (S-curve design) - smoother and better looking
    const armCurve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(-0.4, 0.05, 0.15),
      new THREE.Vector3(-1.2, 0.02, 0.3),
      new THREE.Vector3(-1.9, -0.04, 0.38),
      new THREE.Vector3(-2.25, -0.08, 0.42),
    ])
    const armTubeGeometry = new THREE.TubeGeometry(
      armCurve,
      64,
      0.045,
      16,
      false
    )
    const armTube = new THREE.Mesh(armTubeGeometry, chromeMaterial)
    armTube.castShadow = true
    tonearmGroup.add(armTube)

    // Headshell - Sleek design
    const headshellGroup = new THREE.Group()
    headshellGroup.position.set(-2.25, -0.08, 0.42)
    headshellGroup.rotation.z = -0.1
    headshellGroup.rotation.y = 0.2

    // Main flat part with rounded edges look
    const headshellShape = new THREE.Shape()
    headshellShape.moveTo(0, -0.09)
    headshellShape.lineTo(0.35, -0.07)
    headshellShape.lineTo(0.35, 0.07)
    headshellShape.lineTo(0, 0.09)
    headshellShape.lineTo(-0.05, 0)

    const headshellGeo = new THREE.ExtrudeGeometry(headshellShape, {
      depth: 0.02,
      bevelEnabled: true,
      bevelThickness: 0.01,
      bevelSize: 0.01,
      bevelSegments: 2,
    })
    headshellGeo.rotateX(-Math.PI / 2) // Flatten it

    const headshellMesh = new THREE.Mesh(headshellGeo, matteBlackMaterial)
    headshellMesh.position.y = 0.02
    headshellGroup.add(headshellMesh)

    // Finger lift - curved handle
    const fingerLiftCurve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(0.2, 0.02, 0.08),
      new THREE.Vector3(0.25, 0.05, 0.08),
      new THREE.Vector3(0.3, 0.06, 0.08),
    ])
    const fingerLiftGeo = new THREE.TubeGeometry(
      fingerLiftCurve,
      8,
      0.008,
      8,
      false
    )
    const fingerLift = new THREE.Mesh(fingerLiftGeo, chromeMaterial)
    headshellGroup.add(fingerLift)

    tonearmGroup.add(headshellGroup)

    // Cartridge - attached under headshell
    const cartridgeGeometry = new THREE.BoxGeometry(0.1, 0.12, 0.08)
    const cartridgeMaterial = new THREE.MeshStandardMaterial({
      color: 0x8b0000, // Deep red
      roughness: 0.2,
      metalness: 0.4,
    })
    const cartridge = new THREE.Mesh(cartridgeGeometry, cartridgeMaterial)
    cartridge.position.set(0.15, -0.06, 0)
    headshellGroup.add(cartridge)

    // Stylus/Needle - Larger and more visible
    const needleGeometry = new THREE.ConeGeometry(0.03, 0.12, 16)
    const needleMaterial = new THREE.MeshStandardMaterial({
      color: 0xffd700, // Gold
      roughness: 0.1,
      metalness: 1.0,
      emissive: 0x333300, // Slight glow to be visible against black vinyl
      emissiveIntensity: 0.2,
    })
    const needle = new THREE.Mesh(needleGeometry, needleMaterial)
    needle.rotation.x = Math.PI
    needle.position.set(0.15, -0.13, 0)
    headshellGroup.add(needle)

    // Counterweight - detailed
    const counterweightGroup = new THREE.Group()
    counterweightGroup.position.set(0.4, 0, 0)

    const cwMainGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 32)
    const cwMain = new THREE.Mesh(cwMainGeo, chromeMaterial)
    cwMain.rotation.z = Math.PI / 2
    counterweightGroup.add(cwMain)

    // Scale ring on counterweight
    const cwRingGeo = new THREE.CylinderGeometry(0.152, 0.152, 0.05, 32)
    const cwRing = new THREE.Mesh(cwRingGeo, matteBlackMaterial)
    cwRing.rotation.z = Math.PI / 2
    cwRing.position.set(-0.08, 0, 0)
    counterweightGroup.add(cwRing)

    tonearmGroup.add(counterweightGroup)

    // Anti-skate weight
    const antiSkateGeometry = new THREE.SphereGeometry(0.04, 16, 16)
    const antiSkate = new THREE.Mesh(antiSkateGeometry, chromeMaterial)
    antiSkate.position.set(0.15, 0.08, 0.15)
    tonearmGroup.add(antiSkate)

    // Set tonearm to rest position
    tonearmGroup.rotation.y = 0.9

    turntableGroup.add(tonearmGroup)

    // ==================== Controls ====================
    // Start/Stop button
    const buttonBaseGeometry = new THREE.CylinderGeometry(0.2, 0.22, 0.06, 24)
    const buttonBase = new THREE.Mesh(buttonBaseGeometry, aluminumMaterial)
    buttonBase.position.set(2.2, 0.43, 1.8)
    turntableGroup.add(buttonBase)

    const buttonGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.04, 24)
    const buttonMaterial = new THREE.MeshStandardMaterial({
      color: 0x333333,
      roughness: 0.3,
      metalness: 0.2,
    })
    const button = new THREE.Mesh(buttonGeometry, buttonMaterial)
    button.position.set(2.2, 0.48, 1.8)
    turntableGroup.add(button)

    // Speed selector (33/45 RPM)
    const speedSelectorGeometry = new THREE.CylinderGeometry(
      0.15,
      0.15,
      0.05,
      24
    )
    const speedSelector = new THREE.Mesh(
      speedSelectorGeometry,
      aluminumMaterial
    )
    speedSelector.position.set(1.5, 0.45, 1.8)
    turntableGroup.add(speedSelector)

    // Volume knob
    const volumeKnobGroup = new THREE.Group()
    volumeKnobGroup.position.set(2.5, 0.48, 0.8)
    volumeKnobGroup.name = 'volumeKnob'

    const knobBaseGeometry = new THREE.CylinderGeometry(0.18, 0.2, 0.06, 32)
    const knobBase = new THREE.Mesh(knobBaseGeometry, aluminumMaterial)
    volumeKnobGroup.add(knobBase)

    const knobGeometry = new THREE.CylinderGeometry(0.14, 0.14, 0.08, 32)
    const knob = new THREE.Mesh(
      knobGeometry,
      new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.3,
        metalness: 0.2,
      })
    )
    knob.position.y = 0.06
    volumeKnobGroup.add(knob)

    // Knob indicator line
    const indicatorGeometry = new THREE.BoxGeometry(0.02, 0.08, 0.02)
    const indicatorMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
    })
    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial)
    indicator.position.set(0, 0.1, 0.1)
    volumeKnobGroup.add(indicator)

    // Knob grip lines
    for (let i = 0; i < 16; i++) {
      const angle = (i / 16) * Math.PI * 2
      const gripGeometry = new THREE.BoxGeometry(0.008, 0.06, 0.01)
      const grip = new THREE.Mesh(
        gripGeometry,
        new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
      )
      grip.position.set(Math.sin(angle) * 0.12, 0.06, Math.cos(angle) * 0.12)
      grip.rotation.y = angle
      volumeKnobGroup.add(grip)
    }

    turntableGroup.add(volumeKnobGroup)

    // LED power indicator
    const ledGeometry = new THREE.SphereGeometry(0.03, 16, 16)
    const led = new THREE.Mesh(ledGeometry, ledMaterial)
    led.position.set(2.5, 0.45, 1.3)
    turntableGroup.add(led)

    // Brand logo area (simple rectangle)
    const logoGeometry = new THREE.BoxGeometry(0.8, 0.01, 0.15)
    const logoMaterial = new THREE.MeshStandardMaterial({
      color: 0x3a3a3a,
      roughness: 0.5,
      metalness: 0.3,
    })
    const logo = new THREE.Mesh(logoGeometry, logoMaterial)
    logo.position.set(-2.4, 0.41, 1.8)
    turntableGroup.add(logo)

    scene.add(turntableGroup)

    // ==================== State Management ====================
    let isPlaying = false
    let currentAlbum: Album | null = null
    let currentSongIndex = 0
    let audioElement: HTMLAudioElement | null = null
    let volume = 0.7
    let currentPlaybackRate = 1.0

    // Tonearm angles - two fixed positions only
    let tonearmAngle = 0.9
    const tonearmPlayAngle = -0.2 // Fixed position on vinyl edge when playing
    const tonearmRestAngle = 0.9 // Rest position outside vinyl
    let isTonearmDown = false

    // Animation variables
    let vinylRotation = 0

    // Knob state - FIXED: reversed direction
    let isDraggingKnob = false
    let knobRotation = -0.7 * Math.PI // Initial 70% volume
    const knobMinRotation = -Math.PI // 0% volume (full left)
    const knobMaxRotation = 0 // 100% volume (full right)

    // 3D view dragging
    let isDraggingScene = false
    let previousMousePosition = { x: 0, y: 0 }
    let cameraTheta = 0 // Horizontal angle - start facing front
    let cameraPhi = Math.PI / 4 // Vertical angle - 45 degrees from above
    let cameraRadius = 12
    const minZoom = 8
    const maxZoom = 20

    // ==================== Volume Knob Interaction ====================
    const raycaster = new THREE.Raycaster()
    const mouse = new THREE.Vector2()
    let lastMouseX = 0

    function updateVolumeFromKnob() {
      // Convert knob rotation to volume (0-1)
      // knobMinRotation (-π) = 0%, knobMaxRotation (0) = 100%
      const normalizedAngle =
        (knobRotation - knobMinRotation) / (knobMaxRotation - knobMinRotation)
      volume = Math.max(0, Math.min(1, normalizedAngle))

      if (audioElement) {
        audioElement.volume = volume
      }

      // Rotate the indicator around Y axis
      volumeKnobGroup.rotation.y = knobRotation
    }

    // Initialize knob position
    updateVolumeFromKnob()

    // Update camera position
    function updateCameraPosition() {
      camera.position.x =
        cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi)
      camera.position.y = cameraRadius * Math.sin(cameraPhi) + 1
      camera.position.z =
        cameraRadius * Math.cos(cameraTheta) * Math.cos(cameraPhi)
      camera.lookAt(0, 0.3, 0)
    }

    // Initialize camera position
    updateCameraPosition()

    renderer.domElement.addEventListener('mousedown', (event) => {
      const rect = renderer.domElement.getBoundingClientRect()
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1

      raycaster.setFromCamera(mouse, camera)

      // Check volume knob click
      const knobIntersects = raycaster.intersectObjects(
        volumeKnobGroup.children,
        true
      )
      if (knobIntersects.length > 0) {
        isDraggingKnob = true
        lastMouseX = event.clientX
        return
      }

      // Check tonearm click (using hitbox for larger area)
      const tonearmObjects = tonearmGroup.children
      const armIntersects = raycaster.intersectObjects(tonearmObjects, true)
      if (armIntersects.length > 0) {
        toggleTonearm()
        return
      }

      // Start scene dragging
      isDraggingScene = true
      previousMousePosition = { x: event.clientX, y: event.clientY }
      renderer.domElement.style.cursor = 'grabbing'
    })

    renderer.domElement.addEventListener('mousemove', (event) => {
      // Drag volume knob
      if (isDraggingKnob) {
        const deltaX = event.clientX - lastMouseX
        // FIXED: changed sign to fix reversed direction
        knobRotation += deltaX * 0.02
        knobRotation = Math.max(
          knobMinRotation,
          Math.min(knobMaxRotation, knobRotation)
        )
        updateVolumeFromKnob()
        lastMouseX = event.clientX
        return
      }

      // Drag 3D scene
      if (isDraggingScene) {
        const deltaX = event.clientX - previousMousePosition.x
        const deltaY = event.clientY - previousMousePosition.y

        cameraTheta -= deltaX * 0.005
        cameraPhi += deltaY * 0.005

        // Limit vertical angle
        cameraPhi = Math.max(0.2, Math.min(Math.PI / 2.2, cameraPhi))

        updateCameraPosition()
        previousMousePosition = { x: event.clientX, y: event.clientY }
        return
      }

      // Hover detection
      const rect = renderer.domElement.getBoundingClientRect()
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1

      raycaster.setFromCamera(mouse, camera)

      const knobIntersects = raycaster.intersectObjects(
        volumeKnobGroup.children,
        true
      )
      const armIntersects = raycaster.intersectObjects(
        tonearmGroup.children,
        true
      )

      if (knobIntersects.length > 0 || armIntersects.length > 0) {
        renderer.domElement.style.cursor = 'pointer'
      } else {
        renderer.domElement.style.cursor = 'grab'
      }
    })

    renderer.domElement.addEventListener('mouseup', () => {
      isDraggingKnob = false
      isDraggingScene = false
      renderer.domElement.style.cursor = 'grab'
    })

    renderer.domElement.addEventListener('mouseleave', () => {
      isDraggingKnob = false
      isDraggingScene = false
      renderer.domElement.style.cursor = 'grab'
    })

    // Scroll zoom
    renderer.domElement.addEventListener(
      'wheel',
      (e) => {
        e.preventDefault()
        const delta = e.deltaY > 0 ? 1 : -1
        cameraRadius = Math.max(
          minZoom,
          Math.min(maxZoom, cameraRadius + delta * 0.5)
        )
        updateCameraPosition()
      },
      { passive: false }
    )

    // Touch pinch zoom
    let touchStartDistance = 0
    let initialPinchRadius = cameraRadius

    renderer.domElement.addEventListener(
      'touchstart',
      (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX
          const dy = e.touches[0].clientY - e.touches[1].clientY
          touchStartDistance = Math.sqrt(dx * dx + dy * dy)
          initialPinchRadius = cameraRadius
        }
      },
      { passive: true }
    )

    renderer.domElement.addEventListener(
      'touchmove',
      (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX
          const dy = e.touches[0].clientY - e.touches[1].clientY
          const distance = Math.sqrt(dx * dx + dy * dy)
          const scale = touchStartDistance / distance
          cameraRadius = Math.max(
            minZoom,
            Math.min(maxZoom, initialPinchRadius * scale)
          )
          updateCameraPosition()
        }
      },
      { passive: true }
    )

    // ==================== Event Listeners ====================
    window.addEventListener('album-selected', ((e: CustomEvent) => {
      // Check if already playing before loading new album
      const wasPlaying = isPlaying && isTonearmDown
      loadAlbum(e.detail)

      // If was playing, auto-play the new album's first song after loading
      if (wasPlaying) {
        setTimeout(() => {
          isTonearmDown = true
          animateTonearm(tonearmPlayAngle)
          // Play the first song of the new album
          playSong(0)
        }, 600)
      }
    }) as EventListener)

    // Auto-play album when clicked (first time)
    window.addEventListener('auto-play-album', (() => {
      if (!currentAlbum) return

      // Wait for vinyl placement animation then auto-play
      setTimeout(() => {
        if (!isTonearmDown) {
          isTonearmDown = true
          animateTonearm(tonearmPlayAngle)
          // Play the first song
          playSong(0)
        }
      }, 600)
    }) as EventListener)

    window.addEventListener('song-selected', ((e: CustomEvent) => {
      const { index } = e.detail

      // If tonearm is not down, lower it first
      if (!isTonearmDown && currentAlbum) {
        isTonearmDown = true
        animateTonearm(tonearmPlayAngle)
      }

      playSong(index)
    }) as EventListener)

    window.addEventListener('seek-to', ((e: CustomEvent) => {
      if (audioElement && audioElement.duration) {
        audioElement.currentTime = audioElement.duration * e.detail
      }
    }) as EventListener)

    // ==================== Playback Control ====================
    function loadAlbum(album: Album) {
      currentAlbum = album
      currentSongIndex = 0
      vinylGroup.visible = true

      // Load album cover image onto vinyl
      if (album.cover) {
        updateCoverImage(album.cover)
      }

      // Stop playback and reset audio before loading new album
      if (isPlaying) {
        stopPlayback()
      }

      // Reset audio element to prevent AbortError
      if (audioElement) {
        audioElement.pause()
        audioElement.currentTime = 0
        audioElement.src = ''
      }

      animateVinylPlacement()
    }

    // Event Listeners for controls
    window.addEventListener('seek-to', ((e: CustomEvent) => {
      const percent = e.detail
      if (audioElement && audioElement.duration) {
        audioElement.currentTime = percent * audioElement.duration
      }
    }) as EventListener)

    window.addEventListener('set-playback-rate', ((e: CustomEvent) => {
      const rate = e.detail
      currentPlaybackRate = rate
      if (audioElement) {
        audioElement.playbackRate = rate
      }
    }) as EventListener)

    // Smooth transition play song
    async function playSong(index: number) {
      if (!currentAlbum) return

      // Fade out if playing
      if (isPlaying && audioElement) {
        // Simple fade out
        const fadeOutDuration = 500
        const startVolume = audioElement.volume
        const startTime = performance.now()

        await new Promise<void>((resolve) => {
          const fadeOut = (currentTime: number) => {
            const elapsed = currentTime - startTime
            const progress = Math.min(elapsed / fadeOutDuration, 1)

            if (audioElement) {
              audioElement.volume = startVolume * (1 - progress)
            }

            if (progress < 1) {
              requestAnimationFrame(fadeOut)
            } else {
              resolve()
            }
          }
          requestAnimationFrame(fadeOut)
        })
      }

      currentSongIndex = index
      const song = currentAlbum.songs[index]

      if (!audioElement) {
        audioElement = new Audio()
        audioElement.crossOrigin = 'anonymous'
        audioElement.addEventListener('ended', handleSongEnd)
        audioElement.addEventListener('timeupdate', handleTimeUpdate)
        audioElement.addEventListener('loadedmetadata', () => {
          window.dispatchEvent(
            new CustomEvent('playback-progress', {
              detail: {
                currentTime: 0,
                duration: audioElement?.duration || 0,
                songIndex: currentSongIndex,
              },
            })
          )
        })
      }

      // Pause and reset
      audioElement.pause()
      audioElement.currentTime = 0

      // Set new source and load
      audioElement.src = song.url
      audioElement.volume = volume // Reset volume
      // Apply current playback rate if any (we should store it)
      // For now default to 1 or whatever was set?
      // Let's assume 1 unless we track it.
      // Ideally we should track `currentPlaybackRate`.

      audioElement.load()

      // Only play if tonearm is down
      if (isTonearmDown) {
        const playPromise = audioElement.play()
        if (playPromise !== undefined) {
          playPromise.catch((error) => {
            if (error.name !== 'AbortError') {
              console.error('Playback error:', error)
            }
          })
        }
        isPlaying = true
        window.dispatchEvent(
          new CustomEvent('playback-state', {
            detail: { isPlaying: true, songIndex: currentSongIndex },
          })
        )
      }
    }

    function startPlayback() {
      if (!currentAlbum) return

      isPlaying = true

      if (audioElement && audioElement.src) {
        const playPromise = audioElement.play()
        if (playPromise !== undefined) {
          playPromise.catch((error) => {
            // Ignore AbortError - it's expected when switching songs quickly
            if (error.name !== 'AbortError') {
              console.error('Playback error:', error)
            }
          })
        }
      } else if (currentAlbum) {
        playSong(currentSongIndex)
        return
      }

      window.dispatchEvent(
        new CustomEvent('playback-state', {
          detail: { isPlaying: true, songIndex: currentSongIndex },
        })
      )
    }

    function stopPlayback() {
      isPlaying = false

      if (audioElement) {
        audioElement.pause()
      }

      window.dispatchEvent(
        new CustomEvent('playback-state', {
          detail: { isPlaying: false, songIndex: currentSongIndex },
        })
      )
    }

    // Tonearm toggle control
    function toggleTonearm() {
      if (!currentAlbum) return

      if (isTonearmDown) {
        // Lift tonearm - stop playback
        isTonearmDown = false
        animateTonearm(tonearmRestAngle)
        stopPlayback()
      } else {
        // Lower tonearm - start playback from outer groove
        isTonearmDown = true
        animateTonearm(tonearmPlayAngle)
        startPlayback()
      }
    }

    function handleSongEnd() {
      if (!currentAlbum) return

      currentSongIndex++
      if (currentSongIndex < currentAlbum.songs.length) {
        playSong(currentSongIndex)
      } else {
        currentSongIndex = 0
        stopPlayback()
      }
    }

    function handleTimeUpdate() {
      if (!audioElement) return

      // Update playback progress for UI only
      // Note: Progress tracking removed as it was not being used

      window.dispatchEvent(
        new CustomEvent('playback-progress', {
          detail: {
            currentTime: audioElement.currentTime,
            duration: audioElement.duration,
            songIndex: currentSongIndex,
          },
        })
      )
    }

    // ==================== Animations ====================
    function animateVinylPlacement() {
      vinylGroup.position.y = 2.5
      vinylGroup.scale.set(0.3, 0.3, 0.3)
      vinylGroup.rotation.x = 0.2

      const animate = () => {
        const targetY = 0.65
        const diff = vinylGroup.position.y - targetY

        if (Math.abs(diff) > 0.01) {
          vinylGroup.position.y -= diff * 0.1

          const scale = vinylGroup.scale.x
          if (scale < 1) {
            const newScale = scale + (1 - scale) * 0.1
            vinylGroup.scale.set(newScale, newScale, newScale)
          }

          if (vinylGroup.rotation.x > 0.01) {
            vinylGroup.rotation.x *= 0.85
          }

          requestAnimationFrame(animate)
        } else {
          vinylGroup.position.y = targetY
          vinylGroup.scale.set(1, 1, 1)
          vinylGroup.rotation.x = 0
        }
      }
      animate()
    }

    function animateTonearm(targetAngle: number) {
      const startAngle = tonearmAngle
      const startTime = performance.now()
      const duration = 800 // Smooth animation duration in ms

      // Easing function - ease out cubic for smooth deceleration
      const easeOutCubic = (t: number) => 1 - Math.pow(1 - t, 3)

      const animate = (currentTime: number) => {
        const elapsed = currentTime - startTime
        const progress = Math.min(elapsed / duration, 1)
        const easedProgress = easeOutCubic(progress)

        tonearmAngle = startAngle + (targetAngle - startAngle) * easedProgress
        tonearmGroup.rotation.y = tonearmAngle

        if (progress < 1) {
          requestAnimationFrame(animate)
        } else {
          tonearmAngle = targetAngle
          tonearmGroup.rotation.y = targetAngle
        }
      }

      requestAnimationFrame(animate)
    }

    // ==================== Render Loop ====================
    function animate() {
      requestAnimationFrame(animate)

      // Vinyl rotation - continuous when playing (clockwise from top view)
      if (isPlaying && isTonearmDown && vinylGroup.visible) {
        // Base speed 0.02 is approx 33 RPM at 60fps
        // Adjust based on playback rate
        vinylRotation -= 0.02 * currentPlaybackRate
        vinylGroup.rotation.y = vinylRotation
        platterGroup.rotation.y = vinylRotation
      }

      // Subtle spotlight animation
      const time = Date.now() * 0.001
      spotLight.position.x = Math.sin(time * 0.2) * 0.5
      spotLight.position.z = Math.cos(time * 0.2) * 0.5

      renderer.render(scene, camera)
    }

    animate()

    // ==================== Responsive ====================
    function handleResize() {
      if (!container) return

      const size = getContainerSize()
      camera.aspect = size.width / size.height
      camera.updateProjectionMatrix()
      renderer.setSize(size.width, size.height)
    }

    window.addEventListener('resize', handleResize)

    // Delayed resize to ensure correct container size
    setTimeout(handleResize, 100)

    // ==================== Theme Adaptation ====================
    const updateThemeColors = () => {
      const isDark = document.documentElement.classList.contains('dark')
      const bgColor = getThemeBackgroundColor()

      // Update scene background
      scene.background = new THREE.Color(bgColor)

      // Adjust lighting based on theme
      if (isDark) {
        // Dark theme: brighter lights for contrast
        ambientLight.intensity = 0.4
        spotLight.intensity = 60
        rimLight.intensity = 1.5
        renderer.toneMappingExposure = 1.4
      } else {
        // Light theme: softer lights to avoid overexposure
        ambientLight.intensity = 0.5
        spotLight.intensity = 40
        rimLight.intensity = 1.2
        renderer.toneMappingExposure = 1.1
      }
    }

    // Listen for theme changes
    const themeObserver = new MutationObserver(() => {
      updateThemeColors()
    })

    themeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class'],
    })

    // Initial theme setup
    updateThemeColors()

    // Cleanup
    window.addEventListener('beforeunload', () => {
      themeObserver.disconnect()
      if (audioElement) {
        audioElement.pause()
        audioElement = null
      }
    })
  })
</script>
