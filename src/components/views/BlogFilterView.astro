---
import { render } from 'astro:content'

import Categorizer from '~/components/base/Categorizer.astro'
import ListItem from '~/components/views/ListItem.astro'
import Warning from '~/components/base/Warning.astro'

import {
  getFilteredPosts,
  buildNestedCategoryTree,
  flattenCategoryTree,
  type CategoryTreeNode,
} from '~/utils/data'

import type { CollectionEntry } from 'astro:content'

const WARNING = `No content available for display.`

/* Posts */
const blogItems = await getFilteredPosts('blog')
const categoryTree = buildNestedCategoryTree(blogItems)
const flattenedCategories = flattenCategoryTree(categoryTree)

// 收集所有分类路径用于 JS
const allCategoryPaths = flattenedCategories.map((fc) => fc.node.path)

// 收集所有文章并按树形顺序排列
function collectAllPosts(
  nodes: CategoryTreeNode[]
): CollectionEntry<'blog' | 'changelog'>[] {
  const posts: CollectionEntry<'blog' | 'changelog'>[] = []
  const collectFromNode = (node: CategoryTreeNode) => {
    posts.push(...node.posts)
    node.children.forEach(collectFromNode)
  }
  nodes.forEach(collectFromNode)
  return posts
}

const sortedBlogItems = collectAllPosts(categoryTree)
const isEmpty = sortedBlogItems.length === 0

// 预处理文章数据，添加阅读时间
interface PostWithReadTime {
  post: CollectionEntry<'blog' | 'changelog'>
  minutesRead: number
  categoryPath: string
  globalIdx: number
}

// 收集文章及其分类路径
function collectPostsWithCategory(
  nodes: CategoryTreeNode[]
): { post: CollectionEntry<'blog' | 'changelog'>; categoryPath: string }[] {
  const result: {
    post: CollectionEntry<'blog' | 'changelog'>
    categoryPath: string
  }[] = []
  const collectFromNode = (node: CategoryTreeNode) => {
    node.posts.forEach((post) => {
      result.push({ post, categoryPath: node.path })
    })
    node.children.forEach(collectFromNode)
  }
  nodes.forEach(collectFromNode)
  return result
}

const postsInDisplayOrder = collectPostsWithCategory(categoryTree)

/**
 * Process posts in batches to avoid overwhelming the system
 */
async function processPostsInBatches<T, R>(
  items: T[],
  batchSize: number,
  processor: (item: T, index: number) => Promise<R>
): Promise<R[]> {
  const results: R[] = []
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize)
    const batchResults = await Promise.all(
      batch.map((item, batchIdx) => processor(item, i + batchIdx))
    )
    results.push(...batchResults)
  }
  return results
}

const postsWithReadTime: PostWithReadTime[] = await processPostsInBatches(
  postsInDisplayOrder,
  10, // Process 10 posts at a time
  async ({ post, categoryPath }, globalIdx) => {
    let minutesRead = post.data.minutesRead || 0

    try {
      // Add timeout wrapper to prevent hanging
      const renderResult = await Promise.race([
        render(post),
        new Promise<never>((_, reject) =>
          setTimeout(() => reject(new Error('Render timeout')), 15000)
        ),
      ])

      minutesRead =
        post.data.minutesRead ||
        renderResult.remarkPluginFrontmatter.minutesRead ||
        0
    } catch (error) {
      // Log error but don't fail the entire page
      console.error(`Failed to render post ${post.id}:`, error)
      // Use default value
      minutesRead = post.data.minutesRead || 0
    }

    return {
      post,
      minutesRead,
      categoryPath,
      globalIdx,
    }
  }
)

// 生成树形结构的 JSON 供 JS 使用
const treeDataForJS = JSON.stringify(
  flattenedCategories.map((fc) => ({
    path: fc.node.path,
    depth: fc.depth,
    hasChildren: fc.hasChildren,
    totalPosts: fc.totalPosts,
    postIds: fc.node.posts.map((p) => p.id),
  }))
)
---

{
  isEmpty ? (
    <Warning html={WARNING} />
  ) : (
    <blog-filter-view
      data-categories={JSON.stringify(allCategoryPaths)}
      data-tree={treeDataForJS}
    >
      {/* 左侧分类导航 - 桌面端 */}
      <aside class="category-sidebar lt-lgp:hidden">
        <nav class="toc-desktop toc-desktop-content" id="blog-filter-toc">
          <div class="search-box" id="search-box">
            <button
              type="button"
              class="search-trigger"
              id="search-trigger"
              aria-label="搜索"
            >
              <span class="i-ri-search-line" />
            </button>
            <input
              type="text"
              class="search-input"
              id="sidebar-search-input"
              placeholder="搜索文章..."
              autocomplete="off"
            />
            <button
              type="button"
              class="search-clear hidden"
              id="search-clear"
              aria-label="清除搜索"
            >
              <span class="i-ri-close-line" />
            </button>
          </div>
          <ul id="blog-filter-toc-list" class="category-nav">
            {/* 全部分类选项 */}
            <li class="category-group" data-depth="0">
              <button
                type="button"
                class="category-header active"
                data-category="all"
              >
                <span class="category-name">全部</span>
                <span class="category-count">({sortedBlogItems.length})</span>
              </button>
            </li>
            {/* 树形分类导航 */}
            {flattenedCategories.map(
              ({ node, depth, hasChildren, totalPosts }) => (
                <li
                  class="category-group"
                  data-depth={depth}
                  data-path={node.path}
                >
                  <button
                    type="button"
                    class="category-header"
                    data-category={node.path}
                    data-has-children={hasChildren || node.posts.length > 0}
                    style={`padding-left: ${depth * 0.75}rem`}
                  >
                    {(hasChildren || node.posts.length > 0) && (
                      <span class="expand-icon i-ri-arrow-right-s-line" />
                    )}
                    <span class="category-name">{node.name}</span>
                    <span class="category-count">({totalPosts})</span>
                  </button>
                  {/* 当前分类的文章列表 */}
                  {node.posts.length > 0 && (
                    <ul
                      class="category-posts"
                      style={`padding-left: ${depth * 0.75 + 1.25}rem`}
                    >
                      {node.posts.map((post) => (
                        <li>
                          <a
                            href={`/blog/${post.id}/`}
                            class="post-link"
                            title={post.data.title}
                          >
                            {post.data.title}
                          </a>
                        </li>
                      ))}
                    </ul>
                  )}
                </li>
              )
            )}
          </ul>
        </nav>
      </aside>

      {/* 移动端分类抽屉触发按钮 */}
      <button
        type="button"
        class="category-drawer-trigger hidden lt-lgp:flex"
        id="category-drawer-trigger"
        aria-label="打开分类导航"
      >
        <span class="i-ri-menu-fold-line text-xl" />
      </button>

      {/* 移动端抽屉 */}
      <div class="category-drawer hidden lt-lgp:block" id="category-drawer">
        <div class="drawer-overlay" id="drawer-overlay" />
        <div class="drawer-content">
          <div class="drawer-header">
            <div class="search-box mobile-search-box" id="mobile-search-box">
              <button
                type="button"
                class="search-trigger"
                id="mobile-search-trigger"
                aria-label="搜索"
              >
                <span class="i-ri-search-line" />
              </button>
              <input
                type="text"
                class="search-input"
                id="mobile-sidebar-search-input"
                placeholder="搜索文章..."
                autocomplete="off"
              />
              <button
                type="button"
                class="search-clear hidden"
                id="mobile-search-clear"
                aria-label="清除搜索"
              >
                <span class="i-ri-close-line" />
              </button>
            </div>
            <button
              type="button"
              class="drawer-close"
              id="drawer-close"
              aria-label="收起"
            >
              <span class="i-ri-arrow-left-s-line text-xl" />
            </button>
          </div>
          <ul class="category-nav mobile-nav">
            {/* 全部分类选项 */}
            <li class="category-group" data-depth="0">
              <button
                type="button"
                class="category-header active"
                data-category="all"
              >
                <span class="category-name">全部</span>
                <span class="category-count">({sortedBlogItems.length})</span>
              </button>
            </li>
            {/* 树形分类导航 - 移动端 */}
            {flattenedCategories.map(
              ({ node, depth, hasChildren, totalPosts }) => (
                <li
                  class="category-group"
                  data-depth={depth}
                  data-path={node.path}
                >
                  <button
                    type="button"
                    class="category-header"
                    data-category={node.path}
                    data-has-children={hasChildren || node.posts.length > 0}
                    style={`padding-left: ${depth * 0.75}rem`}
                  >
                    {(hasChildren || node.posts.length > 0) && (
                      <span class="expand-icon i-ri-arrow-right-s-line" />
                    )}
                    <span class="category-name">{node.name}</span>
                    <span class="category-count">({totalPosts})</span>
                  </button>
                  {node.posts.length > 0 && (
                    <ul
                      class="category-posts"
                      style={`padding-left: ${depth * 0.75 + 1.25}rem`}
                    >
                      {node.posts.map((post) => (
                        <li>
                          <a
                            href={`/blog/${post.id}/`}
                            class="post-link"
                            title={post.data.title}
                          >
                            {post.data.title}
                          </a>
                        </li>
                      ))}
                    </ul>
                  )}
                </li>
              )
            )}
          </ul>
        </div>
      </div>

      {/* 文章列表 */}
      <div aria-label="Post list" id="blog-post-list" class="mt-10">
        {postsWithReadTime.map(
          ({ post, minutesRead, categoryPath, globalIdx }, idx) => {
            const { data, id } = post
            const isFirstInCategory =
              idx === 0 ||
              postsWithReadTime[idx - 1]?.categoryPath !== categoryPath

            // 获取显示名称：只显示末级目录名称，去掉数字前缀
            const segments = categoryPath.split('/')
            const lastSegment = segments[segments.length - 1]
            const displayCategory = lastSegment.replace(/^\d+-/, '')

            return (
              <div class="post-item" data-category={categoryPath}>
                {isFirstInCategory && (
                  <Categorizer
                    idx={globalIdx}
                    needId={true}
                    text={displayCategory}
                  />
                )}
                <ListItem
                  idx={globalIdx}
                  collectionType="blog"
                  redirect={data.redirect}
                  postSlug={id}
                  title={data.title}
                  titleIcon={data.titleIcon}
                  video={data.video}
                  radio={data.radio}
                  date={data.pubDate}
                  {minutesRead}
                  platform={data.platform}
                />
              </div>
            )
          }
        )}
      </div>
    </blog-filter-view>
  )
}

<style>
  /* 搜索框样式 - 使用下划线动画 */
  .search-box {
    position: relative;
    display: flex;
    align-items: center;
    margin-bottom: 0.75rem;
    height: 2rem;
  }

  /* 下划线效果 */
  .search-box::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 2rem;
    right: 0;
    height: 1px;
    background: currentColor;
    opacity: 0.2;
    transform: scaleX(0);
    transform-origin: left;
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .search-box.expanded::after {
    transform: scaleX(1);
  }

  /* 搜索触发按钮 */
  .search-trigger {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    flex-shrink: 0;
    background: none;
    border: none;
    cursor: pointer;
    opacity: 0.5;
    font-size: 1rem;
    border-radius: 50%;
    transition:
      opacity 0.2s ease,
      transform 0.2s ease;
  }

  .search-trigger:hover {
    opacity: 1;
  }

  .search-box.expanded .search-trigger {
    opacity: 0.6;
    cursor: default;
    pointer-events: none;
    transform: scale(0.9);
  }

  /* 搜索输入框 */
  .search-input {
    position: absolute;
    left: 2rem;
    right: 1.5rem;
    border: none;
    background: transparent;
    font-size: 0.8125rem;
    color: inherit;
    outline: none;
    padding: 0.25rem 0;
    opacity: 0;
    transform: translateX(-8px);
    pointer-events: none;
    transition:
      opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
      transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .search-box.expanded .search-input {
    opacity: 1;
    transform: translateX(0);
    pointer-events: auto;
  }

  .search-input::placeholder {
    opacity: 0.4;
    color: inherit;
  }

  /* 清除按钮 */
  .search-clear {
    position: absolute;
    right: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5rem;
    height: 1.5rem;
    background: none;
    border: none;
    cursor: pointer;
    opacity: 0;
    font-size: 0.75rem;
    transform: scale(0.8);
    transition:
      opacity 0.2s ease,
      transform 0.2s ease;
  }

  .search-box.expanded .search-clear:not(.hidden) {
    opacity: 0.5;
    transform: scale(1);
  }

  .search-clear:hover {
    opacity: 1 !important;
  }

  .search-clear.hidden {
    display: none;
  }

  /* 移动端搜索框 */
  .mobile-search-box {
    flex: 1;
    margin-right: 0.5rem;
    margin-bottom: 0;
  }

  .mobile-search-box::after {
    left: 1.75rem;
  }

  .mobile-search-box .search-trigger {
    width: 1.75rem;
    height: 1.75rem;
    font-size: 0.9rem;
  }

  .mobile-search-box .search-input {
    left: 1.75rem;
    font-size: 0.875rem;
  }

  /* 搜索匹配项高亮 */
  .search-no-match {
    display: none !important;
  }

  .search-match-highlight {
    background: rgba(255, 200, 0, 0.3);
    border-radius: 2px;
  }

  /* 分类导航样式 */
  .category-nav {
    list-style: none;
    padding: 0;
    padding-right: 0.75rem;
    margin: 0;
    overflow-y: auto;
    max-height: calc(100vh - 10rem);
    scrollbar-width: thin;
    scrollbar-color: rgba(125, 125, 125, 0.3) transparent;
  }

  /* Webkit 滚动条样式 */
  .category-nav::-webkit-scrollbar {
    width: 4px;
  }

  .category-nav::-webkit-scrollbar-track {
    background: transparent;
    border-radius: 2px;
  }

  .category-nav::-webkit-scrollbar-thumb {
    background: rgba(125, 125, 125, 0.25);
    border-radius: 2px;
    transition: background 0.2s;
  }

  .category-nav::-webkit-scrollbar-thumb:hover {
    background: rgba(125, 125, 125, 0.4);
  }

  :global(.dark) .category-nav::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.15);
  }

  :global(.dark) .category-nav::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.25);
  }

  .category-group {
    margin-bottom: 0.25rem;
  }

  .category-header {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    width: 100%;
    padding: 0.375rem 0;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 0.875rem;
    color: inherit;
    opacity: 0.85;
    transition: opacity 0.2s;
    text-align: left;
  }

  .category-header:hover {
    opacity: 1;
  }

  .category-header.active {
    opacity: 1;
    font-weight: 500;
  }

  .expand-icon {
    transition: transform 0.2s;
    font-size: 1rem;
    flex-shrink: 0;
  }

  .category-header.expanded .expand-icon {
    transform: rotate(90deg);
  }

  .category-name {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .category-count {
    opacity: 0.7;
    font-size: 0.75rem;
    flex-shrink: 0;
    padding-right: 0.5rem;
  }

  /* 文章列表缩进 */
  .category-posts {
    list-style: none;
    padding-left: 1.25rem;
    margin: 0;
    overflow: hidden;
    max-height: 0;
    transition: max-height 0.3s ease;
  }

  .category-posts.expanded {
    max-height: 2000px;
  }

  .category-posts li {
    padding: 0.2rem 0;
  }

  .category-posts .post-link {
    font-size: 0.8125rem;
    opacity: 0.75;
    transition: opacity 0.2s;
    display: block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    color: inherit;
    text-decoration: none;
    border-bottom: none !important;
  }

  .category-posts .post-link:hover {
    opacity: 1;
  }

  /* 移动端抽屉触发按钮 */
  .category-drawer-trigger {
    position: fixed;
    bottom: 6rem;
    left: 1.25rem;
    z-index: 40;
    width: 3rem;
    height: 3rem;
    border-radius: 50%;
    background: var(--c-bg);
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(125, 125, 125, 0.2);
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
  }

  .category-drawer-trigger:hover {
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    transform: scale(1.05);
  }

  /* 抽屉遮罩 */
  .drawer-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    z-index: 200;
  }

  /* 抽屉内容 */
  .drawer-content {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 80%;
    max-width: 300px;
    background: var(--c-bg);
    transform: translateX(-100%);
    transition: transform 0.3s ease;
    display: flex;
    flex-direction: column;
    z-index: 201;
    box-shadow: 2px 0 12px rgba(0, 0, 0, 0.1);
  }

  .category-drawer.open .drawer-overlay {
    opacity: 1;
    pointer-events: auto;
  }

  .category-drawer.open .drawer-content {
    transform: translateX(0);
  }

  .drawer-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem;
    border-bottom: 1px solid rgba(125, 125, 125, 0.2);
    flex-shrink: 0;
    background: rgba(255, 255, 255, 0.3);
    backdrop-filter: saturate(180%) blur(12px);
    -webkit-backdrop-filter: saturate(180%) blur(12px);
  }

  :global(.dark) .drawer-header {
    background: rgba(5, 5, 5, 0.3);
  }

  .mobile-nav {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
  }

  .drawer-close {
    background: none;
    border: none;
    cursor: pointer;
    opacity: 0.6;
    transition: opacity 0.2s;
    padding: 0.25rem;
  }

  .drawer-close:hover {
    opacity: 1;
  }

  /* 移动端导航样式调整 */
  .mobile-nav .category-header {
    padding: 0.5rem 0;
  }

  .mobile-nav .category-posts .post-link {
    padding: 0.375rem 0;
  }

  /* 去掉移动端抽屉中列表项的小点和 padding */
  #category-drawer .drawer-content ul li::before {
    display: none;
  }

  #category-drawer .drawer-content ul li {
    padding-left: 0;
  }

  /* 文章列表项隐藏 */
  .post-item.hidden {
    display: none;
  }
</style>

<script>
  class BlogFilterView extends HTMLElement {
    private categories: string[] = []
    private expandedCategories: Set<string> = new Set<string>()
    private searchTimeout: ReturnType<typeof setTimeout> | null = null
    private readonly DEBOUNCE_DELAY = 300

    connectedCallback() {
      this.categories = JSON.parse(this.dataset.categories || '[]')
      this.init()
    }

    private init() {
      this.setupCategoryHeaders()
      this.setupDrawer()
      this.setupSearch()
      this.restoreCategoryFromStorage()
      this.restoreExpandedFromStorage()
    }

    // 防抖函数
    private debounce(fn: () => void) {
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout)
      }
      this.searchTimeout = setTimeout(fn, this.DEBOUNCE_DELAY)
    }

    private setupSearch() {
      // 桌面端搜索
      const searchBox = document.querySelector('#search-box')
      const searchTrigger = document.querySelector('#search-trigger')
      const desktopInput = document.querySelector(
        '#sidebar-search-input'
      ) as HTMLInputElement
      const desktopClear = document.querySelector('#search-clear')

      // 移动端搜索
      const mobileSearchBox = document.querySelector('#mobile-search-box')
      const mobileSearchTrigger = document.querySelector(
        '#mobile-search-trigger'
      )
      const mobileInput = document.querySelector(
        '#mobile-sidebar-search-input'
      ) as HTMLInputElement
      const mobileClear = document.querySelector('#mobile-search-clear')

      // 通用的搜索框展开/收起逻辑
      const setupSearchBox = (
        box: Element | null,
        trigger: Element | null,
        input: HTMLInputElement | null,
        clearBtn: Element | null,
        otherInput: HTMLInputElement | null,
        otherClearBtn: Element | null
      ) => {
        if (!box || !input) return

        const expand = () => {
          box.classList.add('expanded')
          setTimeout(() => input.focus(), 50)
        }

        const collapse = () => {
          if (!input.value) {
            box.classList.remove('expanded')
          }
        }

        trigger?.addEventListener('click', (e) => {
          e.stopPropagation()
          expand()
        })

        input.addEventListener('focus', expand)
        input.addEventListener('blur', () => setTimeout(collapse, 150))

        input.addEventListener('input', () => {
          this.debounce(() => {
            this.filterBySearch(input.value.trim())
          })
          // 同步另一个输入框
          if (otherInput) otherInput.value = input.value
          // 显示/隐藏清除按钮
          const showClear = !!input.value
          clearBtn?.classList.toggle('hidden', !showClear)
          otherClearBtn?.classList.toggle('hidden', !showClear)
        })

        clearBtn?.addEventListener('click', (e) => {
          e.stopPropagation()
          input.value = ''
          if (otherInput) otherInput.value = ''
          clearBtn.classList.add('hidden')
          otherClearBtn?.classList.add('hidden')
          this.filterBySearch('')
          box.classList.remove('expanded')
        })
      }

      // 设置桌面端搜索框
      setupSearchBox(
        searchBox,
        searchTrigger,
        desktopInput,
        desktopClear,
        mobileInput,
        mobileClear
      )
      // 设置移动端搜索框
      setupSearchBox(
        mobileSearchBox,
        mobileSearchTrigger,
        mobileInput,
        mobileClear,
        desktopInput,
        desktopClear
      )
    }

    private filterBySearch(keyword: string) {
      const lowerKeyword = keyword.toLowerCase()

      // 过滤侧边栏的分类和文章
      this.filterSidebarBySearch(lowerKeyword)

      // 过滤主内容区的文章
      this.filterPostsBySearch(lowerKeyword)
    }

    private filterSidebarBySearch(keyword: string) {
      const categoryGroups = this.querySelectorAll('.category-group')

      categoryGroups.forEach((group) => {
        const header = group.querySelector('.category-header') as HTMLElement
        const category = header?.dataset.category

        // "全部"选项特殊处理
        if (category === 'all') {
          if (!keyword) {
            group.classList.remove('search-no-match')
          } else {
            group.classList.add('search-no-match')
          }
          return
        }

        const categoryName =
          header?.querySelector('.category-name')?.textContent || ''
        const postLinks = group.querySelectorAll('.post-link')
        let hasMatch = false
        let matchCount = 0

        // 检查分类名是否匹配
        if (categoryName.toLowerCase().includes(keyword)) {
          hasMatch = true
        }

        // 检查文章标题是否匹配
        postLinks.forEach((link) => {
          const title = link.textContent || ''
          if (!keyword || title.toLowerCase().includes(keyword)) {
            ;(link as HTMLElement).parentElement?.classList.remove(
              'search-no-match'
            )
            if (keyword) matchCount++
            hasMatch = true
          } else {
            ;(link as HTMLElement).parentElement?.classList.add(
              'search-no-match'
            )
          }
        })

        // 显示/隐藏分类组
        if (!keyword || hasMatch) {
          group.classList.remove('search-no-match')
          // 如果有搜索关键词且有匹配，自动展开
          if (keyword && matchCount > 0) {
            const postsContainer = header?.nextElementSibling as HTMLElement
            if (postsContainer?.classList.contains('category-posts')) {
              postsContainer.classList.add('expanded')
              header?.classList.add('expanded')
            }
          }
        } else {
          group.classList.add('search-no-match')
        }
      })
    }

    private filterPostsBySearch(keyword: string) {
      const postItems = this.querySelectorAll('.post-item')
      const categoryFirstPost = new Map<string, boolean>()

      postItems.forEach((item) => {
        const itemElement = item as HTMLElement
        const categorizer = item.querySelector('.toc-heading')
        const titleElement = item.querySelector('.flex-grow a, .flex-grow span')
        const title = titleElement?.textContent || ''
        const itemCategory = itemElement.dataset.category || ''

        if (!keyword || title.toLowerCase().includes(keyword)) {
          item.classList.remove('hidden')
          // 显示分类标题（如果是该分类的第一篇可见文章）
          if (categorizer) {
            if (!categoryFirstPost.has(itemCategory)) {
              categoryFirstPost.set(itemCategory, true)
              ;(categorizer as HTMLElement).style.display = ''
            }
          }
        } else {
          item.classList.add('hidden')
          if (categorizer) {
            ;(categorizer as HTMLElement).style.display = 'none'
          }
        }
      })

      // 如果有搜索关键词，重置分类筛选到"全部"
      if (keyword) {
        localStorage.setItem('blog-filter-category', 'all')
      }
    }

    private setupCategoryHeaders() {
      // 桌面端和移动端的分类头部
      const headers = this.querySelectorAll('.category-header')
      headers.forEach((header) => {
        header.addEventListener('click', () => {
          const category = (header as HTMLElement).dataset.category || 'all'
          const hasExpandIcon = header.querySelector('.expand-icon')

          // 如果有展开图标（非"全部"选项），切换展开状态
          if (hasExpandIcon) {
            this.toggleCategoryExpand(category, header as HTMLElement)
          }

          // 筛选文章
          this.filterByCategory(category)
          this.updateActiveCategory(category)
        })
      })
    }

    private setupDrawer() {
      const trigger = document.querySelector('#category-drawer-trigger')
      const drawer = document.querySelector('#category-drawer')
      const overlay = document.querySelector('#drawer-overlay')
      const closeBtn = document.querySelector('#drawer-close')

      trigger?.addEventListener('click', () => {
        drawer?.classList.add('open')
      })

      const closeDrawer = () => {
        drawer?.classList.remove('open')
      }

      overlay?.addEventListener('click', closeDrawer)
      closeBtn?.addEventListener('click', closeDrawer)
    }

    private toggleCategoryExpand(category: string, header: HTMLElement) {
      const postsContainer = header.nextElementSibling as HTMLElement
      if (!postsContainer) return

      const isExpanded = postsContainer.classList.contains('expanded')

      if (isExpanded) {
        postsContainer.classList.remove('expanded')
        header.classList.remove('expanded')
        this.expandedCategories.delete(category)
      } else {
        postsContainer.classList.add('expanded')
        header.classList.add('expanded')
        this.expandedCategories.add(category)
      }

      this.saveExpandedToStorage()
    }

    private updateActiveCategory(category: string) {
      // 更新桌面端和移动端的激活状态
      const allHeaders = this.querySelectorAll('.category-header')
      allHeaders.forEach((header) => {
        const headerCategory = (header as HTMLElement).dataset.category || 'all'
        if (headerCategory === category) {
          header.classList.add('active')
        } else {
          header.classList.remove('active')
        }
      })
    }

    private restoreCategoryFromStorage() {
      const savedCategory = localStorage.getItem('blog-filter-category')
      const categoryToRestore =
        savedCategory &&
        (savedCategory === 'all' || this.categories.includes(savedCategory))
          ? savedCategory
          : 'all'

      if (categoryToRestore !== 'all') {
        this.filterByCategory(categoryToRestore)
      }
      this.updateActiveCategory(categoryToRestore)
    }

    private restoreExpandedFromStorage() {
      try {
        const saved = localStorage.getItem('blog-filter-expanded')
        if (saved) {
          const expandedArray = JSON.parse(saved) as string[]
          this.expandedCategories = new Set(expandedArray)

          // 恢复展开状态
          expandedArray.forEach((category) => {
            const headers = this.querySelectorAll(
              `.category-header[data-category="${category}"]`
            )
            headers.forEach((header) => {
              const postsContainer = header.nextElementSibling as HTMLElement
              if (postsContainer?.classList.contains('category-posts')) {
                postsContainer.classList.add('expanded')
                header.classList.add('expanded')
              }
            })
          })
        }
      } catch {
        // ignore
      }
    }

    private saveExpandedToStorage() {
      localStorage.setItem(
        'blog-filter-expanded',
        JSON.stringify([...this.expandedCategories])
      )
    }

    private filterByCategory(category: string) {
      // 保存到 localStorage
      localStorage.setItem('blog-filter-category', category)
      const postItems = this.querySelectorAll('.post-item')

      // 用于追踪每个分类的第一篇文章
      const categoryFirstPost = new Map<string, boolean>()

      postItems.forEach((item) => {
        const itemCategory = (item as HTMLElement).dataset.category || ''
        const categorizer = item.querySelector('.toc-heading')

        if (category === 'all') {
          // 显示所有文章
          item.classList.remove('hidden')
          // 显示分类标题（如果是该分类的第一篇）
          if (categorizer) {
            if (!categoryFirstPost.has(itemCategory)) {
              categoryFirstPost.set(itemCategory, true)
              ;(categorizer as HTMLElement).style.display = ''
            }
          }
        } else {
          // 支持路径前缀匹配：选择 'vue' 应显示 'vue/01-xxx' 下的所有文章
          const isMatch =
            itemCategory === category || itemCategory.startsWith(category + '/')

          if (isMatch) {
            item.classList.remove('hidden')
            // 显示分类标题（如果是该分类的第一篇）
            if (categorizer) {
              if (!categoryFirstPost.has(itemCategory)) {
                categoryFirstPost.set(itemCategory, true)
                ;(categorizer as HTMLElement).style.display = ''
              }
            }
          } else {
            item.classList.add('hidden')
            if (categorizer) {
              ;(categorizer as HTMLElement).style.display = 'none'
            }
          }
        }
      })
    }
  }

  customElements.define('blog-filter-view', BlogFilterView)
</script>
